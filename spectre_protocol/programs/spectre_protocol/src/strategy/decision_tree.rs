//! Decision Tree Trading Strategy
//!
//! A deterministic trading strategy that makes decisions based on:
//! - Market price relative to fair value
//! - Price trend (momentum)
//! - Market volatility
//!
//! The strategy is designed to be:
//! - Auditable: Clear, interpretable decision logic
//! - Deterministic: Same inputs always produce same outputs
//! - Configurable: Parameters can be adjusted without recompilation
//!
//! ## Trading Logic
//!
//! 1. If volatility exceeds cap → HOLD (too risky)
//! 2. If price < low threshold AND trend > 0 → BUY
//! 3. If price > high threshold AND trend < 0 → SELL
//! 4. Strong signals require multiple confirming conditions
//!
//! ## Example
//!
//! ```ignore
//! let params = StrategyParams::default();
//! let signal = run_inference(0.30, 0.2, 0.1, &params);
//! assert_eq!(signal, TradeSignal::Buy);
//! ```

use anchor_lang::prelude::*;

/// Trade signal generated by the strategy
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq, Debug, InitSpace)]
pub enum TradeSignal {
    /// Strong buy signal - high confidence, use larger position
    StrongBuy,
    /// Normal buy signal - moderate confidence
    Buy,
    /// Hold - no action recommended
    Hold,
    /// Normal sell signal - moderate confidence
    Sell,
    /// Strong sell signal - high confidence, use larger position
    StrongSell,
}

impl Default for TradeSignal {
    fn default() -> Self {
        TradeSignal::Hold
    }
}

impl TradeSignal {
    /// Check if this is a buy signal (normal or strong)
    pub fn is_buy(&self) -> bool {
        matches!(self, TradeSignal::StrongBuy | TradeSignal::Buy)
    }

    /// Check if this is a sell signal (normal or strong)
    pub fn is_sell(&self) -> bool {
        matches!(self, TradeSignal::StrongSell | TradeSignal::Sell)
    }

    /// Check if this is a strong signal (buy or sell)
    pub fn is_strong(&self) -> bool {
        matches!(self, TradeSignal::StrongBuy | TradeSignal::StrongSell)
    }

    /// Check if this is a hold signal
    pub fn is_hold(&self) -> bool {
        matches!(self, TradeSignal::Hold)
    }

    /// Convert signal to position sizing multiplier
    /// Strong signals use 2x position size
    pub fn position_multiplier(&self) -> u64 {
        if self.is_strong() { 2 } else { 1 }
    }
}

/// Strategy configuration parameters
///
/// All thresholds use fixed-point representation scaled by 1000
/// (e.g., 350 represents 0.35)
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, InitSpace)]
pub struct StrategyParams {
    /// Price threshold below which we consider buying (scaled by 1000)
    /// Default: 350 (0.35)
    pub price_threshold_low: u32,

    /// Price threshold above which we consider selling (scaled by 1000)
    /// Default: 650 (0.65)
    pub price_threshold_high: u32,

    /// Minimum trend magnitude for strong signals (scaled by 1000)
    /// Default: 100 (0.1)
    pub trend_threshold: u32,

    /// Maximum volatility above which we hold (scaled by 1000)
    /// Default: 400 (0.4)
    pub volatility_cap: u32,

    /// Reserved for future parameters
    pub _reserved: [u8; 16],
}

impl Default for StrategyParams {
    fn default() -> Self {
        Self {
            price_threshold_low: 350,   // 0.35
            price_threshold_high: 650,  // 0.65
            trend_threshold: 100,       // 0.1
            volatility_cap: 400,        // 0.4
            _reserved: [0u8; 16],
        }
    }
}

impl StrategyParams {
    /// Create new strategy params with custom thresholds
    pub fn new(
        price_threshold_low: u32,
        price_threshold_high: u32,
        trend_threshold: u32,
        volatility_cap: u32,
    ) -> Self {
        Self {
            price_threshold_low,
            price_threshold_high,
            trend_threshold,
            volatility_cap,
            _reserved: [0u8; 16],
        }
    }

    /// Validate that parameters are sensible
    pub fn validate(&self) -> bool {
        // Low threshold should be less than high threshold
        if self.price_threshold_low >= self.price_threshold_high {
            return false;
        }

        // Thresholds should be within valid range (0-1000)
        if self.price_threshold_low > 1000 || self.price_threshold_high > 1000 {
            return false;
        }

        // Trend threshold should be reasonable
        if self.trend_threshold > 500 {
            return false;
        }

        // Volatility cap should be reasonable
        if self.volatility_cap > 1000 || self.volatility_cap == 0 {
            return false;
        }

        true
    }

    /// Create aggressive params (wider thresholds, higher volatility tolerance)
    pub fn aggressive() -> Self {
        Self {
            price_threshold_low: 400,   // 0.40
            price_threshold_high: 600,  // 0.60
            trend_threshold: 50,        // 0.05
            volatility_cap: 500,        // 0.5
            _reserved: [0u8; 16],
        }
    }

    /// Create conservative params (tighter thresholds, lower volatility tolerance)
    pub fn conservative() -> Self {
        Self {
            price_threshold_low: 300,   // 0.30
            price_threshold_high: 700,  // 0.70
            trend_threshold: 150,       // 0.15
            volatility_cap: 300,        // 0.3
            _reserved: [0u8; 16],
        }
    }
}

/// Market data input for strategy inference
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, InitSpace)]
pub struct MarketInput {
    /// Current YES price scaled by 1000 (0-1000 representing 0-1)
    pub price: u32,

    /// Price trend (current - previous) scaled by 1000
    /// Range: -1000 to +1000 (representing -1 to +1)
    pub trend: i32,

    /// Market volatility scaled by 1000 (0-1000 representing 0-1)
    pub volatility: u32,

    /// Timestamp of the market data
    pub timestamp: i64,
}

impl MarketInput {
    /// Create new market input with validation
    pub fn new(price: u32, trend: i32, volatility: u32, timestamp: i64) -> Option<Self> {
        // Validate ranges
        if price > 1000 || volatility > 1000 {
            return None;
        }
        if trend < -1000 || trend > 1000 {
            return None;
        }

        Some(Self {
            price,
            trend,
            volatility,
            timestamp,
        })
    }

    /// Create from floating point values (for testing/convenience)
    pub fn from_floats(price: f32, trend: f32, volatility: f32, timestamp: i64) -> Option<Self> {
        if price < 0.0 || price > 1.0 || volatility < 0.0 || volatility > 1.0 {
            return None;
        }
        if trend < -1.0 || trend > 1.0 {
            return None;
        }

        Some(Self {
            price: (price * 1000.0) as u32,
            trend: (trend * 1000.0) as i32,
            volatility: (volatility * 1000.0) as u32,
            timestamp,
        })
    }
}

/// Run the decision tree inference algorithm
///
/// # Arguments
/// * `input` - Market data input
/// * `params` - Strategy configuration parameters
///
/// # Returns
/// * `TradeSignal` - The recommended trading action
///
/// # Algorithm
///
/// 1. **Volatility Check**: If volatility > cap → Hold
/// 2. **Strong Buy**: price < low_threshold AND trend > trend_threshold AND volatility < cap/2
/// 3. **Buy**: price < low_threshold AND trend > 0
/// 4. **Strong Sell**: price > high_threshold AND trend < -trend_threshold AND volatility < cap/2
/// 5. **Sell**: price > high_threshold AND trend < 0
/// 6. **Default**: Hold
pub fn run_inference(input: &MarketInput, params: &StrategyParams) -> TradeSignal {
    let price = input.price;
    let trend = input.trend;
    let volatility = input.volatility;

    // 1. High volatility = be cautious
    if volatility > params.volatility_cap {
        return TradeSignal::Hold;
    }

    let half_vol_cap = params.volatility_cap / 2;
    let trend_threshold = params.trend_threshold as i32;

    // 2. Strong buy: underpriced + positive trend + low volatility
    if price < params.price_threshold_low
        && trend > trend_threshold
        && volatility < half_vol_cap
    {
        return TradeSignal::StrongBuy;
    }

    // 3. Buy: underpriced + any positive trend
    if price < params.price_threshold_low && trend > 0 {
        return TradeSignal::Buy;
    }

    // 4. Strong sell: overpriced + negative trend + low volatility
    if price > params.price_threshold_high
        && trend < -trend_threshold
        && volatility < half_vol_cap
    {
        return TradeSignal::StrongSell;
    }

    // 5. Sell: overpriced + any negative trend
    if price > params.price_threshold_high && trend < 0 {
        return TradeSignal::Sell;
    }

    // 6. Default: Hold
    TradeSignal::Hold
}

/// Convenience function using floating point inputs
///
/// This converts f32 values to the scaled integer format used by the strategy.
/// Useful for testing and external integrations.
pub fn run_inference_f32(
    market_price: f32,
    trend: f32,
    volatility: f32,
    params: &StrategyParams,
) -> TradeSignal {
    let input = match MarketInput::from_floats(market_price, trend, volatility, 0) {
        Some(input) => input,
        None => return TradeSignal::Hold, // Invalid input = Hold
    };
    run_inference(&input, params)
}

#[cfg(test)]
mod tests {
    use super::*;

    // ==========================================
    // StrategyParams Tests
    // ==========================================

    #[test]
    fn test_default_params() {
        let params = StrategyParams::default();
        assert_eq!(params.price_threshold_low, 350);
        assert_eq!(params.price_threshold_high, 650);
        assert_eq!(params.trend_threshold, 100);
        assert_eq!(params.volatility_cap, 400);
        assert!(params.validate());
    }

    #[test]
    fn test_aggressive_params() {
        let params = StrategyParams::aggressive();
        assert_eq!(params.price_threshold_low, 400);
        assert_eq!(params.price_threshold_high, 600);
        assert!(params.validate());
    }

    #[test]
    fn test_conservative_params() {
        let params = StrategyParams::conservative();
        assert_eq!(params.price_threshold_low, 300);
        assert_eq!(params.price_threshold_high, 700);
        assert!(params.validate());
    }

    #[test]
    fn test_invalid_params() {
        // Low > High
        let invalid = StrategyParams::new(700, 300, 100, 400);
        assert!(!invalid.validate());

        // Low == High
        let invalid = StrategyParams::new(500, 500, 100, 400);
        assert!(!invalid.validate());

        // Out of range
        let invalid = StrategyParams::new(350, 1100, 100, 400);
        assert!(!invalid.validate());

        // Zero volatility cap
        let invalid = StrategyParams::new(350, 650, 100, 0);
        assert!(!invalid.validate());
    }

    #[test]
    fn test_custom_params() {
        let custom = StrategyParams::new(250, 750, 150, 350);
        assert!(custom.validate());
        assert_eq!(custom.price_threshold_low, 250);
        assert_eq!(custom.price_threshold_high, 750);
    }

    // ==========================================
    // TradeSignal Tests
    // ==========================================

    #[test]
    fn test_signal_is_buy() {
        assert!(TradeSignal::StrongBuy.is_buy());
        assert!(TradeSignal::Buy.is_buy());
        assert!(!TradeSignal::Hold.is_buy());
        assert!(!TradeSignal::Sell.is_buy());
        assert!(!TradeSignal::StrongSell.is_buy());
    }

    #[test]
    fn test_signal_is_sell() {
        assert!(!TradeSignal::StrongBuy.is_sell());
        assert!(!TradeSignal::Buy.is_sell());
        assert!(!TradeSignal::Hold.is_sell());
        assert!(TradeSignal::Sell.is_sell());
        assert!(TradeSignal::StrongSell.is_sell());
    }

    #[test]
    fn test_signal_is_strong() {
        assert!(TradeSignal::StrongBuy.is_strong());
        assert!(!TradeSignal::Buy.is_strong());
        assert!(!TradeSignal::Hold.is_strong());
        assert!(!TradeSignal::Sell.is_strong());
        assert!(TradeSignal::StrongSell.is_strong());
    }

    #[test]
    fn test_signal_position_multiplier() {
        assert_eq!(TradeSignal::StrongBuy.position_multiplier(), 2);
        assert_eq!(TradeSignal::Buy.position_multiplier(), 1);
        assert_eq!(TradeSignal::Hold.position_multiplier(), 1);
        assert_eq!(TradeSignal::Sell.position_multiplier(), 1);
        assert_eq!(TradeSignal::StrongSell.position_multiplier(), 2);
    }

    // ==========================================
    // MarketInput Tests
    // ==========================================

    #[test]
    fn test_market_input_valid() {
        let input = MarketInput::new(500, 100, 200, 12345);
        assert!(input.is_some());
        let input = input.unwrap();
        assert_eq!(input.price, 500);
        assert_eq!(input.trend, 100);
        assert_eq!(input.volatility, 200);
    }

    #[test]
    fn test_market_input_invalid() {
        // Price too high
        assert!(MarketInput::new(1100, 100, 200, 0).is_none());

        // Volatility too high
        assert!(MarketInput::new(500, 100, 1100, 0).is_none());

        // Trend too high
        assert!(MarketInput::new(500, 1100, 200, 0).is_none());

        // Trend too low
        assert!(MarketInput::new(500, -1100, 200, 0).is_none());
    }

    #[test]
    fn test_market_input_from_floats() {
        let input = MarketInput::from_floats(0.5, 0.1, 0.2, 12345);
        assert!(input.is_some());
        let input = input.unwrap();
        assert_eq!(input.price, 500);
        assert_eq!(input.trend, 100);
        assert_eq!(input.volatility, 200);
    }

    // ==========================================
    // Decision Tree Inference Tests
    // ==========================================

    #[test]
    fn test_buy_signal() {
        let params = StrategyParams::default();
        // Price < 0.35 (350), trend > 0, normal volatility
        let signal = run_inference_f32(0.30, 0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Buy);
    }

    #[test]
    fn test_strong_buy_signal() {
        let params = StrategyParams::default();
        // Price < 0.35, trend > 0.1, volatility < 0.2 (half of 0.4)
        let signal = run_inference_f32(0.25, 0.15, 0.1, &params);
        assert_eq!(signal, TradeSignal::StrongBuy);
    }

    #[test]
    fn test_sell_signal() {
        let params = StrategyParams::default();
        // Price > 0.65 (650), trend < 0
        let signal = run_inference_f32(0.70, -0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Sell);
    }

    #[test]
    fn test_strong_sell_signal() {
        let params = StrategyParams::default();
        // Price > 0.65, trend < -0.1, volatility < 0.2
        let signal = run_inference_f32(0.75, -0.15, 0.1, &params);
        assert_eq!(signal, TradeSignal::StrongSell);
    }

    #[test]
    fn test_hold_high_volatility() {
        let params = StrategyParams::default();
        // Even with good buy conditions, high volatility = Hold
        let signal = run_inference_f32(0.25, 0.15, 0.5, &params);
        assert_eq!(signal, TradeSignal::Hold);
    }

    #[test]
    fn test_hold_neutral_price() {
        let params = StrategyParams::default();
        // Price in neutral zone
        let signal = run_inference_f32(0.50, 0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Hold);
    }

    #[test]
    fn test_hold_wrong_trend() {
        let params = StrategyParams::default();
        // Low price but negative trend
        let signal = run_inference_f32(0.30, -0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Hold);

        // High price but positive trend
        let signal = run_inference_f32(0.70, 0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Hold);
    }

    #[test]
    fn test_edge_cases_price_thresholds() {
        let params = StrategyParams::default();

        // Exactly at low threshold - no buy (must be below)
        let signal = run_inference_f32(0.35, 0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Hold);

        // Just below low threshold - buy
        let signal = run_inference_f32(0.349, 0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Buy);

        // Exactly at high threshold - no sell (must be above)
        let signal = run_inference_f32(0.65, -0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Hold);

        // Just above high threshold - sell
        let signal = run_inference_f32(0.651, -0.05, 0.2, &params);
        assert_eq!(signal, TradeSignal::Sell);
    }

    #[test]
    fn test_determinism() {
        // Same inputs must always produce same outputs
        let params = StrategyParams::default();

        for _ in 0..100 {
            let signal1 = run_inference_f32(0.30, 0.15, 0.1, &params);
            let signal2 = run_inference_f32(0.30, 0.15, 0.1, &params);
            assert_eq!(signal1, signal2);
            assert_eq!(signal1, TradeSignal::StrongBuy);
        }
    }

    #[test]
    fn test_with_custom_params() {
        // Aggressive params: wider entry zones
        let aggressive = StrategyParams::aggressive();

        // Price 0.39 is below low threshold (0.4) for aggressive
        // With trend 0.06 > 0.05 and vol 0.2 < 0.25 (half of 0.5), this is StrongBuy
        let signal = run_inference_f32(0.39, 0.06, 0.2, &aggressive);
        assert_eq!(signal, TradeSignal::StrongBuy);

        // With high volatility (above half cap), it's just Buy
        let signal = run_inference_f32(0.39, 0.06, 0.3, &aggressive);
        assert_eq!(signal, TradeSignal::Buy);

        // But for default (0.35 threshold), 0.39 is above threshold, so Hold
        let default = StrategyParams::default();
        let signal = run_inference_f32(0.39, 0.06, 0.2, &default);
        assert_eq!(signal, TradeSignal::Hold);
    }

    #[test]
    fn test_conservative_params_behavior() {
        let conservative = StrategyParams::conservative();

        // Needs stronger trend for strong signals
        let signal = run_inference_f32(0.25, 0.12, 0.1, &conservative);
        // Trend 0.12 is less than conservative threshold 0.15, so not strong
        assert_eq!(signal, TradeSignal::Buy);

        // With sufficient trend, gets strong signal
        let signal = run_inference_f32(0.25, 0.20, 0.1, &conservative);
        assert_eq!(signal, TradeSignal::StrongBuy);
    }

    #[test]
    fn test_scaled_integer_vs_float() {
        let params = StrategyParams::default();

        // Test that scaled integers produce same result as floats
        let input = MarketInput::new(300, 150, 100, 0).unwrap();
        let signal1 = run_inference(&input, &params);
        let signal2 = run_inference_f32(0.30, 0.15, 0.1, &params);

        assert_eq!(signal1, signal2);
        assert_eq!(signal1, TradeSignal::StrongBuy);
    }

    #[test]
    fn test_extreme_inputs() {
        let params = StrategyParams::default();

        // Minimum price, maximum positive trend, minimum volatility
        let signal = run_inference_f32(0.0, 1.0, 0.0, &params);
        assert_eq!(signal, TradeSignal::StrongBuy);

        // Maximum price, maximum negative trend, minimum volatility
        let signal = run_inference_f32(1.0, -1.0, 0.0, &params);
        assert_eq!(signal, TradeSignal::StrongSell);

        // Any conditions with maximum volatility = Hold
        let signal = run_inference_f32(0.0, 1.0, 1.0, &params);
        assert_eq!(signal, TradeSignal::Hold);
    }
}
