const ks=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];function ai(e,t){if(!t||t==10)return BigInt(e);if(t==16)return e.slice(0,2)=="0x"?BigInt(e):BigInt("0x"+e)}const en=ai;function $s(e,t){let n=BigInt(0);t=BigInt(t);for(let a=0;a<e.length;a++)n=n*t+BigInt(e[a]);return n}function Oa(e){const t=e.toString(16);return(t.length-1)*4+ks[parseInt(t[0],16)]}function po(e){return BigInt(e)<BigInt(0)}function wo(e){return!e}function Wa(e,t){return BigInt(e)<<BigInt(t)}function na(e,t){return BigInt(e)>>BigInt(t)}const Ns=Wa,Vs=na;function ae(e){return(BigInt(e)&BigInt(1))==BigInt(1)}function Zs(e){let t=BigInt(e);const n=[];for(;t;){if(t&BigInt(1)){const a=2-Number(t%BigInt(4));n.push(a),t=t-BigInt(a)}else n.push(0);t=t>>BigInt(1)}return n}function Lo(e){let t=BigInt(e);const n=[];for(;t;)t&BigInt(1)?n.push(1):n.push(0),t=t>>BigInt(1);return n}function go(e){if(e>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Number too big");return Number(e)}function js(e,t){const n=[];let a=BigInt(e);for(t=BigInt(t);a;)n.unshift(Number(a%t)),a=a/t;return n}function ie(e,t){return BigInt(e)+BigInt(t)}function Gn(e,t){return BigInt(e)-BigInt(t)}function mo(e){return-BigInt(e)}function bo(e,t){return BigInt(e)*BigInt(t)}function Hs(e){return BigInt(e)*BigInt(e)}function za(e,t){return BigInt(e)**BigInt(t)}function Ws(e,t){return BigInt(e)**BigInt(t)}function Qs(e){return BigInt(e)>=0?BigInt(e):-BigInt(e)}function ea(e,t){return BigInt(e)/BigInt(t)}function vn(e,t){return BigInt(e)%BigInt(t)}function In(e,t){return BigInt(e)==BigInt(t)}function Ds(e,t){return BigInt(e)!=BigInt(t)}function Ks(e,t){return BigInt(e)<BigInt(t)}function Mi(e,t){return BigInt(e)>BigInt(t)}function Xs(e,t){return BigInt(e)<=BigInt(t)}function yo(e,t){return BigInt(e)>=BigInt(t)}function ee(e,t){return BigInt(e)&BigInt(t)}function Ys(e,t){return BigInt(e)|BigInt(t)}function Js(e,t){return BigInt(e)^BigInt(t)}function tc(e,t){return BigInt(e)&&BigInt(t)}function nc(e,t){return BigInt(e)||BigInt(t)}function ac(e){return!BigInt(e)}function Ga(e,t,n,a){const i="0000000"+n.toString(16),o=new Uint32Array(e.buffer,e.byteOffset+t,a/4),l=((i.length-7)*4-1>>5)+1;for(let s=0;s<l;s++)o[s]=parseInt(i.substring(i.length-8*s-8,i.length-8*s),16);for(let s=l;s<o.length;s++)o[s]=0;for(let s=o.length*4;s<a;s++)e[s]=go(ee(na(n,s*8),255))}function Co(e,t,n,a){const i="0000000"+n.toString(16),o=new DataView(e.buffer,e.byteOffset+t,a),l=((i.length-7)*4-1>>5)+1;for(let s=0;s<l;s++)o.setUint32(a-s*4-4,parseInt(i.substring(i.length-8*s-8,i.length-8*s),16),!1);for(let s=0;s<a/4-l;s++)o[s]=0}function Ta(e,t,n){n=n||e.byteLength,t=t||0;const a=new Uint32Array(e.buffer,e.byteOffset+t,n/4),i=new Array(n/4);return a.forEach((o,l)=>i[i.length-l-1]=o.toString(16).padStart(8,"0")),ai(i.join(""),16)}function Fo(e,t,n){n=n||e.byteLength,t=t||0;const a=new DataView(e.buffer,e.byteOffset+t,n),i=new Array(n/4);for(let o=0;o<n/4;o++)i[o]=a.getUint32(o*4,!1).toString(16).padStart(8,"0");return ai(i.join(""),16)}function oe(e,t){return e.toString(t)}function oa(e){const t=new Uint8Array(Math.floor((Oa(e)-1)/8)+1);return Ga(t,0,e,t.byteLength),t}const So=en(0),jn=en(1);var ic=Object.freeze({__proto__:null,abs:Qs,add:ie,band:ee,bitLength:Oa,bits:Lo,bor:Ys,bxor:Js,div:ea,e:en,eq:In,exp:Ws,fromArray:$s,fromRprBE:Fo,fromRprLE:Ta,fromString:ai,geq:yo,gt:Mi,isNegative:po,isOdd:ae,isZero:wo,land:tc,leq:Xs,lnot:ac,lor:nc,lt:Ks,mod:vn,mul:bo,naf:Zs,neg:mo,neq:Ds,one:jn,pow:za,shiftLeft:Wa,shiftRight:na,shl:Ns,shr:Vs,square:Hs,sub:Gn,toArray:js,toLEBuff:oa,toNumber:go,toRprBE:Co,toRprLE:Ga,toString:oe,zero:So});function Ee(e,t,n){if(wo(n))return e.one;const a=Lo(n);if(a.length==0)return e.one;let i=t;for(let o=a.length-2;o>=0;o--)i=e.square(i),a[o]&&(i=e.mul(i,t));return i}function ec(e){if(e.m%2==1)if(In(vn(e.p,4),1))if(In(vn(e.p,8),1))if(In(vn(e.p,16),1))oc(e);else if(In(vn(e.p,16),9))sc(e);else throw new Error("Field withot sqrt");else if(In(vn(e.p,8),5))cc(e);else throw new Error("Field withot sqrt");else In(vn(e.p,4),3)&&lc(e);else{const t=vn(za(e.p,e.m/2),4);t==1?rc(e):t==3?dc(e):uc(e)}}function oc(e){for(e.sqrt_q=za(e.p,e.m),e.sqrt_s=0,e.sqrt_t=Gn(e.sqrt_q,1);!ae(e.sqrt_t);)e.sqrt_s=e.sqrt_s+1,e.sqrt_t=ea(e.sqrt_t,2);let t=e.one;for(;e.eq(t,e.one);){const n=e.random();e.sqrt_z=e.pow(n,e.sqrt_t),t=e.pow(e.sqrt_z,2**(e.sqrt_s-1))}e.sqrt_tm1d2=ea(Gn(e.sqrt_t,1),2),e.sqrt=function(n){const a=this;if(a.isZero(n))return a.zero;let i=a.pow(n,a.sqrt_tm1d2);const o=a.pow(a.mul(a.square(i),n),2**(a.sqrt_s-1));if(a.eq(o,a.negone))return null;let l=a.sqrt_s,s=a.mul(n,i),f=a.mul(s,i),r=a.sqrt_z;for(;!a.eq(f,a.one);){let c=a.square(f),u=1;for(;!a.eq(c,a.one);)c=a.square(c),u++;i=r;for(let b=0;b<l-u-1;b++)i=a.square(i);r=a.square(i),f=a.mul(f,r),s=a.mul(s,i),l=u}return a.geq(s,a.zero)?s:a.neg(s)}}function sc(e){e.sqrt=function(){throw new Error("Sqrt alg 4 not implemented")}}function cc(e){e.sqrt=function(){throw new Error("Sqrt alg 3 not implemented")}}function lc(e){e.sqrt_q=za(e.p,e.m),e.sqrt_e1=ea(Gn(e.sqrt_q,3),4),e.sqrt=function(t){if(this.isZero(t))return this.zero;const n=this.pow(t,this.sqrt_e1),a=this.mul(this.square(n),t);if(this.eq(a,this.negone))return null;const i=this.mul(n,t);return e.geq(i,e.zero)?i:e.neg(i)}}function rc(e){e.sqrt=function(){throw new Error("Sqrt alg 10 not implemented")}}function dc(e){e.sqrt_q=za(e.p,e.m/2),e.sqrt_e34=ea(Gn(e.sqrt_q,3),4),e.sqrt_e12=ea(Gn(e.sqrt_q,1),2),e.frobenius=function(t,n){return t%2==1?e.conjugate(n):n},e.sqrt=function(t){const n=this,a=n.pow(t,n.sqrt_e34),i=n.mul(n.square(a),t),o=n.mul(n.frobenius(1,i),i);if(n.eq(o,n.negone))return null;const l=n.mul(a,t);let s;if(n.eq(i,n.negone))s=n.mul(l,[n.F.zero,n.F.one]);else{const f=n.pow(n.add(n.one,i),n.sqrt_e12);s=n.mul(f,l)}return n.geq(s,n.zero)?s:n.neg(s)}}function uc(e){e.sqrt=function(){throw new Error("Sqrt alg 8 not implemented")}}function On(e,t,n,a,i){e[t]=e[t]+e[n]>>>0,e[i]=(e[i]^e[t])>>>0,e[i]=(e[i]<<16|e[i]>>>16&65535)>>>0,e[a]=e[a]+e[i]>>>0,e[n]=(e[n]^e[a])>>>0,e[n]=(e[n]<<12|e[n]>>>20&4095)>>>0,e[t]=e[t]+e[n]>>>0,e[i]=(e[i]^e[t])>>>0,e[i]=(e[i]<<8|e[i]>>>24&255)>>>0,e[a]=e[a]+e[i]>>>0,e[n]=(e[n]^e[a])>>>0,e[n]=(e[n]<<7|e[n]>>>25&127)>>>0}function fc(e){On(e,0,4,8,12),On(e,1,5,9,13),On(e,2,6,10,14),On(e,3,7,11,15),On(e,0,5,10,15),On(e,1,6,11,12),On(e,2,7,8,13),On(e,3,4,9,14)}class Kn{constructor(t){t=t||[0,0,0,0,0,0,0,0],this.state=[1634760805,857760878,2036477234,1797285236,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],0,0,0,0],this.idx=16,this.buff=new Array(16)}nextU32(){return this.idx==16&&this.update(),this.buff[this.idx++]}nextU64(){return ie(bo(this.nextU32(),4294967296),this.nextU32())}nextBool(){return(this.nextU32()&1)==1}update(){for(let t=0;t<16;t++)this.buff[t]=this.state[t];for(let t=0;t<10;t++)fc(this.buff);for(let t=0;t<16;t++)this.buff[t]=this.buff[t]+this.state[t]>>>0;this.idx=0,this.state[12]=this.state[12]+1>>>0,this.state[12]==0&&(this.state[13]=this.state[13]+1>>>0,this.state[13]==0&&(this.state[14]=this.state[14]+1>>>0,this.state[14]==0&&(this.state[15]=this.state[15]+1>>>0)))}}function vo(e){let t=new Uint8Array(e);if(typeof globalThis.crypto<"u")globalThis.crypto.getRandomValues(t);else for(let n=0;n<e;n++)t[n]=Math.random()*4294967296>>>0;return t}function _c(){const e=vo(32),t=new Uint32Array(e.buffer),n=[];for(let a=0;a<8;a++)n.push(t[a]);return n}let $a=null;function se(){return $a||($a=new Kn(_c()),$a)}class hc{constructor(t,n,a){this.F=n,this.G=t,this.opMulGF=a;let i=n.sqrt_t||n.t,o=n.sqrt_s||n.s,l=n.one;for(;n.eq(n.pow(l,n.half),n.one);)l=n.add(l,n.one);this.w=new Array(o+1),this.wi=new Array(o+1),this.w[o]=this.F.pow(l,i),this.wi[o]=this.F.inv(this.w[o]);let s=o-1;for(;s>=0;)this.w[s]=this.F.square(this.w[s+1]),this.wi[s]=this.F.square(this.wi[s+1]),s--;this.roots=[],this._setRoots(Math.min(o,15))}_setRoots(t){for(let n=t;n>=0&&!this.roots[n];n--){let a=this.F.one;const i=1<<n,o=new Array(i);for(let l=0;l<i;l++)o[l]=a,a=this.F.mul(a,this.w[n]);this.roots[n]=o}}fft(t){if(t.length<=1)return t;const n=Ae(t.length-1)+1;this._setRoots(n);const a=1<<n;if(t.length!=a)throw new Error("Size must be multiple of 2");return Qa(this,t,n,0,1)}ifft(t){if(t.length<=1)return t;const n=Ae(t.length-1)+1;this._setRoots(n);const a=1<<n;if(t.length!=a)throw new Error("Size must be multiple of 2");const i=Qa(this,t,n,0,1),o=this.F.inv(this.F.mulScalar(this.F.one,a)),l=new Array(a);for(let s=0;s<a;s++)l[s]=this.opMulGF(i[(a-s)%a],o);return l}}function Ae(e){return((e&4294901760)!==0?(e&=4294901760,16):0)|((e&4278255360)!==0?(e&=4278255360,8):0)|((e&4042322160)!==0?(e&=4042322160,4):0)|((e&3435973836)!==0?(e&=3435973836,2):0)|(e&2863311530)!==0}function Qa(e,t,n,a,i){const o=1<<n;if(o==1)return[t[a]];if(o==2)return[e.G.add(t[a],t[a+i]),e.G.sub(t[a],t[a+i])];const l=o>>1,s=Qa(e,t,n-1,a,i*2),f=Qa(e,t,n-1,a+i,i*2),r=new Array(o);for(let c=0;c<l;c++)r[c]=e.G.add(s[c],e.opMulGF(f[c],e.roots[n][c])),r[c+l]=e.G.sub(s[c],e.opMulGF(f[c],e.roots[n][c]));return r}class ce{constructor(t){this.type="F1",this.one=BigInt(1),this.zero=BigInt(0),this.p=BigInt(t),this.m=1,this.negone=this.p-this.one,this.two=BigInt(2),this.half=this.p>>this.one,this.bitLength=Oa(this.p),this.mask=(this.one<<BigInt(this.bitLength))-this.one,this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=this.n64*2,this.n8=this.n64*8,this.R=this.e(this.one<<BigInt(this.n64*64)),this.Ri=this.inv(this.R);const n=this.negone>>this.one;this.nqr=this.two;let a=this.pow(this.nqr,n);for(;!this.eq(a,this.negone);)this.nqr=this.nqr+this.one,a=this.pow(this.nqr,n);for(this.s=0,this.t=this.negone;(this.t&this.one)==this.zero;)this.s=this.s+1,this.t=this.t>>this.one;this.nqr_to_t=this.pow(this.nqr,this.t),ec(this),this.FFT=new hc(this,this,this.mul.bind(this)),this.fft=this.FFT.fft.bind(this.FFT),this.ifft=this.FFT.ifft.bind(this.FFT),this.w=this.FFT.w,this.wi=this.FFT.wi,this.shift=this.square(this.nqr),this.k=this.exp(this.nqr,2**this.s)}e(t,n){let a;if(n?n==16&&(a=BigInt("0x"+t)):a=BigInt(t),a<0){let i=-a;return i>=this.p&&(i=i%this.p),this.p-i}else return a>=this.p?a%this.p:a}add(t,n){const a=t+n;return a>=this.p?a-this.p:a}sub(t,n){return t>=n?t-n:this.p-n+t}neg(t){return t&&this.p-t}mul(t,n){return t*n%this.p}mulScalar(t,n){return t*this.e(n)%this.p}square(t){return t*t%this.p}eq(t,n){return t==n}neq(t,n){return t!=n}lt(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a<i}gt(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a>i}leq(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a<=i}geq(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a>=i}div(t,n){return this.mul(t,this.inv(n))}idiv(t,n){if(!n)throw new Error("Division by zero");return t/n}inv(t){if(!t)throw new Error("Division by zero");let n=this.zero,a=this.p,i=this.one,o=t%this.p;for(;o;){let l=a/o;[n,i]=[i,n-l*i],[a,o]=[o,a-l*o]}return n<this.zero&&(n+=this.p),n}mod(t,n){return t%n}pow(t,n){return Ee(this,t,n)}exp(t,n){return Ee(this,t,n)}band(t,n){const a=t&n&this.mask;return a>=this.p?a-this.p:a}bor(t,n){const a=(t|n)&this.mask;return a>=this.p?a-this.p:a}bxor(t,n){const a=(t^n)&this.mask;return a>=this.p?a-this.p:a}bnot(t){const n=t^this.mask;return n>=this.p?n-this.p:n}shl(t,n){if(Number(n)<this.bitLength){const a=t<<n&this.mask;return a>=this.p?a-this.p:a}else{const a=this.p-n;return Number(a)<this.bitLength?t>>a:this.zero}}shr(t,n){if(Number(n)<this.bitLength)return t>>n;{const a=this.p-n;if(Number(a)<this.bitLength){const i=t<<a&this.mask;return i>=this.p?i-this.p:i}else return 0}}land(t,n){return t&&n?this.one:this.zero}lor(t,n){return t||n?this.one:this.zero}lnot(t){return t?this.zero:this.one}sqrt_old(t){if(t==this.zero)return this.zero;if(this.pow(t,this.negone>>this.one)!=this.one)return null;let a=this.s,i=this.nqr_to_t,o=this.pow(t,this.t),l=this.pow(t,this.add(this.t,this.one)>>this.one);for(;o!=this.one;){let s=this.square(o),f=1;for(;s!=this.one;)f++,s=this.square(s);let r=i;for(let c=0;c<a-f-1;c++)r=this.square(r);a=f,i=this.square(r),o=this.mul(o,i),l=this.mul(l,r)}return l>this.p>>this.one&&(l=this.neg(l)),l}normalize(t,n){if(t=BigInt(t,n),t<0){let a=-t;return a>=this.p&&(a=a%this.p),this.p-a}else return t>=this.p?t%this.p:t}random(){const t=this.bitLength*2/8;let n=this.zero;for(let a=0;a<t;a++)n=(n<<BigInt(8))+BigInt(vo(1)[0]);return n%this.p}toString(t,n){n=n||10;let a;return t>this.half&&n==10?a="-"+(this.p-t).toString(n):a=t.toString(n),a}isZero(t){return t==this.zero}fromRng(t){let n;do{n=this.zero;for(let a=0;a<this.n64;a++)n+=t.nextU64()<<BigInt(64*a);n&=this.mask}while(n>=this.p);return n=n*this.Ri%this.p,n}fft(t){return this.FFT.fft(t)}ifft(t){return this.FFT.ifft(t)}toRprLE(t,n,a){Ga(t,n,a,this.n64*8)}toRprBE(t,n,a){Co(t,n,a,this.n64*8)}toRprBEM(t,n,a){return this.toRprBE(t,n,this.mul(this.R,a))}toRprLEM(t,n,a){return this.toRprLE(t,n,this.mul(this.R,a))}fromRprLE(t,n){return Ta(t,n,this.n8)}fromRprBE(t,n){return Fo(t,n,this.n8)}fromRprLEM(t,n){return this.mul(this.fromRprLE(t,n),this.Ri)}fromRprBEM(t,n){return this.mul(this.fromRprBE(t,n),this.Ri)}toObject(t){return t}}var $n={};$n.bigInt2BytesLE=function(t,n){const a=Array(n);let i=BigInt(t);for(let o=0;o<n;o++)a[o]=Number(i&0xFFn),i=i>>8n;return a};$n.bigInt2U32LE=function(t,n){const a=Array(n);let i=BigInt(t);for(let o=0;o<n;o++)a[o]=Number(i&0xFFFFFFFFn),i=i>>32n;return a};$n.isOcamNum=function(e){return!(!Array.isArray(e)||e.length!=3||typeof e[0]!="number"||typeof e[1]!="number"||!Array.isArray(e[2]))};var pc=function(t,n,a){const i=a||"int";if(t.modules[i])return i;t.modules[i]={};const o=n*2,l=n*8;function s(){const C=t.addFunction(i+"_copy");C.addParam("px","i32"),C.addParam("pr","i32");const _=C.getCodeBuilder();for(let g=0;g<n;g++)C.addCode(_.i64_store(_.getLocal("pr"),g*8,_.i64_load(_.getLocal("px"),g*8)))}function f(){const C=t.addFunction(i+"_zero");C.addParam("pr","i32");const _=C.getCodeBuilder();for(let g=0;g<n;g++)C.addCode(_.i64_store(_.getLocal("pr"),g*8,_.i64_const(0)))}function r(){const C=t.addFunction(i+"_one");C.addParam("pr","i32");const _=C.getCodeBuilder();C.addCode(_.i64_store(_.getLocal("pr"),0,_.i64_const(1)));for(let g=1;g<n;g++)C.addCode(_.i64_store(_.getLocal("pr"),g*8,_.i64_const(0)))}function c(){const C=t.addFunction(i+"_isZero");C.addParam("px","i32"),C.setReturnType("i32");const _=C.getCodeBuilder();function g($){return $==0?_.ret(_.i64_eqz(_.i64_load(_.getLocal("px")))):_.if(_.i64_eqz(_.i64_load(_.getLocal("px"),$*8)),g($-1),_.ret(_.i32_const(0)))}C.addCode(g(n-1)),C.addCode(_.ret(_.i32_const(0)))}function u(){const C=t.addFunction(i+"_eq");C.addParam("px","i32"),C.addParam("py","i32"),C.setReturnType("i32");const _=C.getCodeBuilder();function g($){return $==0?_.ret(_.i64_eq(_.i64_load(_.getLocal("px")),_.i64_load(_.getLocal("py")))):_.if(_.i64_eq(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),g($-1),_.ret(_.i32_const(0)))}C.addCode(g(n-1)),C.addCode(_.ret(_.i32_const(0)))}function b(){const C=t.addFunction(i+"_gte");C.addParam("px","i32"),C.addParam("py","i32"),C.setReturnType("i32");const _=C.getCodeBuilder();function g($){return $==0?_.ret(_.i64_ge_u(_.i64_load(_.getLocal("px")),_.i64_load(_.getLocal("py")))):_.if(_.i64_lt_u(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),_.ret(_.i32_const(0)),_.if(_.i64_gt_u(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),_.ret(_.i32_const(1)),g($-1)))}C.addCode(g(n-1)),C.addCode(_.ret(_.i32_const(0)))}function w(){const C=t.addFunction(i+"_add");C.addParam("x","i32"),C.addParam("y","i32"),C.addParam("r","i32"),C.setReturnType("i32"),C.addLocal("c","i64");const _=C.getCodeBuilder();C.addCode(_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("x")),_.i64_load32_u(_.getLocal("y"))))),C.addCode(_.i64_store32(_.getLocal("r"),_.getLocal("c")));for(let g=1;g<o;g++)C.addCode(_.setLocal("c",_.i64_add(_.i64_add(_.i64_load32_u(_.getLocal("x"),4*g),_.i64_load32_u(_.getLocal("y"),4*g)),_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))),C.addCode(_.i64_store32(_.getLocal("r"),g*4,_.getLocal("c")));C.addCode(_.i32_wrap_i64(_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))}function A(){const C=t.addFunction(i+"_sub");C.addParam("x","i32"),C.addParam("y","i32"),C.addParam("r","i32"),C.setReturnType("i32"),C.addLocal("c","i64");const _=C.getCodeBuilder();C.addCode(_.setLocal("c",_.i64_sub(_.i64_load32_u(_.getLocal("x")),_.i64_load32_u(_.getLocal("y"))))),C.addCode(_.i64_store32(_.getLocal("r"),_.i64_and(_.getLocal("c"),_.i64_const("0xFFFFFFFF"))));for(let g=1;g<o;g++)C.addCode(_.setLocal("c",_.i64_add(_.i64_sub(_.i64_load32_u(_.getLocal("x"),4*g),_.i64_load32_u(_.getLocal("y"),4*g)),_.i64_shr_s(_.getLocal("c"),_.i64_const(32))))),C.addCode(_.i64_store32(_.getLocal("r"),g*4,_.i64_and(_.getLocal("c"),_.i64_const("0xFFFFFFFF"))));C.addCode(_.i32_wrap_i64(_.i64_shr_s(_.getLocal("c"),_.i64_const(32))))}function x(){const C=t.addFunction(i+"_mul");C.addParam("x","i32"),C.addParam("y","i32"),C.addParam("r","i32"),C.addLocal("c0","i64"),C.addLocal("c1","i64");for(let E=0;E<o;E++)C.addLocal("x"+E,"i64"),C.addLocal("y"+E,"i64");const _=C.getCodeBuilder(),g=[],$=[];function Z(E,q){let M,Q;return g[E]?M=_.getLocal("x"+E):(M=_.teeLocal("x"+E,_.i64_load32_u(_.getLocal("x"),E*4)),g[E]=!0),$[q]?Q=_.getLocal("y"+q):(Q=_.teeLocal("y"+q,_.i64_load32_u(_.getLocal("y"),q*4)),$[q]=!0),_.i64_mul(M,Q)}let j="c0",O="c1";for(let E=0;E<o*2-1;E++){for(let q=Math.max(0,E-o+1);q<=E&&q<o;q++){const M=E-q;C.addCode(_.setLocal(j,_.i64_add(_.i64_and(_.getLocal(j),_.i64_const(4294967295)),Z(q,M)))),C.addCode(_.setLocal(O,_.i64_add(_.getLocal(O),_.i64_shr_u(_.getLocal(j),_.i64_const(32)))))}C.addCode(_.i64_store32(_.getLocal("r"),E*4,_.getLocal(j))),[j,O]=[O,j],C.addCode(_.setLocal(O,_.i64_shr_u(_.getLocal(j),_.i64_const(32))))}C.addCode(_.i64_store32(_.getLocal("r"),o*4*2-4,_.getLocal(j)))}function v(){const C=t.addFunction(i+"_square");C.addParam("x","i32"),C.addParam("r","i32"),C.addLocal("c0","i64"),C.addLocal("c1","i64"),C.addLocal("c0_old","i64"),C.addLocal("c1_old","i64");for(let q=0;q<o;q++)C.addLocal("x"+q,"i64");const _=C.getCodeBuilder(),g=[];function $(q,M){let Q,D;return g[q]?Q=_.getLocal("x"+q):(Q=_.teeLocal("x"+q,_.i64_load32_u(_.getLocal("x"),q*4)),g[q]=!0),g[M]?D=_.getLocal("x"+M):(D=_.teeLocal("x"+M,_.i64_load32_u(_.getLocal("x"),M*4)),g[M]=!0),_.i64_mul(Q,D)}let Z="c0",j="c1",O="c0_old",E="c1_old";for(let q=0;q<o*2-1;q++){C.addCode(_.setLocal(Z,_.i64_const(0)),_.setLocal(j,_.i64_const(0)));for(let M=Math.max(0,q-o+1);M<q+1>>1&&M<o;M++){const Q=q-M;C.addCode(_.setLocal(Z,_.i64_add(_.i64_and(_.getLocal(Z),_.i64_const(4294967295)),$(M,Q)))),C.addCode(_.setLocal(j,_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(Z),_.i64_const(32)))))}C.addCode(_.setLocal(Z,_.i64_shl(_.i64_and(_.getLocal(Z),_.i64_const(4294967295)),_.i64_const(1)))),C.addCode(_.setLocal(j,_.i64_add(_.i64_shl(_.getLocal(j),_.i64_const(1)),_.i64_shr_u(_.getLocal(Z),_.i64_const(32))))),q%2==0&&(C.addCode(_.setLocal(Z,_.i64_add(_.i64_and(_.getLocal(Z),_.i64_const(4294967295)),$(q>>1,q>>1)))),C.addCode(_.setLocal(j,_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(Z),_.i64_const(32)))))),q>0&&(C.addCode(_.setLocal(Z,_.i64_add(_.i64_and(_.getLocal(Z),_.i64_const(4294967295)),_.i64_and(_.getLocal(O),_.i64_const(4294967295))))),C.addCode(_.setLocal(j,_.i64_add(_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(Z),_.i64_const(32))),_.getLocal(E))))),C.addCode(_.i64_store32(_.getLocal("r"),q*4,_.getLocal(Z))),C.addCode(_.setLocal(O,_.getLocal(j)),_.setLocal(E,_.i64_shr_u(_.getLocal(O),_.i64_const(32))))}C.addCode(_.i64_store32(_.getLocal("r"),o*4*2-4,_.getLocal(O)))}function F(){const C=t.addFunction(i+"_squareOld");C.addParam("x","i32"),C.addParam("r","i32");const _=C.getCodeBuilder();C.addCode(_.call(i+"_mul",_.getLocal("x"),_.getLocal("x"),_.getLocal("r")))}function y(){const C=t.addFunction(i+"__mul1");C.addParam("px","i32"),C.addParam("y","i64"),C.addParam("pr","i32"),C.addLocal("c","i64");const _=C.getCodeBuilder();C.addCode(_.setLocal("c",_.i64_mul(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("y")))),C.addCode(_.i64_store32(_.getLocal("pr"),0,0,_.getLocal("c")));for(let g=1;g<o;g++)C.addCode(_.setLocal("c",_.i64_add(_.i64_mul(_.i64_load32_u(_.getLocal("px"),4*g,0),_.getLocal("y")),_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))),C.addCode(_.i64_store32(_.getLocal("pr"),g*4,0,_.getLocal("c")))}function B(){const C=t.addFunction(i+"__add1");C.addParam("x","i32"),C.addParam("y","i64"),C.addLocal("c","i64"),C.addLocal("px","i32");const _=C.getCodeBuilder();C.addCode(_.setLocal("px",_.getLocal("x"))),C.addCode(_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("y")))),C.addCode(_.i64_store32(_.getLocal("px"),0,0,_.getLocal("c"))),C.addCode(_.setLocal("c",_.i64_shr_u(_.getLocal("c"),_.i64_const(32)))),C.addCode(_.block(_.loop(_.br_if(1,_.i64_eqz(_.getLocal("c"))),_.setLocal("px",_.i32_add(_.getLocal("px"),_.i32_const(4))),_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("c"))),_.i64_store32(_.getLocal("px"),0,0,_.getLocal("c")),_.setLocal("c",_.i64_shr_u(_.getLocal("c"),_.i64_const(32))),_.br(0))))}function P(){y(),B();const C=t.addFunction(i+"_div");C.addParam("x","i32"),C.addParam("y","i32"),C.addParam("c","i32"),C.addParam("r","i32"),C.addLocal("rr","i32"),C.addLocal("cc","i32"),C.addLocal("eX","i32"),C.addLocal("eY","i32"),C.addLocal("sy","i64"),C.addLocal("sx","i64"),C.addLocal("ec","i32");const _=C.getCodeBuilder(),g=_.i32_const(t.alloc(l)),$=_.i32_const(t.alloc(l)),Z=_.i32_const(t.alloc(l)),j=_.getLocal("cc"),O=_.getLocal("rr"),E=t.alloc(l*2),q=_.i32_const(E),M=_.i32_const(E+l);C.addCode(_.if(_.getLocal("c"),_.setLocal("cc",_.getLocal("c")),_.setLocal("cc",$))),C.addCode(_.if(_.getLocal("r"),_.setLocal("rr",_.getLocal("r")),_.setLocal("rr",Z))),C.addCode(_.call(i+"_copy",_.getLocal("x"),O)),C.addCode(_.call(i+"_copy",_.getLocal("y"),g)),C.addCode(_.call(i+"_zero",j)),C.addCode(_.call(i+"_zero",q)),C.addCode(_.setLocal("eX",_.i32_const(l-1))),C.addCode(_.setLocal("eY",_.i32_const(l-1))),C.addCode(_.block(_.loop(_.br_if(1,_.i32_or(_.i32_load8_u(_.i32_add(g,_.getLocal("eY")),0,0),_.i32_eq(_.getLocal("eY"),_.i32_const(3)))),_.setLocal("eY",_.i32_sub(_.getLocal("eY"),_.i32_const(1))),_.br(0)))),C.addCode(_.setLocal("sy",_.i64_add(_.i64_load32_u(_.i32_sub(_.i32_add(g,_.getLocal("eY")),_.i32_const(3)),0,0),_.i64_const(1)))),C.addCode(_.if(_.i64_eq(_.getLocal("sy"),_.i64_const(1)),_.drop(_.i64_div_u(_.i64_const(0),_.i64_const(0))))),C.addCode(_.block(_.loop(_.block(_.loop(_.br_if(1,_.i32_or(_.i32_load8_u(_.i32_add(O,_.getLocal("eX")),0,0),_.i32_eq(_.getLocal("eX"),_.i32_const(7)))),_.setLocal("eX",_.i32_sub(_.getLocal("eX"),_.i32_const(1))),_.br(0))),_.setLocal("sx",_.i64_load(_.i32_sub(_.i32_add(O,_.getLocal("eX")),_.i32_const(7)),0,0)),_.setLocal("sx",_.i64_div_u(_.getLocal("sx"),_.getLocal("sy"))),_.setLocal("ec",_.i32_sub(_.i32_sub(_.getLocal("eX"),_.getLocal("eY")),_.i32_const(4))),_.block(_.loop(_.br_if(1,_.i32_and(_.i64_eqz(_.i64_and(_.getLocal("sx"),_.i64_const("0xFFFFFFFF00000000"))),_.i32_ge_s(_.getLocal("ec"),_.i32_const(0)))),_.setLocal("sx",_.i64_shr_u(_.getLocal("sx"),_.i64_const(8))),_.setLocal("ec",_.i32_add(_.getLocal("ec"),_.i32_const(1))),_.br(0))),_.if(_.i64_eqz(_.getLocal("sx")),[..._.br_if(2,_.i32_eqz(_.call(i+"_gte",O,g))),..._.setLocal("sx",_.i64_const(1)),..._.setLocal("ec",_.i32_const(0))]),_.call(i+"__mul1",g,_.getLocal("sx"),M),_.drop(_.call(i+"_sub",O,_.i32_sub(M,_.getLocal("ec")),O)),_.call(i+"__add1",_.i32_add(j,_.getLocal("ec")),_.getLocal("sx")),_.br(0))))}function T(){const C=t.addFunction(i+"_inverseMod");C.addParam("px","i32"),C.addParam("pm","i32"),C.addParam("pr","i32"),C.addLocal("t","i32"),C.addLocal("newt","i32"),C.addLocal("r","i32"),C.addLocal("qq","i32"),C.addLocal("qr","i32"),C.addLocal("newr","i32"),C.addLocal("swp","i32"),C.addLocal("x","i32"),C.addLocal("signt","i32"),C.addLocal("signnewt","i32"),C.addLocal("signx","i32");const _=C.getCodeBuilder(),g=_.i32_const(t.alloc(l)),$=_.i32_const(t.alloc(l)),Z=_.i32_const(t.alloc(l)),j=_.i32_const(t.alloc(l)),O=_.i32_const(t.alloc(l)),E=_.i32_const(t.alloc(l)),q=_.i32_const(t.alloc(l*2)),M=_.i32_const(t.alloc(l));C.addCode(_.setLocal("t",g),_.call(i+"_zero",g),_.setLocal("signt",_.i32_const(0))),C.addCode(_.setLocal("r",$),_.call(i+"_copy",_.getLocal("pm"),$)),C.addCode(_.setLocal("newt",Z),_.call(i+"_one",Z),_.setLocal("signnewt",_.i32_const(0))),C.addCode(_.setLocal("newr",j),_.call(i+"_copy",_.getLocal("px"),j)),C.addCode(_.setLocal("qq",O)),C.addCode(_.setLocal("qr",E)),C.addCode(_.setLocal("x",M)),C.addCode(_.block(_.loop(_.br_if(1,_.call(i+"_isZero",_.getLocal("newr"))),_.call(i+"_div",_.getLocal("r"),_.getLocal("newr"),_.getLocal("qq"),_.getLocal("qr")),_.call(i+"_mul",_.getLocal("qq"),_.getLocal("newt"),q),_.if(_.getLocal("signt"),_.if(_.getLocal("signnewt"),_.if(_.call(i+"_gte",q,_.getLocal("t")),[..._.drop(_.call(i+"_sub",q,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],[..._.drop(_.call(i+"_sub",_.getLocal("t"),q,_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]),[..._.drop(_.call(i+"_add",q,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]),_.if(_.getLocal("signnewt"),[..._.drop(_.call(i+"_add",q,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],_.if(_.call(i+"_gte",_.getLocal("t"),q),[..._.drop(_.call(i+"_sub",_.getLocal("t"),q,_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],[..._.drop(_.call(i+"_sub",q,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]))),_.setLocal("swp",_.getLocal("t")),_.setLocal("t",_.getLocal("newt")),_.setLocal("newt",_.getLocal("x")),_.setLocal("x",_.getLocal("swp")),_.setLocal("signt",_.getLocal("signnewt")),_.setLocal("signnewt",_.getLocal("signx")),_.setLocal("swp",_.getLocal("r")),_.setLocal("r",_.getLocal("newr")),_.setLocal("newr",_.getLocal("qr")),_.setLocal("qr",_.getLocal("swp")),_.br(0)))),C.addCode(_.if(_.getLocal("signt"),_.drop(_.call(i+"_sub",_.getLocal("pm"),_.getLocal("t"),_.getLocal("pr"))),_.call(i+"_copy",_.getLocal("t"),_.getLocal("pr"))))}return s(),f(),c(),r(),u(),b(),w(),A(),x(),v(),F(),P(),T(),t.exportFunction(i+"_copy"),t.exportFunction(i+"_zero"),t.exportFunction(i+"_one"),t.exportFunction(i+"_isZero"),t.exportFunction(i+"_eq"),t.exportFunction(i+"_gte"),t.exportFunction(i+"_add"),t.exportFunction(i+"_sub"),t.exportFunction(i+"_mul"),t.exportFunction(i+"_square"),t.exportFunction(i+"_squareOld"),t.exportFunction(i+"_div"),t.exportFunction(i+"_inverseMod"),i},le=function(t,n,a,i,o,l,s){const f=t.addFunction(n);f.addParam("base","i32"),f.addParam("scalar","i32"),f.addParam("scalarLength","i32"),f.addParam("r","i32"),f.addLocal("i","i32"),f.addLocal("b","i32");const r=f.getCodeBuilder(),c=r.i32_const(t.alloc(a));f.addCode(r.if(r.i32_eqz(r.getLocal("scalarLength")),[...r.call(s,r.getLocal("r")),...r.ret([])])),f.addCode(r.call(l,r.getLocal("base"),c)),f.addCode(r.call(s,r.getLocal("r"))),f.addCode(r.setLocal("i",r.getLocal("scalarLength"))),f.addCode(r.block(r.loop(r.setLocal("i",r.i32_sub(r.getLocal("i"),r.i32_const(1))),r.setLocal("b",r.i32_load8_u(r.i32_add(r.getLocal("scalar"),r.getLocal("i")))),...u(),r.br_if(1,r.i32_eqz(r.getLocal("i"))),r.br(0))));function u(){const b=[];for(let w=0;w<8;w++)b.push(...r.call(o,r.getLocal("r"),r.getLocal("r")),...r.if(r.i32_ge_u(r.getLocal("b"),r.i32_const(128>>w)),[...r.setLocal("b",r.i32_sub(r.getLocal("b"),r.i32_const(128>>w))),...r.call(i,r.getLocal("r"),c,r.getLocal("r"))]));return b}},re=wc;function wc(e,t){const n=e.modules[t].n64*8,a=e.addFunction(t+"_batchInverse");a.addParam("pIn","i32"),a.addParam("inStep","i32"),a.addParam("n","i32"),a.addParam("pOut","i32"),a.addParam("outStep","i32"),a.addLocal("itAux","i32"),a.addLocal("itIn","i32"),a.addLocal("itOut","i32"),a.addLocal("i","i32");const i=a.getCodeBuilder(),o=i.i32_const(e.alloc(n));a.addCode(i.setLocal("itAux",i.i32_load(i.i32_const(0))),i.i32_store(i.i32_const(0),i.i32_add(i.getLocal("itAux"),i.i32_mul(i.i32_add(i.getLocal("n"),i.i32_const(1)),i.i32_const(n))))),a.addCode(i.call(t+"_one",i.getLocal("itAux")),i.setLocal("itIn",i.getLocal("pIn")),i.setLocal("itAux",i.i32_add(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_const(0)),i.block(i.loop(i.br_if(1,i.i32_eq(i.getLocal("i"),i.getLocal("n"))),i.if(i.call(t+"_isZero",i.getLocal("itIn")),i.call(t+"_copy",i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),i.getLocal("itAux")),i.call(t+"_mul",i.getLocal("itIn"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),i.getLocal("itAux"))),i.setLocal("itIn",i.i32_add(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itAux",i.i32_add(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_add(i.getLocal("i"),i.i32_const(1))),i.br(0))),i.setLocal("itIn",i.i32_sub(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itAux",i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("itOut",i.i32_add(i.getLocal("pOut"),i.i32_mul(i.i32_sub(i.getLocal("n"),i.i32_const(1)),i.getLocal("outStep")))),i.call(t+"_inverse",i.getLocal("itAux"),i.getLocal("itAux")),i.block(i.loop(i.br_if(1,i.i32_eqz(i.getLocal("i"))),i.if(i.call(t+"_isZero",i.getLocal("itIn")),[...i.call(t+"_copy",i.getLocal("itAux"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),...i.call(t+"_zero",i.getLocal("itOut"))],[...i.call(t+"_copy",i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),o),...i.call(t+"_mul",i.getLocal("itAux"),i.getLocal("itIn"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),...i.call(t+"_mul",i.getLocal("itAux"),o,i.getLocal("itOut"))]),i.setLocal("itIn",i.i32_sub(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itOut",i.i32_sub(i.getLocal("itOut"),i.getLocal("outStep"))),i.setLocal("itAux",i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_sub(i.getLocal("i"),i.i32_const(1))),i.br(0)))),a.addCode(i.i32_store(i.i32_const(0),i.getLocal("itAux")))}var Eo=Lc;function Lc(e,t,n,a,i,o){typeof o>"u"&&(a<i?o=!0:o=!1);const l=e.addFunction(t);l.addParam("pIn","i32"),l.addParam("n","i32"),l.addParam("pOut","i32"),l.addLocal("i","i32"),l.addLocal("itIn","i32"),l.addLocal("itOut","i32");const s=l.getCodeBuilder();o?l.addCode(s.setLocal("itIn",s.i32_add(s.getLocal("pIn"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itOut",s.i32_add(s.getLocal("pOut"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(i)))),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn"),s.getLocal("itOut")),s.setLocal("itIn",s.i32_sub(s.getLocal("itIn"),s.i32_const(a))),s.setLocal("itOut",s.i32_sub(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0)))):l.addCode(s.setLocal("itIn",s.getLocal("pIn")),s.setLocal("itOut",s.getLocal("pOut")),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn"),s.getLocal("itOut")),s.setLocal("itIn",s.i32_add(s.getLocal("itIn"),s.i32_const(a))),s.setLocal("itOut",s.i32_add(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0))))}var gc=mc;function mc(e,t,n,a,i,o){typeof o>"u"&&(a<i?o=!0:o=!1);const l=e.addFunction(t);l.addParam("pIn1","i32"),l.addParam("pIn2","i32"),l.addParam("n","i32"),l.addParam("pOut","i32"),l.addLocal("i","i32"),l.addLocal("itIn1","i32"),l.addLocal("itIn2","i32"),l.addLocal("itOut","i32");const s=l.getCodeBuilder();o?l.addCode(s.setLocal("itIn1",s.i32_add(s.getLocal("pIn1"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itIn2",s.i32_add(s.getLocal("pIn2"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itOut",s.i32_add(s.getLocal("pOut"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(i)))),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn1"),s.getLocal("itIn2"),s.getLocal("itOut")),s.setLocal("itIn1",s.i32_sub(s.getLocal("itIn1"),s.i32_const(a))),s.setLocal("itIn2",s.i32_sub(s.getLocal("itIn2"),s.i32_const(a))),s.setLocal("itOut",s.i32_sub(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0)))):l.addCode(s.setLocal("itIn1",s.getLocal("pIn1")),s.setLocal("itIn2",s.getLocal("pIn2")),s.setLocal("itOut",s.getLocal("pOut")),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn1"),s.getLocal("itIn2"),s.getLocal("itOut")),s.setLocal("itIn1",s.i32_add(s.getLocal("itIn1"),s.i32_const(a))),s.setLocal("itIn2",s.i32_add(s.getLocal("itIn2"),s.i32_const(a))),s.setLocal("itOut",s.i32_add(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0))))}var fn={};function Ao(e,t){return e===t?0:e>t?1:-1}function de(e){return e*e}function xo(e){return e%2n!==0n}function ue(e){return e%2n===0n}function ii(e){return e<0n}function bc(e){return e>0n}function Bo(e){return ii(e)?e.toString(2).length-1:e.toString(2).length}function qa(e){return e<0n?-e:e}function sa(e){return qa(e)===1n}function Io(e,t){for(var n=0n,a=1n,i=t,o=qa(e),l,s,f;o!==0n;)l=i/o,s=n,f=i,n=a,i=o,a=s-l*a,o=f-l*o;if(!sa(i))throw new Error(e.toString()+" and "+t.toString()+" are not co-prime");return Ao(n,0n)===-1&&(n=n+t),ii(e)?-n:n}function Po(e,t,n){if(n===0n)throw new Error("Cannot take modPow with modulus 0");var a=1n,i=e%n;for(ii(t)&&(t=t*-1n,i=Io(i,n));bc(t);){if(i===0n)return 0n;xo(t)&&(a=a*i%n),t=t/2n,i=de(i)%n}return a}function yc(e,t){return e=e>=0n?e:-e,t=t>=0n?t:-t,e===t?0:e>t?1:-1}function xe(e,t){return t===0n?!1:sa(t)?!0:yc(t,2n)===0?ue(e):e%t===0n}function Cc(e){var t=qa(e);if(sa(t))return!1;if(t===2n||t===3n||t===5n)return!0;if(ue(t)||xe(t,3n)||xe(t,5n))return!1;if(t<49n)return!0}function Fc(e){return e-1n}function Be(e,t){for(var n=Fc(e),a=n,i=0,o,l,s;ue(a);)a=a/2n,i++;t:for(l=0;l<t.length;l++)if(!(e<t[l])&&(s=Po(BigInt(t[l]),a,e),!(sa(s)||s===n))){for(o=i-1;o!=0;o--){if(s=de(s)%e,sa(s))return!1;if(s===n)continue t}return!1}return!0}function Sc(e){var t=Cc(e);if(t!==void 0)return t;var n=qa(e),a=Bo(n);if(a<=64)return Be(n,[2,3,5,7,11,13,17,19,23,29,31,37]);for(var i=Math.log(2)*Number(a),o=Math.ceil(i),l=[],s=0;s<o;s++)l.push(BigInt(s+2));return Be(n,l)}fn.bitLength=Bo;fn.isOdd=xo;fn.isNegative=ii;fn.abs=qa;fn.isUnit=sa;fn.compare=Ao;fn.modInv=Io;fn.modPow=Po;fn.isPrime=Sc;fn.square=de;const vc=pc,An=$n,Ec=le,Ac=re,_i=Eo,hi=gc,{bitLength:xc,modInv:pi,modPow:Ie,isPrime:Pe,isOdd:Bc,square:Ic}=fn;var fe=function(t,n,a,i){const o=BigInt(n),l=Math.floor((xc(o-1n)-1)/64)+1,s=l*2,f=l*8,r=a||"f1m";if(t.modules[r])return r;const c=vc(t,l,i),u=t.alloc(f,An.bigInt2BytesLE(o,f)),b=t.alloc(An.bigInt2BytesLE(Ic(1n<<BigInt(l*64))%o,f)),w=t.alloc(An.bigInt2BytesLE((1n<<BigInt(l*64))%o,f)),A=t.alloc(An.bigInt2BytesLE(0n,f)),x=o-1n,v=x>>1n,F=t.alloc(f,An.bigInt2BytesLE(v,f)),y=v+1n,B=t.alloc(f,An.bigInt2BytesLE(y,f));t.modules[r]={pq:u,pR2:b,n64:l,q:o,pOne:w,pZero:A,pePlusOne:B};function P(){const G=t.addFunction(r+"_one");G.addParam("pr","i32");const m=G.getCodeBuilder();G.addCode(m.call(c+"_copy",m.i32_const(w),m.getLocal("pr")))}function T(){const G=t.addFunction(r+"_add");G.addParam("x","i32"),G.addParam("y","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.if(m.call(c+"_add",m.getLocal("x"),m.getLocal("y"),m.getLocal("r")),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))),m.if(m.call(c+"_gte",m.getLocal("r"),m.i32_const(u)),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))))))}function C(){const G=t.addFunction(r+"_sub");G.addParam("x","i32"),G.addParam("y","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.if(m.call(c+"_sub",m.getLocal("x"),m.getLocal("y"),m.getLocal("r")),m.drop(m.call(c+"_add",m.getLocal("r"),m.i32_const(u),m.getLocal("r")))))}function _(){const G=t.addFunction(r+"_neg");G.addParam("x","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.call(r+"_sub",m.i32_const(A),m.getLocal("x"),m.getLocal("r")))}function g(){const G=t.addFunction(r+"_isNegative");G.addParam("x","i32"),G.setReturnType("i32");const m=G.getCodeBuilder(),z=m.i32_const(t.alloc(f));G.addCode(m.call(r+"_fromMontgomery",m.getLocal("x"),z),m.call(c+"_gte",z,m.i32_const(B)))}function $(){const G=t.addFunction(r+"_sign");G.addParam("x","i32"),G.setReturnType("i32");const m=G.getCodeBuilder(),z=m.i32_const(t.alloc(f));G.addCode(m.if(m.call(c+"_isZero",m.getLocal("x")),m.ret(m.i32_const(0))),m.call(r+"_fromMontgomery",m.getLocal("x"),z),m.if(m.call(c+"_gte",z,m.i32_const(B)),m.ret(m.i32_const(-1))),m.ret(m.i32_const(1)))}function Z(){const G=t.alloc(s*s*8),m=t.addFunction(r+"_mReduct");m.addParam("t","i32"),m.addParam("r","i32"),m.addLocal("np32","i64"),m.addLocal("c","i64"),m.addLocal("m","i64");const z=m.getCodeBuilder(),W=Number(0x100000000n-pi(o,0x100000000n));m.addCode(z.setLocal("np32",z.i64_const(W)));for(let it=0;it<s;it++){m.addCode(z.setLocal("c",z.i64_const(0))),m.addCode(z.setLocal("m",z.i64_and(z.i64_mul(z.i64_load32_u(z.getLocal("t"),it*4),z.getLocal("np32")),z.i64_const("0xFFFFFFFF"))));for(let X=0;X<s;X++)m.addCode(z.setLocal("c",z.i64_add(z.i64_add(z.i64_load32_u(z.getLocal("t"),(it+X)*4),z.i64_shr_u(z.getLocal("c"),z.i64_const(32))),z.i64_mul(z.i64_load32_u(z.i32_const(u),X*4),z.getLocal("m"))))),m.addCode(z.i64_store32(z.getLocal("t"),(it+X)*4,z.getLocal("c")));m.addCode(z.i64_store32(z.i32_const(G),it*4,z.i64_shr_u(z.getLocal("c"),z.i64_const(32))))}m.addCode(z.call(r+"_add",z.i32_const(G),z.i32_add(z.getLocal("t"),z.i32_const(s*4)),z.getLocal("r")))}function j(){const G=t.addFunction(r+"_mul");G.addParam("x","i32"),G.addParam("y","i32"),G.addParam("r","i32"),G.addLocal("c0","i64"),G.addLocal("c1","i64"),G.addLocal("np32","i64");for(let st=0;st<s;st++)G.addLocal("x"+st,"i64"),G.addLocal("y"+st,"i64"),G.addLocal("m"+st,"i64"),G.addLocal("q"+st,"i64");const m=G.getCodeBuilder(),z=Number(0x100000000n-pi(o,0x100000000n));G.addCode(m.setLocal("np32",m.i64_const(z)));const W=[],it=[],X=[];function lt(st,ct){let gt,yt;return W[st]?gt=m.getLocal("x"+st):(gt=m.teeLocal("x"+st,m.i64_load32_u(m.getLocal("x"),st*4)),W[st]=!0),it[ct]?yt=m.getLocal("y"+ct):(yt=m.teeLocal("y"+ct,m.i64_load32_u(m.getLocal("y"),ct*4)),it[ct]=!0),m.i64_mul(gt,yt)}function _t(st,ct){let gt,yt;return X[st]?gt=m.getLocal("q"+st):(gt=m.teeLocal("q"+st,m.i64_load32_u(m.i32_const(0),u+st*4)),X[st]=!0),yt=m.getLocal("m"+ct),m.i64_mul(gt,yt)}let wt="c0",ft="c1";for(let st=0;st<s*2-1;st++){for(let ct=Math.max(0,st-s+1);ct<=st&&ct<s;ct++){const gt=st-ct;G.addCode(m.setLocal(wt,m.i64_add(m.i64_and(m.getLocal(wt),m.i64_const(4294967295)),lt(ct,gt)))),G.addCode(m.setLocal(ft,m.i64_add(m.getLocal(ft),m.i64_shr_u(m.getLocal(wt),m.i64_const(32)))))}for(let ct=Math.max(1,st-s+1);ct<=st&&ct<s;ct++){const gt=st-ct;G.addCode(m.setLocal(wt,m.i64_add(m.i64_and(m.getLocal(wt),m.i64_const(4294967295)),_t(ct,gt)))),G.addCode(m.setLocal(ft,m.i64_add(m.getLocal(ft),m.i64_shr_u(m.getLocal(wt),m.i64_const(32)))))}st<s&&(G.addCode(m.setLocal("m"+st,m.i64_and(m.i64_mul(m.i64_and(m.getLocal(wt),m.i64_const(4294967295)),m.getLocal("np32")),m.i64_const("0xFFFFFFFF")))),G.addCode(m.setLocal(wt,m.i64_add(m.i64_and(m.getLocal(wt),m.i64_const(4294967295)),_t(0,st)))),G.addCode(m.setLocal(ft,m.i64_add(m.getLocal(ft),m.i64_shr_u(m.getLocal(wt),m.i64_const(32)))))),st>=s&&G.addCode(m.i64_store32(m.getLocal("r"),(st-s)*4,m.getLocal(wt))),[wt,ft]=[ft,wt],G.addCode(m.setLocal(ft,m.i64_shr_u(m.getLocal(wt),m.i64_const(32))))}G.addCode(m.i64_store32(m.getLocal("r"),s*4-4,m.getLocal(wt))),G.addCode(m.if(m.i32_wrap_i64(m.getLocal(ft)),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))),m.if(m.call(c+"_gte",m.getLocal("r"),m.i32_const(u)),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))))))}function O(){const G=t.addFunction(r+"_square");G.addParam("x","i32"),G.addParam("r","i32"),G.addLocal("c0","i64"),G.addLocal("c1","i64"),G.addLocal("c0_old","i64"),G.addLocal("c1_old","i64"),G.addLocal("np32","i64");for(let ct=0;ct<s;ct++)G.addLocal("x"+ct,"i64"),G.addLocal("m"+ct,"i64"),G.addLocal("q"+ct,"i64");const m=G.getCodeBuilder(),z=Number(0x100000000n-pi(o,0x100000000n));G.addCode(m.setLocal("np32",m.i64_const(z)));const W=[],it=[];function X(ct,gt){let yt,xt;return W[ct]?yt=m.getLocal("x"+ct):(yt=m.teeLocal("x"+ct,m.i64_load32_u(m.getLocal("x"),ct*4)),W[ct]=!0),W[gt]?xt=m.getLocal("x"+gt):(xt=m.teeLocal("x"+gt,m.i64_load32_u(m.getLocal("x"),gt*4)),W[gt]=!0),m.i64_mul(yt,xt)}function lt(ct,gt){let yt,xt;return it[ct]?yt=m.getLocal("q"+ct):(yt=m.teeLocal("q"+ct,m.i64_load32_u(m.i32_const(0),u+ct*4)),it[ct]=!0),xt=m.getLocal("m"+gt),m.i64_mul(yt,xt)}let _t="c0",wt="c1",ft="c0_old",st="c1_old";for(let ct=0;ct<s*2-1;ct++){G.addCode(m.setLocal(_t,m.i64_const(0)),m.setLocal(wt,m.i64_const(0)));for(let gt=Math.max(0,ct-s+1);gt<ct+1>>1&&gt<s;gt++){const yt=ct-gt;G.addCode(m.setLocal(_t,m.i64_add(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),X(gt,yt)))),G.addCode(m.setLocal(wt,m.i64_add(m.getLocal(wt),m.i64_shr_u(m.getLocal(_t),m.i64_const(32)))))}G.addCode(m.setLocal(_t,m.i64_shl(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),m.i64_const(1)))),G.addCode(m.setLocal(wt,m.i64_add(m.i64_shl(m.getLocal(wt),m.i64_const(1)),m.i64_shr_u(m.getLocal(_t),m.i64_const(32))))),ct%2==0&&(G.addCode(m.setLocal(_t,m.i64_add(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),X(ct>>1,ct>>1)))),G.addCode(m.setLocal(wt,m.i64_add(m.getLocal(wt),m.i64_shr_u(m.getLocal(_t),m.i64_const(32)))))),ct>0&&(G.addCode(m.setLocal(_t,m.i64_add(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),m.i64_and(m.getLocal(ft),m.i64_const(4294967295))))),G.addCode(m.setLocal(wt,m.i64_add(m.i64_add(m.getLocal(wt),m.i64_shr_u(m.getLocal(_t),m.i64_const(32))),m.getLocal(st)))));for(let gt=Math.max(1,ct-s+1);gt<=ct&&gt<s;gt++){const yt=ct-gt;G.addCode(m.setLocal(_t,m.i64_add(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),lt(gt,yt)))),G.addCode(m.setLocal(wt,m.i64_add(m.getLocal(wt),m.i64_shr_u(m.getLocal(_t),m.i64_const(32)))))}ct<s&&(G.addCode(m.setLocal("m"+ct,m.i64_and(m.i64_mul(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),m.getLocal("np32")),m.i64_const("0xFFFFFFFF")))),G.addCode(m.setLocal(_t,m.i64_add(m.i64_and(m.getLocal(_t),m.i64_const(4294967295)),lt(0,ct)))),G.addCode(m.setLocal(wt,m.i64_add(m.getLocal(wt),m.i64_shr_u(m.getLocal(_t),m.i64_const(32)))))),ct>=s&&G.addCode(m.i64_store32(m.getLocal("r"),(ct-s)*4,m.getLocal(_t))),G.addCode(m.setLocal(ft,m.getLocal(wt)),m.setLocal(st,m.i64_shr_u(m.getLocal(ft),m.i64_const(32))))}G.addCode(m.i64_store32(m.getLocal("r"),s*4-4,m.getLocal(ft))),G.addCode(m.if(m.i32_wrap_i64(m.getLocal(st)),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))),m.if(m.call(c+"_gte",m.getLocal("r"),m.i32_const(u)),m.drop(m.call(c+"_sub",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))))))}function E(){const G=t.addFunction(r+"_squareOld");G.addParam("x","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.call(r+"_mul",m.getLocal("x"),m.getLocal("x"),m.getLocal("r")))}function q(){const G=t.addFunction(r+"_toMontgomery");G.addParam("x","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.call(r+"_mul",m.getLocal("x"),m.i32_const(b),m.getLocal("r")))}function M(){const G=t.alloc(f*2),m=t.addFunction(r+"_fromMontgomery");m.addParam("x","i32"),m.addParam("r","i32");const z=m.getCodeBuilder();m.addCode(z.call(c+"_copy",z.getLocal("x"),z.i32_const(G))),m.addCode(z.call(c+"_zero",z.i32_const(G+f))),m.addCode(z.call(r+"_mReduct",z.i32_const(G),z.getLocal("r")))}function Q(){const G=t.addFunction(r+"_inverse");G.addParam("x","i32"),G.addParam("r","i32");const m=G.getCodeBuilder();G.addCode(m.call(r+"_fromMontgomery",m.getLocal("x"),m.getLocal("r"))),G.addCode(m.call(c+"_inverseMod",m.getLocal("r"),m.i32_const(u),m.getLocal("r"))),G.addCode(m.call(r+"_toMontgomery",m.getLocal("r"),m.getLocal("r")))}let D=2n;if(Pe(o))for(;Ie(D,v,o)!==x;)D=D+1n;let V=0,nt=x;for(;!Bc(nt)&&nt!==0n;)V++,nt=nt>>1n;const R=t.alloc(f,An.bigInt2BytesLE(nt,f)),at=Ie(D,nt,o),J=t.alloc(An.bigInt2BytesLE((at<<BigInt(l*64))%o,f)),k=nt+1n>>1n,K=t.alloc(f,An.bigInt2BytesLE(k,f));function I(){const G=t.addFunction(r+"_sqrt");G.addParam("n","i32"),G.addParam("r","i32"),G.addLocal("m","i32"),G.addLocal("i","i32"),G.addLocal("j","i32");const m=G.getCodeBuilder(),z=m.i32_const(w),W=m.i32_const(t.alloc(f)),it=m.i32_const(t.alloc(f)),X=m.i32_const(t.alloc(f)),lt=m.i32_const(t.alloc(f)),_t=m.i32_const(t.alloc(f));G.addCode(m.if(m.call(r+"_isZero",m.getLocal("n")),m.ret(m.call(r+"_zero",m.getLocal("r")))),m.setLocal("m",m.i32_const(V)),m.call(r+"_copy",m.i32_const(J),W),m.call(r+"_exp",m.getLocal("n"),m.i32_const(R),m.i32_const(f),it),m.call(r+"_exp",m.getLocal("n"),m.i32_const(K),m.i32_const(f),X),m.block(m.loop(m.br_if(1,m.call(r+"_eq",it,z)),m.call(r+"_square",it,lt),m.setLocal("i",m.i32_const(1)),m.block(m.loop(m.br_if(1,m.call(r+"_eq",lt,z)),m.call(r+"_square",lt,lt),m.setLocal("i",m.i32_add(m.getLocal("i"),m.i32_const(1))),m.br(0))),m.call(r+"_copy",W,_t),m.setLocal("j",m.i32_sub(m.i32_sub(m.getLocal("m"),m.getLocal("i")),m.i32_const(1))),m.block(m.loop(m.br_if(1,m.i32_eqz(m.getLocal("j"))),m.call(r+"_square",_t,_t),m.setLocal("j",m.i32_sub(m.getLocal("j"),m.i32_const(1))),m.br(0))),m.setLocal("m",m.getLocal("i")),m.call(r+"_square",_t,W),m.call(r+"_mul",it,W,it),m.call(r+"_mul",X,_t,X),m.br(0))),m.if(m.call(r+"_isNegative",X),m.call(r+"_neg",X,m.getLocal("r")),m.call(r+"_copy",X,m.getLocal("r"))))}function d(){const G=t.addFunction(r+"_isSquare");G.addParam("n","i32"),G.setReturnType("i32");const m=G.getCodeBuilder(),z=m.i32_const(w),W=m.i32_const(t.alloc(f));G.addCode(m.if(m.call(r+"_isZero",m.getLocal("n")),m.ret(m.i32_const(1))),m.call(r+"_exp",m.getLocal("n"),m.i32_const(F),m.i32_const(f),W),m.call(r+"_eq",W,z))}function S(){const G=t.addFunction(r+"_load");G.addParam("scalar","i32"),G.addParam("scalarLen","i32"),G.addParam("r","i32"),G.addLocal("p","i32"),G.addLocal("l","i32"),G.addLocal("i","i32"),G.addLocal("j","i32");const m=G.getCodeBuilder(),z=m.i32_const(t.alloc(f)),W=t.alloc(f),it=m.i32_const(W);G.addCode(m.call(c+"_zero",m.getLocal("r")),m.setLocal("i",m.i32_const(f)),m.setLocal("p",m.getLocal("scalar")),m.block(m.loop(m.br_if(1,m.i32_gt_u(m.getLocal("i"),m.getLocal("scalarLen"))),m.if(m.i32_eq(m.getLocal("i"),m.i32_const(f)),m.call(r+"_one",z),m.call(r+"_mul",z,m.i32_const(b),z)),m.call(r+"_mul",m.getLocal("p"),z,it),m.call(r+"_add",m.getLocal("r"),it,m.getLocal("r")),m.setLocal("p",m.i32_add(m.getLocal("p"),m.i32_const(f))),m.setLocal("i",m.i32_add(m.getLocal("i"),m.i32_const(f))),m.br(0))),m.setLocal("l",m.i32_rem_u(m.getLocal("scalarLen"),m.i32_const(f))),m.if(m.i32_eqz(m.getLocal("l")),m.ret([])),m.call(c+"_zero",it),m.setLocal("j",m.i32_const(0)),m.block(m.loop(m.br_if(1,m.i32_eq(m.getLocal("j"),m.getLocal("l"))),m.i32_store8(m.getLocal("j"),W,m.i32_load8_u(m.getLocal("p"))),m.setLocal("p",m.i32_add(m.getLocal("p"),m.i32_const(1))),m.setLocal("j",m.i32_add(m.getLocal("j"),m.i32_const(1))),m.br(0))),m.if(m.i32_eq(m.getLocal("i"),m.i32_const(f)),m.call(r+"_one",z),m.call(r+"_mul",z,m.i32_const(b),z)),m.call(r+"_mul",it,z,it),m.call(r+"_add",m.getLocal("r"),it,m.getLocal("r")))}function h(){const G=t.addFunction(r+"_timesScalar");G.addParam("x","i32"),G.addParam("scalar","i32"),G.addParam("scalarLen","i32"),G.addParam("r","i32");const m=G.getCodeBuilder(),z=m.i32_const(t.alloc(f));G.addCode(m.call(r+"_load",m.getLocal("scalar"),m.getLocal("scalarLen"),z),m.call(r+"_toMontgomery",z,z),m.call(r+"_mul",m.getLocal("x"),z,m.getLocal("r")))}function U(){const G=t.addFunction(r+"_isOne");G.addParam("x","i32"),G.setReturnType("i32");const m=G.getCodeBuilder();G.addCode(m.ret(m.call(c+"_eq",m.getLocal("x"),m.i32_const(w))))}return t.exportFunction(c+"_copy",r+"_copy"),t.exportFunction(c+"_zero",r+"_zero"),t.exportFunction(c+"_isZero",r+"_isZero"),t.exportFunction(c+"_eq",r+"_eq"),U(),T(),C(),_(),Z(),j(),O(),E(),q(),M(),g(),$(),Q(),P(),S(),h(),Ac(t,r),_i(t,r+"_batchToMontgomery",r+"_toMontgomery",f,f),_i(t,r+"_batchFromMontgomery",r+"_fromMontgomery",f,f),_i(t,r+"_batchNeg",r+"_neg",f,f),hi(t,r+"_batchAdd",r+"_add",f,f),hi(t,r+"_batchSub",r+"_sub",f,f),hi(t,r+"_batchMul",r+"_mul",f,f),t.exportFunction(r+"_add"),t.exportFunction(r+"_sub"),t.exportFunction(r+"_neg"),t.exportFunction(r+"_isNegative"),t.exportFunction(r+"_isOne"),t.exportFunction(r+"_sign"),t.exportFunction(r+"_mReduct"),t.exportFunction(r+"_mul"),t.exportFunction(r+"_square"),t.exportFunction(r+"_squareOld"),t.exportFunction(r+"_fromMontgomery"),t.exportFunction(r+"_toMontgomery"),t.exportFunction(r+"_inverse"),t.exportFunction(r+"_one"),t.exportFunction(r+"_load"),t.exportFunction(r+"_timesScalar"),Ec(t,r+"_exp",f,r+"_mul",r+"_square",c+"_copy",r+"_one"),t.exportFunction(r+"_exp"),t.exportFunction(r+"_batchInverse"),Pe(o)&&(I(),d(),t.exportFunction(r+"_sqrt"),t.exportFunction(r+"_isSquare")),t.exportFunction(r+"_batchToMontgomery"),t.exportFunction(r+"_batchFromMontgomery"),r};const Pc=fe,{bitLength:Gc}=fn;var Go=function(t,n,a,i,o){const l=BigInt(n),s=Math.floor((Gc(l-1n)-1)/64)+1,f=s*8,r=a||"f1";if(t.modules[r])return r;t.modules[r]={n64:s};const c=o||"int",u=Pc(t,l,i,c),b=t.modules[u].pR2,w=t.modules[u].pq,A=t.modules[u].pePlusOne;function x(){const B=t.alloc(f),P=t.addFunction(r+"_mul");P.addParam("x","i32"),P.addParam("y","i32"),P.addParam("r","i32");const T=P.getCodeBuilder();P.addCode(T.call(u+"_mul",T.getLocal("x"),T.getLocal("y"),T.i32_const(B))),P.addCode(T.call(u+"_mul",T.i32_const(B),T.i32_const(b),T.getLocal("r")))}function v(){const B=t.addFunction(r+"_square");B.addParam("x","i32"),B.addParam("r","i32");const P=B.getCodeBuilder();B.addCode(P.call(r+"_mul",P.getLocal("x"),P.getLocal("x"),P.getLocal("r")))}function F(){const B=t.addFunction(r+"_inverse");B.addParam("x","i32"),B.addParam("r","i32");const P=B.getCodeBuilder();B.addCode(P.call(c+"_inverseMod",P.getLocal("x"),P.i32_const(w),P.getLocal("r")))}function y(){const B=t.addFunction(r+"_isNegative");B.addParam("x","i32"),B.setReturnType("i32");const P=B.getCodeBuilder();B.addCode(P.call(c+"_gte",P.getLocal("x"),P.i32_const(A)))}return x(),v(),F(),y(),t.exportFunction(u+"_add",r+"_add"),t.exportFunction(u+"_sub",r+"_sub"),t.exportFunction(u+"_neg",r+"_neg"),t.exportFunction(r+"_mul"),t.exportFunction(r+"_square"),t.exportFunction(r+"_inverse"),t.exportFunction(r+"_isNegative"),t.exportFunction(u+"_copy",r+"_copy"),t.exportFunction(u+"_zero",r+"_zero"),t.exportFunction(u+"_one",r+"_one"),t.exportFunction(u+"_isZero",r+"_isZero"),t.exportFunction(u+"_eq",r+"_eq"),r};const Tc=le,Oc=re,wi=$n;var To=function(t,n,a,i){if(t.modules[a])return a;const o=t.modules[i].n64*8,l=t.modules[i].q;t.modules[a]={n64:t.modules[i].n64*2};function s(){const O=t.addFunction(a+"_add");O.addParam("x","i32"),O.addParam("y","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("y"),D=E.i32_add(E.getLocal("y"),E.i32_const(o)),V=E.getLocal("r"),nt=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_add",q,Q,V),E.call(i+"_add",M,D,nt))}function f(){const O=t.addFunction(a+"_timesScalar");O.addParam("x","i32"),O.addParam("scalar","i32"),O.addParam("scalarLen","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_timesScalar",q,E.getLocal("scalar"),E.getLocal("scalarLen"),Q),E.call(i+"_timesScalar",M,E.getLocal("scalar"),E.getLocal("scalarLen"),D))}function r(){const O=t.addFunction(a+"_sub");O.addParam("x","i32"),O.addParam("y","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("y"),D=E.i32_add(E.getLocal("y"),E.i32_const(o)),V=E.getLocal("r"),nt=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_sub",q,Q,V),E.call(i+"_sub",M,D,nt))}function c(){const O=t.addFunction(a+"_neg");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_neg",q,Q),E.call(i+"_neg",M,D))}function u(){const O=t.addFunction(a+"_conjugate");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_copy",q,Q),E.call(i+"_neg",M,D))}function b(){const O=t.addFunction(a+"_isNegative");O.addParam("x","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.if(E.call(i+"_isZero",M),E.ret(E.call(i+"_isNegative",q))),E.ret(E.call(i+"_isNegative",M)))}function w(){const O=t.addFunction(a+"_mul");O.addParam("x","i32"),O.addParam("y","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("y"),D=E.i32_add(E.getLocal("y"),E.i32_const(o)),V=E.getLocal("r"),nt=E.i32_add(E.getLocal("r"),E.i32_const(o)),R=E.i32_const(t.alloc(o)),at=E.i32_const(t.alloc(o)),J=E.i32_const(t.alloc(o)),k=E.i32_const(t.alloc(o));O.addCode(E.call(i+"_mul",q,Q,R),E.call(i+"_mul",M,D,at),E.call(i+"_add",q,M,J),E.call(i+"_add",Q,D,k),E.call(i+"_mul",J,k,J),E.call(n,at,V),E.call(i+"_add",R,V,V),E.call(i+"_add",R,at,nt),E.call(i+"_sub",J,nt,nt))}function A(){const O=t.addFunction(a+"_mul1");O.addParam("x","i32"),O.addParam("y","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("y"),D=E.getLocal("r"),V=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_mul",q,Q,D),E.call(i+"_mul",M,Q,V))}function x(){const O=t.addFunction(a+"_square");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o)),V=E.i32_const(t.alloc(o)),nt=E.i32_const(t.alloc(o)),R=E.i32_const(t.alloc(o)),at=E.i32_const(t.alloc(o));O.addCode(E.call(i+"_mul",q,M,V),E.call(i+"_add",q,M,nt),E.call(n,M,R),E.call(i+"_add",q,R,R),E.call(n,V,at),E.call(i+"_add",at,V,at),E.call(i+"_mul",nt,R,Q),E.call(i+"_sub",Q,at,Q),E.call(i+"_add",V,V,D))}function v(){const O=t.addFunction(a+"_toMontgomery");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_toMontgomery",q,Q),E.call(i+"_toMontgomery",M,D))}function F(){const O=t.addFunction(a+"_fromMontgomery");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_fromMontgomery",q,Q),E.call(i+"_fromMontgomery",M,D))}function y(){const O=t.addFunction(a+"_copy");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o));O.addCode(E.call(i+"_copy",q,Q),E.call(i+"_copy",M,D))}function B(){const O=t.addFunction(a+"_zero");O.addParam("x","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.call(i+"_zero",q),E.call(i+"_zero",M))}function P(){const O=t.addFunction(a+"_one");O.addParam("x","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.call(i+"_one",q),E.call(i+"_zero",M))}function T(){const O=t.addFunction(a+"_eq");O.addParam("x","i32"),O.addParam("y","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("y"),D=E.i32_add(E.getLocal("y"),E.i32_const(o));O.addCode(E.i32_and(E.call(i+"_eq",q,Q),E.call(i+"_eq",M,D)))}function C(){const O=t.addFunction(a+"_isZero");O.addParam("x","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.i32_and(E.call(i+"_isZero",q),E.call(i+"_isZero",M)))}function _(){const O=t.addFunction(a+"_inverse");O.addParam("x","i32"),O.addParam("r","i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o)),Q=E.getLocal("r"),D=E.i32_add(E.getLocal("r"),E.i32_const(o)),V=E.i32_const(t.alloc(o)),nt=E.i32_const(t.alloc(o)),R=E.i32_const(t.alloc(o)),at=E.i32_const(t.alloc(o));O.addCode(E.call(i+"_square",q,V),E.call(i+"_square",M,nt),E.call(n,nt,R),E.call(i+"_sub",V,R,R),E.call(i+"_inverse",R,at),E.call(i+"_mul",q,at,Q),E.call(i+"_mul",M,at,D),E.call(i+"_neg",D,D))}function g(){const O=t.addFunction(a+"_sign");O.addParam("x","i32"),O.addLocal("s","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.setLocal("s",E.call(i+"_sign",M)),E.if(E.getLocal("s"),E.ret(E.getLocal("s"))),E.ret(E.call(i+"_sign",q)))}function $(){const O=t.addFunction(a+"_isOne");O.addParam("x","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.getLocal("x"),M=E.i32_add(E.getLocal("x"),E.i32_const(o));O.addCode(E.ret(E.i32_and(E.call(i+"_isOne",q),E.call(i+"_isZero",M))))}function Z(){const O=t.addFunction(a+"_sqrt");O.addParam("a","i32"),O.addParam("pr","i32");const E=O.getCodeBuilder(),q=E.i32_const(t.alloc(wi.bigInt2BytesLE((BigInt(l||0)-3n)/4n,o))),M=E.i32_const(t.alloc(wi.bigInt2BytesLE((BigInt(l||0)-1n)/2n,o))),Q=E.getLocal("a"),D=E.i32_const(t.alloc(o*2)),V=E.i32_const(t.alloc(o*2)),nt=E.i32_const(t.alloc(o*2)),R=t.alloc(o*2),at=E.i32_const(R),J=E.i32_const(R),k=E.i32_const(R+o),K=E.i32_const(t.alloc(o*2)),I=E.i32_const(t.alloc(o*2));O.addCode(E.call(a+"_one",at),E.call(a+"_neg",at,at),E.call(a+"_exp",Q,q,E.i32_const(o),D),E.call(a+"_square",D,V),E.call(a+"_mul",Q,V,V),E.call(a+"_conjugate",V,nt),E.call(a+"_mul",nt,V,nt),E.if(E.call(a+"_eq",nt,at),E.unreachable()),E.call(a+"_mul",D,Q,K),E.if(E.call(a+"_eq",V,at),[...E.call(i+"_zero",J),...E.call(i+"_one",k),...E.call(a+"_mul",at,K,E.getLocal("pr"))],[...E.call(a+"_one",I),...E.call(a+"_add",I,V,I),...E.call(a+"_exp",I,M,E.i32_const(o),I),...E.call(a+"_mul",I,K,E.getLocal("pr"))]))}function j(){const O=t.addFunction(a+"_isSquare");O.addParam("a","i32"),O.setReturnType("i32");const E=O.getCodeBuilder(),q=E.i32_const(t.alloc(wi.bigInt2BytesLE((BigInt(l||0)-3n)/4n,o))),M=E.getLocal("a"),Q=E.i32_const(t.alloc(o*2)),D=E.i32_const(t.alloc(o*2)),V=E.i32_const(t.alloc(o*2)),nt=t.alloc(o*2),R=E.i32_const(nt);O.addCode(E.call(a+"_one",R),E.call(a+"_neg",R,R),E.call(a+"_exp",M,q,E.i32_const(o),Q),E.call(a+"_square",Q,D),E.call(a+"_mul",M,D,D),E.call(a+"_conjugate",D,V),E.call(a+"_mul",V,D,V),E.if(E.call(a+"_eq",V,R),E.ret(E.i32_const(0))),E.ret(E.i32_const(1)))}return C(),$(),B(),P(),y(),w(),A(),x(),s(),r(),c(),u(),v(),F(),T(),_(),f(),g(),b(),t.exportFunction(a+"_isZero"),t.exportFunction(a+"_isOne"),t.exportFunction(a+"_zero"),t.exportFunction(a+"_one"),t.exportFunction(a+"_copy"),t.exportFunction(a+"_mul"),t.exportFunction(a+"_mul1"),t.exportFunction(a+"_square"),t.exportFunction(a+"_add"),t.exportFunction(a+"_sub"),t.exportFunction(a+"_neg"),t.exportFunction(a+"_sign"),t.exportFunction(a+"_conjugate"),t.exportFunction(a+"_fromMontgomery"),t.exportFunction(a+"_toMontgomery"),t.exportFunction(a+"_eq"),t.exportFunction(a+"_inverse"),Oc(t,a),Tc(t,a+"_exp",o*2,a+"_mul",a+"_square",a+"_copy",a+"_one"),Z(),j(),t.exportFunction(a+"_exp"),t.exportFunction(a+"_timesScalar"),t.exportFunction(a+"_batchInverse"),t.exportFunction(a+"_sqrt"),t.exportFunction(a+"_isSquare"),t.exportFunction(a+"_isNegative"),a};const zc=le,qc=re;var Oo=function(t,n,a,i){if(t.modules[a])return a;const o=t.modules[i].n64*8;t.modules[a]={n64:t.modules[i].n64*3};function l(){const _=t.addFunction(a+"_add");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("y"),E=g.i32_add(g.getLocal("y"),g.i32_const(o)),q=g.i32_add(g.getLocal("y"),g.i32_const(2*o)),M=g.getLocal("r"),Q=g.i32_add(g.getLocal("r"),g.i32_const(o)),D=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_add",$,O,M),g.call(i+"_add",Z,E,Q),g.call(i+"_add",j,q,D))}function s(){const _=t.addFunction(a+"_timesScalar");_.addParam("x","i32"),_.addParam("scalar","i32"),_.addParam("scalarLen","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_timesScalar",$,g.getLocal("scalar"),g.getLocal("scalarLen"),O),g.call(i+"_timesScalar",Z,g.getLocal("scalar"),g.getLocal("scalarLen"),E),g.call(i+"_timesScalar",j,g.getLocal("scalar"),g.getLocal("scalarLen"),q))}function f(){const _=t.addFunction(a+"_sub");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("y"),E=g.i32_add(g.getLocal("y"),g.i32_const(o)),q=g.i32_add(g.getLocal("y"),g.i32_const(2*o)),M=g.getLocal("r"),Q=g.i32_add(g.getLocal("r"),g.i32_const(o)),D=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_sub",$,O,M),g.call(i+"_sub",Z,E,Q),g.call(i+"_sub",j,q,D))}function r(){const _=t.addFunction(a+"_neg");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_neg",$,O),g.call(i+"_neg",Z,E),g.call(i+"_neg",j,q))}function c(){const _=t.addFunction(a+"_isNegative");_.addParam("x","i32"),_.setReturnType("i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o));_.addCode(g.if(g.call(i+"_isZero",j),g.if(g.call(i+"_isZero",Z),g.ret(g.call(i+"_isNegative",$)),g.ret(g.call(i+"_isNegative",Z)))),g.ret(g.call(i+"_isNegative",j)))}function u(){const _=t.addFunction(a+"_mul");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("y"),E=g.i32_add(g.getLocal("y"),g.i32_const(o)),q=g.i32_add(g.getLocal("y"),g.i32_const(2*o)),M=g.getLocal("r"),Q=g.i32_add(g.getLocal("r"),g.i32_const(o)),D=g.i32_add(g.getLocal("r"),g.i32_const(2*o)),V=g.i32_const(t.alloc(o)),nt=g.i32_const(t.alloc(o)),R=g.i32_const(t.alloc(o)),at=g.i32_const(t.alloc(o)),J=g.i32_const(t.alloc(o)),k=g.i32_const(t.alloc(o)),K=g.i32_const(t.alloc(o)),I=g.i32_const(t.alloc(o)),d=g.i32_const(t.alloc(o)),S=g.i32_const(t.alloc(o)),h=g.i32_const(t.alloc(o)),U=g.i32_const(t.alloc(o)),G=g.i32_const(t.alloc(o));_.addCode(g.call(i+"_mul",$,O,V),g.call(i+"_mul",Z,E,nt),g.call(i+"_mul",j,q,R),g.call(i+"_add",$,Z,at),g.call(i+"_add",O,E,J),g.call(i+"_add",$,j,k),g.call(i+"_add",O,q,K),g.call(i+"_add",Z,j,I),g.call(i+"_add",E,q,d),g.call(i+"_add",V,nt,S),g.call(i+"_add",V,R,h),g.call(i+"_add",nt,R,U),g.call(i+"_mul",I,d,M),g.call(i+"_sub",M,U,M),g.call(n,M,M),g.call(i+"_add",V,M,M),g.call(i+"_mul",at,J,Q),g.call(i+"_sub",Q,S,Q),g.call(n,R,G),g.call(i+"_add",Q,G,Q),g.call(i+"_mul",k,K,D),g.call(i+"_sub",D,h,D),g.call(i+"_add",D,nt,D))}function b(){const _=t.addFunction(a+"_square");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o)),M=g.i32_const(t.alloc(o)),Q=g.i32_const(t.alloc(o)),D=g.i32_const(t.alloc(o)),V=g.i32_const(t.alloc(o)),nt=g.i32_const(t.alloc(o)),R=g.i32_const(t.alloc(o)),at=g.i32_const(t.alloc(o));_.addCode(g.call(i+"_square",$,M),g.call(i+"_mul",$,Z,Q),g.call(i+"_add",Q,Q,D),g.call(i+"_sub",$,Z,V),g.call(i+"_add",V,j,V),g.call(i+"_square",V,V),g.call(i+"_mul",Z,j,nt),g.call(i+"_add",nt,nt,R),g.call(i+"_square",j,at),g.call(n,R,O),g.call(i+"_add",M,O,O),g.call(n,at,E),g.call(i+"_add",D,E,E),g.call(i+"_add",M,at,q),g.call(i+"_sub",R,q,q),g.call(i+"_add",V,q,q),g.call(i+"_add",D,q,q))}function w(){const _=t.addFunction(a+"_toMontgomery");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_toMontgomery",$,O),g.call(i+"_toMontgomery",Z,E),g.call(i+"_toMontgomery",j,q))}function A(){const _=t.addFunction(a+"_fromMontgomery");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_fromMontgomery",$,O),g.call(i+"_fromMontgomery",Z,E),g.call(i+"_fromMontgomery",j,q))}function x(){const _=t.addFunction(a+"_copy");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o));_.addCode(g.call(i+"_copy",$,O),g.call(i+"_copy",Z,E),g.call(i+"_copy",j,q))}function v(){const _=t.addFunction(a+"_zero");_.addParam("x","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o));_.addCode(g.call(i+"_zero",$),g.call(i+"_zero",Z),g.call(i+"_zero",j))}function F(){const _=t.addFunction(a+"_one");_.addParam("x","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o));_.addCode(g.call(i+"_one",$),g.call(i+"_zero",Z),g.call(i+"_zero",j))}function y(){const _=t.addFunction(a+"_eq");_.addParam("x","i32"),_.addParam("y","i32"),_.setReturnType("i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("y"),E=g.i32_add(g.getLocal("y"),g.i32_const(o)),q=g.i32_add(g.getLocal("y"),g.i32_const(2*o));_.addCode(g.i32_and(g.i32_and(g.call(i+"_eq",$,O),g.call(i+"_eq",Z,E)),g.call(i+"_eq",j,q)))}function B(){const _=t.addFunction(a+"_isZero");_.addParam("x","i32"),_.setReturnType("i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o));_.addCode(g.i32_and(g.i32_and(g.call(i+"_isZero",$),g.call(i+"_isZero",Z)),g.call(i+"_isZero",j)))}function P(){const _=t.addFunction(a+"_inverse");_.addParam("x","i32"),_.addParam("r","i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o)),O=g.getLocal("r"),E=g.i32_add(g.getLocal("r"),g.i32_const(o)),q=g.i32_add(g.getLocal("r"),g.i32_const(2*o)),M=g.i32_const(t.alloc(o)),Q=g.i32_const(t.alloc(o)),D=g.i32_const(t.alloc(o)),V=g.i32_const(t.alloc(o)),nt=g.i32_const(t.alloc(o)),R=g.i32_const(t.alloc(o)),at=g.i32_const(t.alloc(o)),J=g.i32_const(t.alloc(o)),k=g.i32_const(t.alloc(o)),K=g.i32_const(t.alloc(o)),I=g.i32_const(t.alloc(o));_.addCode(g.call(i+"_square",$,M),g.call(i+"_square",Z,Q),g.call(i+"_square",j,D),g.call(i+"_mul",$,Z,V),g.call(i+"_mul",$,j,nt),g.call(i+"_mul",Z,j,R),g.call(n,R,at),g.call(i+"_sub",M,at,at),g.call(n,D,J),g.call(i+"_sub",J,V,J),g.call(i+"_sub",Q,nt,k),g.call(i+"_mul",j,J,K),g.call(i+"_mul",Z,k,I),g.call(i+"_add",K,I,K),g.call(n,K,K),g.call(i+"_mul",$,at,I),g.call(i+"_add",I,K,K),g.call(i+"_inverse",K,K),g.call(i+"_mul",K,at,O),g.call(i+"_mul",K,J,E),g.call(i+"_mul",K,k,q))}function T(){const _=t.addFunction(a+"_sign");_.addParam("x","i32"),_.addLocal("s","i32"),_.setReturnType("i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(2*o));_.addCode(g.setLocal("s",g.call(i+"_sign",j)),g.if(g.getLocal("s"),g.ret(g.getLocal("s"))),g.setLocal("s",g.call(i+"_sign",Z)),g.if(g.getLocal("s"),g.ret(g.getLocal("s"))),g.ret(g.call(i+"_sign",$)))}function C(){const _=t.addFunction(a+"_isOne");_.addParam("x","i32"),_.setReturnType("i32");const g=_.getCodeBuilder(),$=g.getLocal("x"),Z=g.i32_add(g.getLocal("x"),g.i32_const(o)),j=g.i32_add(g.getLocal("x"),g.i32_const(o*2));_.addCode(g.ret(g.i32_and(g.i32_and(g.call(i+"_isOne",$),g.call(i+"_isZero",Z)),g.call(i+"_isZero",j))))}return B(),C(),v(),F(),x(),u(),b(),l(),f(),r(),T(),w(),A(),y(),P(),s(),c(),t.exportFunction(a+"_isZero"),t.exportFunction(a+"_isOne"),t.exportFunction(a+"_zero"),t.exportFunction(a+"_one"),t.exportFunction(a+"_copy"),t.exportFunction(a+"_mul"),t.exportFunction(a+"_square"),t.exportFunction(a+"_add"),t.exportFunction(a+"_sub"),t.exportFunction(a+"_neg"),t.exportFunction(a+"_sign"),t.exportFunction(a+"_fromMontgomery"),t.exportFunction(a+"_toMontgomery"),t.exportFunction(a+"_eq"),t.exportFunction(a+"_inverse"),qc(t,a),zc(t,a+"_exp",o*3,a+"_mul",a+"_square",a+"_copy",a+"_one"),t.exportFunction(a+"_exp"),t.exportFunction(a+"_timesScalar"),t.exportFunction(a+"_batchInverse"),t.exportFunction(a+"_isNegative"),a},Mc=function(t,n,a,i,o,l,s,f){const r=t.addFunction(n);r.addParam("base","i32"),r.addParam("scalar","i32"),r.addParam("scalarLength","i32"),r.addParam("r","i32"),r.addLocal("old0","i32"),r.addLocal("nbits","i32"),r.addLocal("i","i32"),r.addLocal("last","i32"),r.addLocal("cur","i32"),r.addLocal("carry","i32"),r.addLocal("p","i32");const c=r.getCodeBuilder(),u=c.i32_const(t.alloc(a));function b(A){return c.i32_and(c.i32_shr_u(c.i32_load(c.i32_add(c.getLocal("scalar"),c.i32_and(c.i32_shr_u(A,c.i32_const(3)),c.i32_const(4294967292)))),c.i32_and(A,c.i32_const(31))),c.i32_const(1))}function w(A){return[...c.i32_store8(c.getLocal("p"),c.i32_const(A)),...c.setLocal("p",c.i32_add(c.getLocal("p"),c.i32_const(1)))]}r.addCode(c.if(c.i32_eqz(c.getLocal("scalarLength")),[...c.call(f,c.getLocal("r")),...c.ret([])]),c.setLocal("nbits",c.i32_shl(c.getLocal("scalarLength"),c.i32_const(3))),c.setLocal("old0",c.i32_load(c.i32_const(0))),c.setLocal("p",c.getLocal("old0")),c.i32_store(c.i32_const(0),c.i32_and(c.i32_add(c.i32_add(c.getLocal("old0"),c.i32_const(32)),c.getLocal("nbits")),c.i32_const(4294967288))),c.setLocal("i",c.i32_const(1)),c.setLocal("last",b(c.i32_const(0))),c.setLocal("carry",c.i32_const(0)),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("i"),c.getLocal("nbits"))),c.setLocal("cur",b(c.getLocal("i"))),c.if(c.getLocal("last"),c.if(c.getLocal("cur"),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...w(1)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...w(255)]),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...w(255)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(0)),...w(1)])),c.if(c.getLocal("cur"),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...w(0)],[...c.setLocal("last",c.i32_const(1)),...c.setLocal("carry",c.i32_const(0)),...w(0)]),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(1)),...c.setLocal("carry",c.i32_const(0)),...w(0)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(0)),...w(0)]))),c.setLocal("i",c.i32_add(c.getLocal("i"),c.i32_const(1))),c.br(0))),c.if(c.getLocal("last"),c.if(c.getLocal("carry"),[...w(255),...w(0),...w(1)],[...w(1)]),c.if(c.getLocal("carry"),[...w(0),...w(1)])),c.setLocal("p",c.i32_sub(c.getLocal("p"),c.i32_const(1))),c.call(s,c.getLocal("base"),u),c.call(f,c.getLocal("r")),c.block(c.loop(c.call(o,c.getLocal("r"),c.getLocal("r")),c.setLocal("cur",c.i32_load8_u(c.getLocal("p"))),c.if(c.getLocal("cur"),c.if(c.i32_eq(c.getLocal("cur"),c.i32_const(1)),c.call(i,c.getLocal("r"),u,c.getLocal("r")),c.call(l,c.getLocal("r"),u,c.getLocal("r")))),c.br_if(1,c.i32_eq(c.getLocal("old0"),c.getLocal("p"))),c.setLocal("p",c.i32_sub(c.getLocal("p"),c.i32_const(1))),c.br(0))),c.i32_store(c.i32_const(0),c.getLocal("old0")))},Uc=function(t,n,a,i,o){const s=t.modules[n].n64*8;function f(){const b=t.addFunction(a+"_getChunk");b.addParam("pScalar","i32"),b.addParam("scalarSize","i32"),b.addParam("startBit","i32"),b.addParam("chunkSize","i32"),b.addLocal("bitsToEnd","i32"),b.addLocal("mask","i32"),b.setReturnType("i32");const w=b.getCodeBuilder();b.addCode(w.setLocal("bitsToEnd",w.i32_sub(w.i32_mul(w.getLocal("scalarSize"),w.i32_const(8)),w.getLocal("startBit"))),w.if(w.i32_gt_s(w.getLocal("chunkSize"),w.getLocal("bitsToEnd")),w.setLocal("mask",w.i32_sub(w.i32_shl(w.i32_const(1),w.getLocal("bitsToEnd")),w.i32_const(1))),w.setLocal("mask",w.i32_sub(w.i32_shl(w.i32_const(1),w.getLocal("chunkSize")),w.i32_const(1)))),w.i32_and(w.i32_shr_u(w.i32_load(w.i32_add(w.getLocal("pScalar"),w.i32_shr_u(w.getLocal("startBit"),w.i32_const(3))),0,0),w.i32_and(w.getLocal("startBit"),w.i32_const(7))),w.getLocal("mask")))}function r(){const b=t.addFunction(a+"_chunk");b.addParam("pBases","i32"),b.addParam("pScalars","i32"),b.addParam("scalarSize","i32"),b.addParam("n","i32"),b.addParam("startBit","i32"),b.addParam("chunkSize","i32"),b.addParam("pr","i32"),b.addLocal("nChunks","i32"),b.addLocal("itScalar","i32"),b.addLocal("endScalar","i32"),b.addLocal("itBase","i32"),b.addLocal("i","i32"),b.addLocal("j","i32"),b.addLocal("nTable","i32"),b.addLocal("pTable","i32"),b.addLocal("idx","i32"),b.addLocal("pIdxTable","i32");const w=b.getCodeBuilder();b.addCode(w.if(w.i32_eqz(w.getLocal("n")),[...w.call(n+"_zero",w.getLocal("pr")),...w.ret([])]),w.setLocal("nTable",w.i32_shl(w.i32_const(1),w.getLocal("chunkSize"))),w.setLocal("pTable",w.i32_load(w.i32_const(0))),w.i32_store(w.i32_const(0),w.i32_add(w.getLocal("pTable"),w.i32_mul(w.getLocal("nTable"),w.i32_const(s)))),w.setLocal("j",w.i32_const(0)),w.block(w.loop(w.br_if(1,w.i32_eq(w.getLocal("j"),w.getLocal("nTable"))),w.call(n+"_zero",w.i32_add(w.getLocal("pTable"),w.i32_mul(w.getLocal("j"),w.i32_const(s)))),w.setLocal("j",w.i32_add(w.getLocal("j"),w.i32_const(1))),w.br(0))),w.setLocal("itBase",w.getLocal("pBases")),w.setLocal("itScalar",w.getLocal("pScalars")),w.setLocal("endScalar",w.i32_add(w.getLocal("pScalars"),w.i32_mul(w.getLocal("n"),w.getLocal("scalarSize")))),w.block(w.loop(w.br_if(1,w.i32_eq(w.getLocal("itScalar"),w.getLocal("endScalar"))),w.setLocal("idx",w.call(a+"_getChunk",w.getLocal("itScalar"),w.getLocal("scalarSize"),w.getLocal("startBit"),w.getLocal("chunkSize"))),w.if(w.getLocal("idx"),[...w.setLocal("pIdxTable",w.i32_add(w.getLocal("pTable"),w.i32_mul(w.i32_sub(w.getLocal("idx"),w.i32_const(1)),w.i32_const(s)))),...w.call(i,w.getLocal("pIdxTable"),w.getLocal("itBase"),w.getLocal("pIdxTable"))]),w.setLocal("itScalar",w.i32_add(w.getLocal("itScalar"),w.getLocal("scalarSize"))),w.setLocal("itBase",w.i32_add(w.getLocal("itBase"),w.i32_const(o))),w.br(0))),w.call(a+"_reduceTable",w.getLocal("pTable"),w.getLocal("chunkSize")),w.call(n+"_copy",w.getLocal("pTable"),w.getLocal("pr")),w.i32_store(w.i32_const(0),w.getLocal("pTable")))}function c(){const b=t.addFunction(a);b.addParam("pBases","i32"),b.addParam("pScalars","i32"),b.addParam("scalarSize","i32"),b.addParam("n","i32"),b.addParam("pr","i32"),b.addLocal("chunkSize","i32"),b.addLocal("nChunks","i32"),b.addLocal("itScalar","i32"),b.addLocal("endScalar","i32"),b.addLocal("itBase","i32"),b.addLocal("itBit","i32"),b.addLocal("i","i32"),b.addLocal("j","i32"),b.addLocal("nTable","i32"),b.addLocal("pTable","i32"),b.addLocal("idx","i32"),b.addLocal("pIdxTable","i32");const w=b.getCodeBuilder(),A=w.i32_const(t.alloc(s)),x=t.alloc([17,17,17,17,17,17,17,17,17,17,16,16,15,14,13,13,12,11,10,9,8,7,7,6,5,4,3,2,1,1,1,1]);b.addCode(w.call(n+"_zero",w.getLocal("pr")),w.if(w.i32_eqz(w.getLocal("n")),w.ret([])),w.setLocal("chunkSize",w.i32_load8_u(w.i32_clz(w.getLocal("n")),x)),w.setLocal("nChunks",w.i32_add(w.i32_div_u(w.i32_sub(w.i32_shl(w.getLocal("scalarSize"),w.i32_const(3)),w.i32_const(1)),w.getLocal("chunkSize")),w.i32_const(1))),w.setLocal("itBit",w.i32_mul(w.i32_sub(w.getLocal("nChunks"),w.i32_const(1)),w.getLocal("chunkSize"))),w.block(w.loop(w.br_if(1,w.i32_lt_s(w.getLocal("itBit"),w.i32_const(0))),w.if(w.i32_eqz(w.call(n+"_isZero",w.getLocal("pr"))),[...w.setLocal("j",w.i32_const(0)),...w.block(w.loop(w.br_if(1,w.i32_eq(w.getLocal("j"),w.getLocal("chunkSize"))),w.call(n+"_double",w.getLocal("pr"),w.getLocal("pr")),w.setLocal("j",w.i32_add(w.getLocal("j"),w.i32_const(1))),w.br(0)))]),w.call(a+"_chunk",w.getLocal("pBases"),w.getLocal("pScalars"),w.getLocal("scalarSize"),w.getLocal("n"),w.getLocal("itBit"),w.getLocal("chunkSize"),A),w.call(n+"_add",w.getLocal("pr"),A,w.getLocal("pr")),w.setLocal("itBit",w.i32_sub(w.getLocal("itBit"),w.getLocal("chunkSize"))),w.br(0))))}function u(){const b=t.addFunction(a+"_reduceTable");b.addParam("pTable","i32"),b.addParam("p","i32"),b.addLocal("half","i32"),b.addLocal("it1","i32"),b.addLocal("it2","i32"),b.addLocal("pAcc","i32");const w=b.getCodeBuilder();b.addCode(w.if(w.i32_eq(w.getLocal("p"),w.i32_const(1)),w.ret([])),w.setLocal("half",w.i32_shl(w.i32_const(1),w.i32_sub(w.getLocal("p"),w.i32_const(1)))),w.setLocal("it1",w.getLocal("pTable")),w.setLocal("it2",w.i32_add(w.getLocal("pTable"),w.i32_mul(w.getLocal("half"),w.i32_const(s)))),w.setLocal("pAcc",w.i32_sub(w.getLocal("it2"),w.i32_const(s))),w.block(w.loop(w.br_if(1,w.i32_eq(w.getLocal("it1"),w.getLocal("pAcc"))),w.call(n+"_add",w.getLocal("it1"),w.getLocal("it2"),w.getLocal("it1")),w.call(n+"_add",w.getLocal("pAcc"),w.getLocal("it2"),w.getLocal("pAcc")),w.setLocal("it1",w.i32_add(w.getLocal("it1"),w.i32_const(s))),w.setLocal("it2",w.i32_add(w.getLocal("it2"),w.i32_const(s))),w.br(0))),w.call(a+"_reduceTable",w.getLocal("pTable"),w.i32_sub(w.getLocal("p"),w.i32_const(1))),w.setLocal("p",w.i32_sub(w.getLocal("p"),w.i32_const(1))),w.block(w.loop(w.br_if(1,w.i32_eqz(w.getLocal("p"))),w.call(n+"_double",w.getLocal("pAcc"),w.getLocal("pAcc")),w.setLocal("p",w.i32_sub(w.getLocal("p"),w.i32_const(1))),w.br(0))),w.call(n+"_add",w.getLocal("pTable"),w.getLocal("pAcc"),w.getLocal("pTable")))}f(),u(),r(),c(),t.exportFunction(a),t.exportFunction(a+"_chunk")};const Ge=Mc,ha=Eo,Te=Uc;var zo=function(t,n,a,i){const o=t.modules[a].n64,l=o*8;if(t.modules[n])return n;t.modules[n]={n64:o*3};function s(){const I=t.addFunction(n+"_isZero");I.addParam("p1","i32"),I.setReturnType("i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_isZero",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))))}function f(){const I=t.addFunction(n+"_isZeroAffine");I.addParam("p1","i32"),I.setReturnType("i32");const d=I.getCodeBuilder();I.addCode(d.i32_and(d.call(a+"_isZero",d.getLocal("p1")),d.call(a+"_isZero",d.i32_add(d.getLocal("p1"),d.i32_const(l)))))}function r(){const I=t.addFunction(n+"_copy");I.addParam("ps","i32"),I.addParam("pd","i32");const d=I.getCodeBuilder();for(let S=0;S<o*3;S++)I.addCode(d.i64_store(d.getLocal("pd"),S*8,d.i64_load(d.getLocal("ps"),S*8)))}function c(){const I=t.addFunction(n+"_copyAffine");I.addParam("ps","i32"),I.addParam("pd","i32");const d=I.getCodeBuilder();for(let S=0;S<o*2;S++)I.addCode(d.i64_store(d.getLocal("pd"),S*8,d.i64_load(d.getLocal("ps"),S*8)))}function u(){const I=t.addFunction(n+"_zero");I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_zero",d.getLocal("pr"))),I.addCode(d.call(a+"_one",d.i32_add(d.getLocal("pr"),d.i32_const(l)))),I.addCode(d.call(a+"_zero",d.i32_add(d.getLocal("pr"),d.i32_const(l*2))))}function b(){const I=t.addFunction(n+"_zeroAffine");I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_zero",d.getLocal("pr"))),I.addCode(d.call(a+"_zero",d.i32_add(d.getLocal("pr"),d.i32_const(l))))}function w(){const I=t.addFunction(n+"_eq");I.addParam("p1","i32"),I.addParam("p2","i32"),I.setReturnType("i32"),I.addLocal("z1","i32"),I.addLocal("z2","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l));I.addCode(d.setLocal("z1",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))));const U=d.getLocal("z1"),G=d.getLocal("p2"),m=d.i32_add(d.getLocal("p2"),d.i32_const(l));I.addCode(d.setLocal("z2",d.i32_add(d.getLocal("p2"),d.i32_const(l*2))));const z=d.getLocal("z2"),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l)),wt=d.i32_const(t.alloc(l)),ft=d.i32_const(t.alloc(l)),st=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),d.ret(d.call(n+"_isZero",d.getLocal("p2")))),d.if(d.call(n+"_isZero",d.getLocal("p2")),d.ret(d.i32_const(0))),d.if(d.call(a+"_isOne",U),d.ret(d.call(n+"_eqMixed",d.getLocal("p2"),d.getLocal("p1")))),d.if(d.call(a+"_isOne",z),d.ret(d.call(n+"_eqMixed",d.getLocal("p1"),d.getLocal("p2")))),d.call(a+"_square",U,W),d.call(a+"_square",z,it),d.call(a+"_mul",S,it,X),d.call(a+"_mul",G,W,lt),d.call(a+"_mul",U,W,_t),d.call(a+"_mul",z,it,wt),d.call(a+"_mul",h,wt,ft),d.call(a+"_mul",m,_t,st),d.if(d.call(a+"_eq",X,lt),d.if(d.call(a+"_eq",ft,st),d.ret(d.i32_const(1)))),d.ret(d.i32_const(0)))}function A(){const I=t.addFunction(n+"_eqMixed");I.addParam("p1","i32"),I.addParam("p2","i32"),I.setReturnType("i32"),I.addLocal("z1","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l));I.addCode(d.setLocal("z1",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))));const U=d.getLocal("z1"),G=d.getLocal("p2"),m=d.i32_add(d.getLocal("p2"),d.i32_const(l)),z=d.i32_const(t.alloc(l)),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),d.ret(d.call(n+"_isZeroAffine",d.getLocal("p2")))),d.if(d.call(n+"_isZeroAffine",d.getLocal("p2")),d.ret(d.i32_const(0))),d.if(d.call(a+"_isOne",U),d.ret(d.call(n+"_eqAffine",d.getLocal("p1"),d.getLocal("p2")))),d.call(a+"_square",U,z),d.call(a+"_mul",G,z,W),d.call(a+"_mul",U,z,it),d.call(a+"_mul",m,it,X),d.if(d.call(a+"_eq",S,W),d.if(d.call(a+"_eq",h,X),d.ret(d.i32_const(1)))),d.ret(d.i32_const(0)))}function x(){const I=t.addFunction(n+"_double");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.i32_add(d.getLocal("p1"),d.i32_const(l*2)),G=d.getLocal("pr"),m=d.i32_add(d.getLocal("pr"),d.i32_const(l)),z=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l)),wt=d.i32_const(t.alloc(l)),ft=d.i32_const(t.alloc(l)),st=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),[...d.call(n+"_copy",d.getLocal("p1"),d.getLocal("pr")),...d.ret([])]),d.if(d.call(a+"_isOne",U),[...d.ret(d.call(n+"_doubleAffine",d.getLocal("p1"),d.getLocal("pr"))),...d.ret([])]),d.call(a+"_square",S,W),d.call(a+"_square",h,it),d.call(a+"_square",it,X),d.call(a+"_add",S,it,lt),d.call(a+"_square",lt,lt),d.call(a+"_sub",lt,W,lt),d.call(a+"_sub",lt,X,lt),d.call(a+"_add",lt,lt,lt),d.call(a+"_add",W,W,_t),d.call(a+"_add",_t,W,_t),d.call(a+"_square",_t,wt),d.call(a+"_mul",h,U,ft),d.call(a+"_add",lt,lt,G),d.call(a+"_sub",wt,G,G),d.call(a+"_add",X,X,st),d.call(a+"_add",st,st,st),d.call(a+"_add",st,st,st),d.call(a+"_sub",lt,G,m),d.call(a+"_mul",m,_t,m),d.call(a+"_sub",m,st,m),d.call(a+"_add",ft,ft,z))}function v(){const I=t.addFunction(n+"_doubleAffine");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.getLocal("pr"),G=d.i32_add(d.getLocal("pr"),d.i32_const(l)),m=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),z=d.i32_const(t.alloc(l)),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZeroAffine",d.getLocal("p1")),[...d.call(n+"_toJacobian",d.getLocal("p1"),d.getLocal("pr")),...d.ret([])]),d.call(a+"_square",S,z),d.call(a+"_square",h,W),d.call(a+"_square",W,it),d.call(a+"_add",S,W,X),d.call(a+"_square",X,X),d.call(a+"_sub",X,z,X),d.call(a+"_sub",X,it,X),d.call(a+"_add",X,X,X),d.call(a+"_add",z,z,lt),d.call(a+"_add",lt,z,lt),d.call(a+"_add",h,h,m),d.call(a+"_square",lt,U),d.call(a+"_sub",U,X,U),d.call(a+"_sub",U,X,U),d.call(a+"_add",it,it,_t),d.call(a+"_add",_t,_t,_t),d.call(a+"_add",_t,_t,_t),d.call(a+"_sub",X,U,G),d.call(a+"_mul",G,lt,G),d.call(a+"_sub",G,_t,G))}function F(){const I=t.addFunction(n+"_eqAffine");I.addParam("p1","i32"),I.addParam("p2","i32"),I.setReturnType("i32"),I.addLocal("z1","i32");const d=I.getCodeBuilder();I.addCode(d.ret(d.i32_and(d.call(a+"_eq",d.getLocal("p1"),d.getLocal("p2")),d.call(a+"_eq",d.i32_add(d.getLocal("p1"),d.i32_const(l)),d.i32_add(d.getLocal("p2"),d.i32_const(l))))))}function y(){const I=t.addFunction(n+"_toMontgomery");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_toMontgomery",d.getLocal("p1"),d.getLocal("pr")));for(let S=1;S<3;S++)I.addCode(d.call(a+"_toMontgomery",d.i32_add(d.getLocal("p1"),d.i32_const(S*l)),d.i32_add(d.getLocal("pr"),d.i32_const(S*l))))}function B(){const I=t.addFunction(n+"_toMontgomeryAffine");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_toMontgomery",d.getLocal("p1"),d.getLocal("pr")));for(let S=1;S<2;S++)I.addCode(d.call(a+"_toMontgomery",d.i32_add(d.getLocal("p1"),d.i32_const(S*l)),d.i32_add(d.getLocal("pr"),d.i32_const(S*l))))}function P(){const I=t.addFunction(n+"_fromMontgomery");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_fromMontgomery",d.getLocal("p1"),d.getLocal("pr")));for(let S=1;S<3;S++)I.addCode(d.call(a+"_fromMontgomery",d.i32_add(d.getLocal("p1"),d.i32_const(S*l)),d.i32_add(d.getLocal("pr"),d.i32_const(S*l))))}function T(){const I=t.addFunction(n+"_fromMontgomeryAffine");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder();I.addCode(d.call(a+"_fromMontgomery",d.getLocal("p1"),d.getLocal("pr")));for(let S=1;S<2;S++)I.addCode(d.call(a+"_fromMontgomery",d.i32_add(d.getLocal("p1"),d.i32_const(S*l)),d.i32_add(d.getLocal("pr"),d.i32_const(S*l))))}function C(){const I=t.addFunction(n+"_add");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32"),I.addLocal("z1","i32"),I.addLocal("z2","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l));I.addCode(d.setLocal("z1",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))));const U=d.getLocal("z1"),G=d.getLocal("p2"),m=d.i32_add(d.getLocal("p2"),d.i32_const(l));I.addCode(d.setLocal("z2",d.i32_add(d.getLocal("p2"),d.i32_const(l*2))));const z=d.getLocal("z2"),W=d.getLocal("pr"),it=d.i32_add(d.getLocal("pr"),d.i32_const(l)),X=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l)),wt=d.i32_const(t.alloc(l)),ft=d.i32_const(t.alloc(l)),st=d.i32_const(t.alloc(l)),ct=d.i32_const(t.alloc(l)),gt=d.i32_const(t.alloc(l)),yt=d.i32_const(t.alloc(l)),xt=d.i32_const(t.alloc(l)),Rt=d.i32_const(t.alloc(l)),Vt=d.i32_const(t.alloc(l)),jt=d.i32_const(t.alloc(l)),Pt=d.i32_const(t.alloc(l)),bt=d.i32_const(t.alloc(l)),kt=d.i32_const(t.alloc(l)),Jt=d.i32_const(t.alloc(l)),Dt=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),[...d.call(n+"_copy",d.getLocal("p2"),d.getLocal("pr")),...d.ret([])]),d.if(d.call(n+"_isZero",d.getLocal("p2")),[...d.call(n+"_copy",d.getLocal("p1"),d.getLocal("pr")),...d.ret([])]),d.if(d.call(a+"_isOne",U),[...d.call(n+"_addMixed",G,S,W),...d.ret([])]),d.if(d.call(a+"_isOne",z),[...d.call(n+"_addMixed",S,G,W),...d.ret([])]),d.call(a+"_square",U,lt),d.call(a+"_square",z,_t),d.call(a+"_mul",S,_t,wt),d.call(a+"_mul",G,lt,ft),d.call(a+"_mul",U,lt,st),d.call(a+"_mul",z,_t,ct),d.call(a+"_mul",h,ct,gt),d.call(a+"_mul",m,st,yt),d.if(d.call(a+"_eq",wt,ft),d.if(d.call(a+"_eq",gt,yt),[...d.call(n+"_double",d.getLocal("p1"),d.getLocal("pr")),...d.ret([])])),d.call(a+"_sub",ft,wt,xt),d.call(a+"_sub",yt,gt,Rt),d.call(a+"_add",xt,xt,Vt),d.call(a+"_square",Vt,Vt),d.call(a+"_mul",xt,Vt,jt),d.call(a+"_add",Rt,Rt,Pt),d.call(a+"_mul",wt,Vt,kt),d.call(a+"_square",Pt,bt),d.call(a+"_add",kt,kt,Jt),d.call(a+"_sub",bt,jt,W),d.call(a+"_sub",W,Jt,W),d.call(a+"_mul",gt,jt,Dt),d.call(a+"_add",Dt,Dt,Dt),d.call(a+"_sub",kt,W,it),d.call(a+"_mul",it,Pt,it),d.call(a+"_sub",it,Dt,it),d.call(a+"_add",U,z,X),d.call(a+"_square",X,X),d.call(a+"_sub",X,lt,X),d.call(a+"_sub",X,_t,X),d.call(a+"_mul",X,xt,X))}function _(){const I=t.addFunction(n+"_addMixed");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32"),I.addLocal("z1","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l));I.addCode(d.setLocal("z1",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))));const U=d.getLocal("z1"),G=d.getLocal("p2"),m=d.i32_add(d.getLocal("p2"),d.i32_const(l)),z=d.getLocal("pr"),W=d.i32_add(d.getLocal("pr"),d.i32_const(l)),it=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),X=d.i32_const(t.alloc(l)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l)),wt=d.i32_const(t.alloc(l)),ft=d.i32_const(t.alloc(l)),st=d.i32_const(t.alloc(l)),ct=d.i32_const(t.alloc(l)),gt=d.i32_const(t.alloc(l)),yt=d.i32_const(t.alloc(l)),xt=d.i32_const(t.alloc(l)),Rt=d.i32_const(t.alloc(l)),Vt=d.i32_const(t.alloc(l)),jt=d.i32_const(t.alloc(l)),Pt=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),[...d.call(n+"_copyAffine",d.getLocal("p2"),d.getLocal("pr")),...d.call(a+"_one",d.i32_add(d.getLocal("pr"),d.i32_const(l*2))),...d.ret([])]),d.if(d.call(n+"_isZeroAffine",d.getLocal("p2")),[...d.call(n+"_copy",d.getLocal("p1"),d.getLocal("pr")),...d.ret([])]),d.if(d.call(a+"_isOne",U),[...d.call(n+"_addAffine",S,G,z),...d.ret([])]),d.call(a+"_square",U,X),d.call(a+"_mul",G,X,lt),d.call(a+"_mul",U,X,_t),d.call(a+"_mul",m,_t,wt),d.if(d.call(a+"_eq",S,lt),d.if(d.call(a+"_eq",h,wt),[...d.call(n+"_doubleAffine",d.getLocal("p2"),d.getLocal("pr")),...d.ret([])])),d.call(a+"_sub",lt,S,ft),d.call(a+"_sub",wt,h,ct),d.call(a+"_square",ft,st),d.call(a+"_add",st,st,gt),d.call(a+"_add",gt,gt,gt),d.call(a+"_mul",ft,gt,yt),d.call(a+"_add",ct,ct,xt),d.call(a+"_mul",S,gt,Vt),d.call(a+"_square",xt,Rt),d.call(a+"_add",Vt,Vt,jt),d.call(a+"_sub",Rt,yt,z),d.call(a+"_sub",z,jt,z),d.call(a+"_mul",h,yt,Pt),d.call(a+"_add",Pt,Pt,Pt),d.call(a+"_sub",Vt,z,W),d.call(a+"_mul",W,xt,W),d.call(a+"_sub",W,Pt,W),d.call(a+"_add",U,ft,it),d.call(a+"_square",it,it),d.call(a+"_sub",it,X,it),d.call(a+"_sub",it,st,it))}function g(){const I=t.addFunction(n+"_addAffine");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32"),I.addLocal("z1","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l));I.addCode(d.setLocal("z1",d.i32_add(d.getLocal("p1"),d.i32_const(l*2))));const U=d.getLocal("p2"),G=d.i32_add(d.getLocal("p2"),d.i32_const(l)),m=d.getLocal("pr"),z=d.i32_add(d.getLocal("pr"),d.i32_const(l)),W=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l)),lt=d.i32_const(t.alloc(l)),_t=d.i32_const(t.alloc(l)),wt=d.i32_const(t.alloc(l)),ft=d.i32_const(t.alloc(l)),st=d.i32_const(t.alloc(l)),ct=d.i32_const(t.alloc(l)),gt=d.i32_const(t.alloc(l)),yt=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZeroAffine",d.getLocal("p1")),[...d.call(n+"_copyAffine",d.getLocal("p2"),d.getLocal("pr")),...d.call(a+"_one",d.i32_add(d.getLocal("pr"),d.i32_const(l*2))),...d.ret([])]),d.if(d.call(n+"_isZeroAffine",d.getLocal("p2")),[...d.call(n+"_copyAffine",d.getLocal("p1"),d.getLocal("pr")),...d.call(a+"_one",d.i32_add(d.getLocal("pr"),d.i32_const(l*2))),...d.ret([])]),d.if(d.call(a+"_eq",S,U),d.if(d.call(a+"_eq",h,G),[...d.call(n+"_doubleAffine",d.getLocal("p2"),d.getLocal("pr")),...d.ret([])])),d.call(a+"_sub",U,S,it),d.call(a+"_sub",G,h,lt),d.call(a+"_square",it,X),d.call(a+"_add",X,X,_t),d.call(a+"_add",_t,_t,_t),d.call(a+"_mul",it,_t,wt),d.call(a+"_add",lt,lt,ft),d.call(a+"_mul",S,_t,ct),d.call(a+"_square",ft,st),d.call(a+"_add",ct,ct,gt),d.call(a+"_sub",st,wt,m),d.call(a+"_sub",m,gt,m),d.call(a+"_mul",h,wt,yt),d.call(a+"_add",yt,yt,yt),d.call(a+"_sub",ct,m,z),d.call(a+"_mul",z,ft,z),d.call(a+"_sub",z,yt,z),d.call(a+"_add",it,it,W))}function $(){const I=t.addFunction(n+"_neg");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.i32_add(d.getLocal("p1"),d.i32_const(l*2)),G=d.getLocal("pr"),m=d.i32_add(d.getLocal("pr"),d.i32_const(l)),z=d.i32_add(d.getLocal("pr"),d.i32_const(l*2));I.addCode(d.call(a+"_copy",S,G),d.call(a+"_neg",h,m),d.call(a+"_copy",U,z))}function Z(){const I=t.addFunction(n+"_negAffine");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.getLocal("pr"),G=d.i32_add(d.getLocal("pr"),d.i32_const(l));I.addCode(d.call(a+"_copy",S,U),d.call(a+"_neg",h,G))}function j(){const I=t.addFunction(n+"_sub");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l*3));I.addCode(d.call(n+"_neg",d.getLocal("p2"),S),d.call(n+"_add",d.getLocal("p1"),S,d.getLocal("pr")))}function O(){const I=t.addFunction(n+"_subMixed");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l*3));I.addCode(d.call(n+"_negAffine",d.getLocal("p2"),S),d.call(n+"_addMixed",d.getLocal("p1"),S,d.getLocal("pr")))}function E(){const I=t.addFunction(n+"_subAffine");I.addParam("p1","i32"),I.addParam("p2","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l*3));I.addCode(d.call(n+"_negAffine",d.getLocal("p2"),S),d.call(n+"_addAffine",d.getLocal("p1"),S,d.getLocal("pr")))}function q(){const I=t.addFunction(n+"_normalize");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.i32_add(d.getLocal("p1"),d.i32_const(l*2)),G=d.getLocal("pr"),m=d.i32_add(d.getLocal("pr"),d.i32_const(l)),z=d.i32_add(d.getLocal("pr"),d.i32_const(l*2)),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l)),X=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),d.call(n+"_zero",d.getLocal("pr")),[...d.call(a+"_inverse",U,W),...d.call(a+"_square",W,it),...d.call(a+"_mul",W,it,X),...d.call(a+"_mul",S,it,G),...d.call(a+"_mul",h,X,m),...d.call(a+"_one",z)]))}function M(){const I=t.addFunction(n+"_toAffine");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.i32_add(d.getLocal("p1"),d.i32_const(l*2)),G=d.getLocal("pr"),m=d.i32_add(d.getLocal("pr"),d.i32_const(l)),z=d.i32_const(t.alloc(l)),W=d.i32_const(t.alloc(l)),it=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZero",d.getLocal("p1")),[...d.call(a+"_zero",G),...d.call(a+"_zero",m)],[...d.call(a+"_inverse",U,z),...d.call(a+"_square",z,W),...d.call(a+"_mul",z,W,it),...d.call(a+"_mul",S,W,G),...d.call(a+"_mul",h,it,m)]))}function Q(){const I=t.addFunction(n+"_toJacobian");I.addParam("p1","i32"),I.addParam("pr","i32");const d=I.getCodeBuilder(),S=d.getLocal("p1"),h=d.i32_add(d.getLocal("p1"),d.i32_const(l)),U=d.getLocal("pr"),G=d.i32_add(d.getLocal("pr"),d.i32_const(l)),m=d.i32_add(d.getLocal("pr"),d.i32_const(l*2));I.addCode(d.if(d.call(n+"_isZeroAffine",d.getLocal("p1")),d.call(n+"_zero",d.getLocal("pr")),[...d.call(a+"_one",m),...d.call(a+"_copy",h,G),...d.call(a+"_copy",S,U)]))}function D(){const I=t.addFunction(n+"_batchToAffine");I.addParam("pIn","i32"),I.addParam("n","i32"),I.addParam("pOut","i32"),I.addLocal("pAux","i32"),I.addLocal("itIn","i32"),I.addLocal("itAux","i32"),I.addLocal("itOut","i32"),I.addLocal("i","i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l));I.addCode(d.setLocal("pAux",d.i32_load(d.i32_const(0))),d.i32_store(d.i32_const(0),d.i32_add(d.getLocal("pAux"),d.i32_mul(d.getLocal("n"),d.i32_const(l)))),d.call(a+"_batchInverse",d.i32_add(d.getLocal("pIn"),d.i32_const(l*2)),d.i32_const(l*3),d.getLocal("n"),d.getLocal("pAux"),d.i32_const(l)),d.setLocal("itIn",d.getLocal("pIn")),d.setLocal("itAux",d.getLocal("pAux")),d.setLocal("itOut",d.getLocal("pOut")),d.setLocal("i",d.i32_const(0)),d.block(d.loop(d.br_if(1,d.i32_eq(d.getLocal("i"),d.getLocal("n"))),d.if(d.call(a+"_isZero",d.getLocal("itAux")),[...d.call(a+"_zero",d.getLocal("itOut")),...d.call(a+"_zero",d.i32_add(d.getLocal("itOut"),d.i32_const(l)))],[...d.call(a+"_mul",d.getLocal("itAux"),d.i32_add(d.getLocal("itIn"),d.i32_const(l)),S),...d.call(a+"_square",d.getLocal("itAux"),d.getLocal("itAux")),...d.call(a+"_mul",d.getLocal("itAux"),d.getLocal("itIn"),d.getLocal("itOut")),...d.call(a+"_mul",d.getLocal("itAux"),S,d.i32_add(d.getLocal("itOut"),d.i32_const(l)))]),d.setLocal("itIn",d.i32_add(d.getLocal("itIn"),d.i32_const(l*3))),d.setLocal("itOut",d.i32_add(d.getLocal("itOut"),d.i32_const(l*2))),d.setLocal("itAux",d.i32_add(d.getLocal("itAux"),d.i32_const(l))),d.setLocal("i",d.i32_add(d.getLocal("i"),d.i32_const(1))),d.br(0))),d.i32_store(d.i32_const(0),d.getLocal("pAux")))}function V(){const I=t.addFunction(n+"__reverseBytes");I.addParam("pIn","i32"),I.addParam("n","i32"),I.addParam("pOut","i32"),I.addLocal("itOut","i32"),I.addLocal("itIn","i32");const d=I.getCodeBuilder();I.addCode(d.setLocal("itOut",d.i32_sub(d.i32_add(d.getLocal("pOut"),d.getLocal("n")),d.i32_const(1))),d.setLocal("itIn",d.getLocal("pIn")),d.block(d.loop(d.br_if(1,d.i32_lt_s(d.getLocal("itOut"),d.getLocal("pOut"))),d.i32_store8(d.getLocal("itOut"),d.i32_load8_u(d.getLocal("itIn"))),d.setLocal("itOut",d.i32_sub(d.getLocal("itOut"),d.i32_const(1))),d.setLocal("itIn",d.i32_add(d.getLocal("itIn"),d.i32_const(1))),d.br(0))))}function nt(){const I=t.addFunction(n+"_LEMtoC");I.addParam("pIn","i32"),I.addParam("pOut","i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l));I.addCode(d.if(d.call(n+"_isZeroAffine",d.getLocal("pIn")),[...d.call(a+"_zero",d.getLocal("pOut")),...d.i32_store8(d.getLocal("pOut"),d.i32_const(64)),...d.ret([])]),d.call(a+"_fromMontgomery",d.getLocal("pIn"),S),d.call(n+"__reverseBytes",S,d.i32_const(l),d.getLocal("pOut")),d.if(d.i32_eq(d.call(a+"_sign",d.i32_add(d.getLocal("pIn"),d.i32_const(l))),d.i32_const(-1)),d.i32_store8(d.getLocal("pOut"),d.i32_or(d.i32_load8_u(d.getLocal("pOut")),d.i32_const(128)))))}function R(){const I=t.addFunction(n+"_LEMtoU");I.addParam("pIn","i32"),I.addParam("pOut","i32");const d=I.getCodeBuilder(),S=t.alloc(l*2),h=d.i32_const(S),U=d.i32_const(S),G=d.i32_const(S+l);I.addCode(d.if(d.call(n+"_isZeroAffine",d.getLocal("pIn")),[...d.call(n+"_zeroAffine",d.getLocal("pOut")),...d.ret([])]),d.call(n+"_fromMontgomeryAffine",d.getLocal("pIn"),h),d.call(n+"__reverseBytes",U,d.i32_const(l),d.getLocal("pOut")),d.call(n+"__reverseBytes",G,d.i32_const(l),d.i32_add(d.getLocal("pOut"),d.i32_const(l))))}function at(){const I=t.addFunction(n+"_UtoLEM");I.addParam("pIn","i32"),I.addParam("pOut","i32");const d=I.getCodeBuilder(),S=t.alloc(l*2),h=d.i32_const(S),U=d.i32_const(S),G=d.i32_const(S+l);I.addCode(d.if(d.i32_and(d.i32_load8_u(d.getLocal("pIn")),d.i32_const(64)),[...d.call(n+"_zeroAffine",d.getLocal("pOut")),...d.ret([])]),d.call(n+"__reverseBytes",d.getLocal("pIn"),d.i32_const(l),U),d.call(n+"__reverseBytes",d.i32_add(d.getLocal("pIn"),d.i32_const(l)),d.i32_const(l),G),d.call(n+"_toMontgomeryAffine",h,d.getLocal("pOut")))}function J(){const I=t.addFunction(n+"_CtoLEM");I.addParam("pIn","i32"),I.addParam("pOut","i32"),I.addLocal("firstByte","i32"),I.addLocal("greatest","i32");const d=I.getCodeBuilder(),S=t.alloc(l*2),h=d.i32_const(S),U=d.i32_const(S+l);I.addCode(d.setLocal("firstByte",d.i32_load8_u(d.getLocal("pIn"))),d.if(d.i32_and(d.getLocal("firstByte"),d.i32_const(64)),[...d.call(n+"_zeroAffine",d.getLocal("pOut")),...d.ret([])]),d.setLocal("greatest",d.i32_and(d.getLocal("firstByte"),d.i32_const(128))),d.call(a+"_copy",d.getLocal("pIn"),U),d.i32_store8(U,d.i32_and(d.getLocal("firstByte"),d.i32_const(63))),d.call(n+"__reverseBytes",U,d.i32_const(l),h),d.call(a+"_toMontgomery",h,d.getLocal("pOut")),d.call(a+"_square",d.getLocal("pOut"),U),d.call(a+"_mul",d.getLocal("pOut"),U,U),d.call(a+"_add",U,d.i32_const(i),U),d.call(a+"_sqrt",U,U),d.call(a+"_neg",U,h),d.if(d.i32_eq(d.call(a+"_sign",U),d.i32_const(-1)),d.if(d.getLocal("greatest"),d.call(a+"_copy",U,d.i32_add(d.getLocal("pOut"),d.i32_const(l))),d.call(a+"_neg",U,d.i32_add(d.getLocal("pOut"),d.i32_const(l)))),d.if(d.getLocal("greatest"),d.call(a+"_neg",U,d.i32_add(d.getLocal("pOut"),d.i32_const(l))),d.call(a+"_copy",U,d.i32_add(d.getLocal("pOut"),d.i32_const(l))))))}function k(){const I=t.addFunction(n+"_inCurveAffine");I.addParam("pIn","i32"),I.setReturnType("i32");const d=I.getCodeBuilder(),S=d.getLocal("pIn"),h=d.i32_add(d.getLocal("pIn"),d.i32_const(l)),U=d.i32_const(t.alloc(l)),G=d.i32_const(t.alloc(l));I.addCode(d.call(a+"_square",h,U),d.call(a+"_square",S,G),d.call(a+"_mul",S,G,G),d.call(a+"_add",G,d.i32_const(i),G),d.ret(d.call(a+"_eq",U,G)))}function K(){const I=t.addFunction(n+"_inCurve");I.addParam("pIn","i32"),I.setReturnType("i32");const d=I.getCodeBuilder(),S=d.i32_const(t.alloc(l*2));I.addCode(d.call(n+"_toAffine",d.getLocal("pIn"),S),d.ret(d.call(n+"_inCurveAffine",S)))}return f(),s(),b(),u(),c(),r(),Q(),F(),A(),w(),v(),x(),g(),_(),C(),Z(),$(),E(),O(),j(),T(),P(),B(),y(),M(),k(),K(),D(),q(),V(),R(),nt(),at(),J(),ha(t,n+"_batchLEMtoU",n+"_LEMtoU",l*2,l*2),ha(t,n+"_batchLEMtoC",n+"_LEMtoC",l*2,l),ha(t,n+"_batchUtoLEM",n+"_UtoLEM",l*2,l*2),ha(t,n+"_batchCtoLEM",n+"_CtoLEM",l,l*2,!0),ha(t,n+"_batchToJacobian",n+"_toJacobian",l*2,l*3,!0),Te(t,n,n+"_multiexp",n+"_add",l*3),Te(t,n,n+"_multiexpAffine",n+"_addMixed",l*2),Ge(t,n+"_timesScalar",l*3,n+"_add",n+"_double",n+"_sub",n+"_copy",n+"_zero"),Ge(t,n+"_timesScalarAffine",l*2,n+"_addMixed",n+"_double",n+"_subMixed",n+"_copyAffine",n+"_zero"),t.exportFunction(n+"_isZero"),t.exportFunction(n+"_isZeroAffine"),t.exportFunction(n+"_eq"),t.exportFunction(n+"_eqMixed"),t.exportFunction(n+"_eqAffine"),t.exportFunction(n+"_copy"),t.exportFunction(n+"_copyAffine"),t.exportFunction(n+"_zero"),t.exportFunction(n+"_zeroAffine"),t.exportFunction(n+"_double"),t.exportFunction(n+"_doubleAffine"),t.exportFunction(n+"_add"),t.exportFunction(n+"_addMixed"),t.exportFunction(n+"_addAffine"),t.exportFunction(n+"_neg"),t.exportFunction(n+"_negAffine"),t.exportFunction(n+"_sub"),t.exportFunction(n+"_subMixed"),t.exportFunction(n+"_subAffine"),t.exportFunction(n+"_fromMontgomery"),t.exportFunction(n+"_fromMontgomeryAffine"),t.exportFunction(n+"_toMontgomery"),t.exportFunction(n+"_toMontgomeryAffine"),t.exportFunction(n+"_timesScalar"),t.exportFunction(n+"_timesScalarAffine"),t.exportFunction(n+"_normalize"),t.exportFunction(n+"_LEMtoU"),t.exportFunction(n+"_LEMtoC"),t.exportFunction(n+"_UtoLEM"),t.exportFunction(n+"_CtoLEM"),t.exportFunction(n+"_batchLEMtoU"),t.exportFunction(n+"_batchLEMtoC"),t.exportFunction(n+"_batchUtoLEM"),t.exportFunction(n+"_batchCtoLEM"),t.exportFunction(n+"_toAffine"),t.exportFunction(n+"_toJacobian"),t.exportFunction(n+"_batchToAffine"),t.exportFunction(n+"_batchToJacobian"),t.exportFunction(n+"_inCurve"),t.exportFunction(n+"_inCurveAffine"),n};const{isOdd:Rc,modInv:Oe,modPow:pa}=fn,Na=$n;var qo=function(t,n,a,i,o){const s=t.modules[i].n64*8,r=t.modules[a].n64*8,c=t.modules[i].q;let u=c-1n,b=0;for(;!Rc(u);)b++,u=u>>1n;let w=2n;for(;pa(w,c>>1n,c)===1n;)w=w+1n;const A=new Array(b+1);A[b]=pa(w,u,c);let x=b-1;for(;x>=0;)A[x]=pa(A[x+1],2n,c),x--;const v=[],F=(1n<<BigInt(s*8))%c;for(let S=0;S<A.length;S++){const h=A[S]*F%c;v.push(...Na.bigInt2BytesLE(h,s))}const y=t.alloc(v),B=new Array(b+1);B[0]=1n;for(let S=1;S<=b;S++)B[S]=B[S-1]*2n;const P=[];for(let S=0;S<=b;S++){const h=Oe(B[S],c)*F%c;P.push(...Na.bigInt2BytesLE(h,s))}const T=t.alloc(P),C=pa(w,2n,c),_=[],g=[];for(let S=0;S<=b;S++){const h=pa(C,2n**BigInt(S),c),U=Oe(c+1n-h,c);_.push(...Na.bigInt2BytesLE(h*F%c,s)),g.push(...Na.bigInt2BytesLE(U*F%c,s))}const $=t.alloc(_),Z=t.alloc(g);function j(S){let h=0;for(let U=0;U<8;U++)S&1<<U&&(h=h|128>>U);return h}const O=Array(256);for(let S=0;S<256;S++)O[S]=j(S);const E=t.alloc(O);function q(){const S=t.addFunction(n+"__log2");S.addParam("n","i32"),S.setReturnType("i32"),S.addLocal("bits","i32"),S.addLocal("aux","i32");const h=S.getCodeBuilder();S.addCode(h.setLocal("aux",h.i32_shr_u(h.getLocal("n"),h.i32_const(1)))),S.addCode(h.setLocal("bits",h.i32_const(0))),S.addCode(h.block(h.loop(h.br_if(1,h.i32_eqz(h.getLocal("aux"))),h.setLocal("aux",h.i32_shr_u(h.getLocal("aux"),h.i32_const(1))),h.setLocal("bits",h.i32_add(h.getLocal("bits"),h.i32_const(1))),h.br(0)))),S.addCode(h.if(h.i32_ne(h.getLocal("n"),h.i32_shl(h.i32_const(1),h.getLocal("bits"))),h.unreachable())),S.addCode(h.if(h.i32_gt_u(h.getLocal("bits"),h.i32_const(b)),h.unreachable())),S.addCode(h.getLocal("bits"))}function M(){const S=t.addFunction(n+"_fft");S.addParam("px","i32"),S.addParam("n","i32"),S.addLocal("bits","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s));S.addCode(h.setLocal("bits",h.call(n+"__log2",h.getLocal("n"))),h.call(i+"_one",U),h.call(n+"_rawfft",h.getLocal("px"),h.getLocal("bits"),h.i32_const(0),U))}function Q(){const S=t.addFunction(n+"_ifft");S.addParam("px","i32"),S.addParam("n","i32"),S.addLocal("bits","i32"),S.addLocal("pInv2","i32");const h=S.getCodeBuilder();S.addCode(h.setLocal("bits",h.call(n+"__log2",h.getLocal("n"))),h.setLocal("pInv2",h.i32_add(h.i32_const(T),h.i32_mul(h.getLocal("bits"),h.i32_const(s)))),h.call(n+"_rawfft",h.getLocal("px"),h.getLocal("bits"),h.i32_const(1),h.getLocal("pInv2")))}function D(){const S=t.addFunction(n+"_rawfft");S.addParam("px","i32"),S.addParam("bits","i32"),S.addParam("reverse","i32"),S.addParam("mulFactor","i32"),S.addLocal("s","i32"),S.addLocal("k","i32"),S.addLocal("j","i32"),S.addLocal("m","i32"),S.addLocal("mdiv2","i32"),S.addLocal("n","i32"),S.addLocal("pwm","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r)),m=h.i32_const(t.alloc(r));S.addCode(h.call(n+"__reversePermutation",h.getLocal("px"),h.getLocal("bits")),h.setLocal("n",h.i32_shl(h.i32_const(1),h.getLocal("bits"))),h.setLocal("s",h.i32_const(1)),h.block(h.loop(h.br_if(1,h.i32_gt_u(h.getLocal("s"),h.getLocal("bits"))),h.setLocal("m",h.i32_shl(h.i32_const(1),h.getLocal("s"))),h.setLocal("pwm",h.i32_add(h.i32_const(y),h.i32_mul(h.getLocal("s"),h.i32_const(s)))),h.setLocal("k",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_ge_u(h.getLocal("k"),h.getLocal("n"))),h.call(i+"_one",U),h.setLocal("mdiv2",h.i32_shr_u(h.getLocal("m"),h.i32_const(1))),h.setLocal("j",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_ge_u(h.getLocal("j"),h.getLocal("mdiv2"))),h.setLocal("idx1",h.i32_add(h.getLocal("px"),h.i32_mul(h.i32_add(h.getLocal("k"),h.getLocal("j")),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("idx1"),h.i32_mul(h.getLocal("mdiv2"),h.i32_const(r)))),h.call(o,h.getLocal("idx2"),U,G),h.call(a+"_copy",h.getLocal("idx1"),m),h.call(a+"_add",m,G,h.getLocal("idx1")),h.call(a+"_sub",m,G,h.getLocal("idx2")),h.call(i+"_mul",U,h.getLocal("pwm"),U),h.setLocal("j",h.i32_add(h.getLocal("j"),h.i32_const(1))),h.br(0))),h.setLocal("k",h.i32_add(h.getLocal("k"),h.getLocal("m"))),h.br(0))),h.setLocal("s",h.i32_add(h.getLocal("s"),h.i32_const(1))),h.br(0))),h.call(n+"__fftFinal",h.getLocal("px"),h.getLocal("bits"),h.getLocal("reverse"),h.getLocal("mulFactor")))}function V(){const S=t.addFunction(n+"__fftFinal");S.addParam("px","i32"),S.addParam("bits","i32"),S.addParam("reverse","i32"),S.addParam("mulFactor","i32"),S.addLocal("n","i32"),S.addLocal("ndiv2","i32"),S.addLocal("pInv2","i32"),S.addLocal("i","i32"),S.addLocal("mask","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(r));S.addCode(h.if(h.i32_and(h.i32_eqz(h.getLocal("reverse")),h.call(i+"_isOne",h.getLocal("mulFactor"))),h.ret([])),h.setLocal("n",h.i32_shl(h.i32_const(1),h.getLocal("bits"))),h.setLocal("mask",h.i32_sub(h.getLocal("n"),h.i32_const(1))),h.setLocal("i",h.i32_const(1)),h.setLocal("ndiv2",h.i32_shr_u(h.getLocal("n"),h.i32_const(1))),h.block(h.loop(h.br_if(1,h.i32_ge_u(h.getLocal("i"),h.getLocal("ndiv2"))),h.setLocal("idx1",h.i32_add(h.getLocal("px"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("px"),h.i32_mul(h.i32_sub(h.getLocal("n"),h.getLocal("i")),h.i32_const(r)))),h.if(h.getLocal("reverse"),h.if(h.call(i+"_isOne",h.getLocal("mulFactor")),[...h.call(a+"_copy",h.getLocal("idx1"),U),...h.call(a+"_copy",h.getLocal("idx2"),h.getLocal("idx1")),...h.call(a+"_copy",U,h.getLocal("idx2"))],[...h.call(a+"_copy",h.getLocal("idx1"),U),...h.call(o,h.getLocal("idx2"),h.getLocal("mulFactor"),h.getLocal("idx1")),...h.call(o,U,h.getLocal("mulFactor"),h.getLocal("idx2"))]),h.if(h.call(i+"_isOne",h.getLocal("mulFactor")),[],[...h.call(o,h.getLocal("idx1"),h.getLocal("mulFactor"),h.getLocal("idx1")),...h.call(o,h.getLocal("idx2"),h.getLocal("mulFactor"),h.getLocal("idx2"))])),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))),h.if(h.call(i+"_isOne",h.getLocal("mulFactor")),[],[...h.call(o,h.getLocal("px"),h.getLocal("mulFactor"),h.getLocal("px")),...h.setLocal("idx2",h.i32_add(h.getLocal("px"),h.i32_mul(h.getLocal("ndiv2"),h.i32_const(r)))),...h.call(o,h.getLocal("idx2"),h.getLocal("mulFactor"),h.getLocal("idx2"))]))}function nt(){const S=t.addFunction(n+"__reversePermutation");S.addParam("px","i32"),S.addParam("bits","i32"),S.addLocal("n","i32"),S.addLocal("i","i32"),S.addLocal("ri","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(r));S.addCode(h.setLocal("n",h.i32_shl(h.i32_const(1),h.getLocal("bits"))),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("n"))),h.setLocal("idx1",h.i32_add(h.getLocal("px"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("ri",h.call(n+"__rev",h.getLocal("i"),h.getLocal("bits"))),h.setLocal("idx2",h.i32_add(h.getLocal("px"),h.i32_mul(h.getLocal("ri"),h.i32_const(r)))),h.if(h.i32_lt_u(h.getLocal("i"),h.getLocal("ri")),[...h.call(a+"_copy",h.getLocal("idx1"),U),...h.call(a+"_copy",h.getLocal("idx2"),h.getLocal("idx1")),...h.call(a+"_copy",U,h.getLocal("idx2"))]),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function R(){const S=t.addFunction(n+"__rev");S.addParam("x","i32"),S.addParam("bits","i32"),S.setReturnType("i32");const h=S.getCodeBuilder();S.addCode(h.i32_rotl(h.i32_add(h.i32_add(h.i32_shl(h.i32_load8_u(h.i32_and(h.getLocal("x"),h.i32_const(255)),E,0),h.i32_const(24)),h.i32_shl(h.i32_load8_u(h.i32_and(h.i32_shr_u(h.getLocal("x"),h.i32_const(8)),h.i32_const(255)),E,0),h.i32_const(16))),h.i32_add(h.i32_shl(h.i32_load8_u(h.i32_and(h.i32_shr_u(h.getLocal("x"),h.i32_const(16)),h.i32_const(255)),E,0),h.i32_const(8)),h.i32_load8_u(h.i32_and(h.i32_shr_u(h.getLocal("x"),h.i32_const(24)),h.i32_const(255)),E,0))),h.getLocal("bits")))}function at(){const S=t.addFunction(n+"_fftJoin");S.addParam("pBuff1","i32"),S.addParam("pBuff2","i32"),S.addParam("n","i32"),S.addParam("first","i32"),S.addParam("inc","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r)),m=h.i32_const(t.alloc(r));S.addCode(h.call(i+"_copy",h.getLocal("first"),U),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("n"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff1"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("pBuff2"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.call(o,h.getLocal("idx2"),U,G),h.call(a+"_copy",h.getLocal("idx1"),m),h.call(a+"_add",m,G,h.getLocal("idx1")),h.call(a+"_sub",m,G,h.getLocal("idx2")),h.call(i+"_mul",U,h.getLocal("inc"),U),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function J(){const S=t.addFunction(n+"_fftJoinExt");S.addParam("pBuff1","i32"),S.addParam("pBuff2","i32"),S.addParam("n","i32"),S.addParam("first","i32"),S.addParam("inc","i32"),S.addParam("totalBits","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32"),S.addLocal("pShiftToM","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r));S.addCode(h.setLocal("pShiftToM",h.i32_add(h.i32_const($),h.i32_mul(h.getLocal("totalBits"),h.i32_const(s)))),h.call(i+"_copy",h.getLocal("first"),U),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("n"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff1"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("pBuff2"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.call(a+"_add",h.getLocal("idx1"),h.getLocal("idx2"),G),h.call(o,h.getLocal("idx2"),h.getLocal("pShiftToM"),h.getLocal("idx2")),h.call(a+"_add",h.getLocal("idx1"),h.getLocal("idx2"),h.getLocal("idx2")),h.call(o,h.getLocal("idx2"),U,h.getLocal("idx2")),h.call(a+"_copy",G,h.getLocal("idx1")),h.call(i+"_mul",U,h.getLocal("inc"),U),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function k(){const S=t.addFunction(n+"_fftJoinExtInv");S.addParam("pBuff1","i32"),S.addParam("pBuff2","i32"),S.addParam("n","i32"),S.addParam("first","i32"),S.addParam("inc","i32"),S.addParam("totalBits","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32"),S.addLocal("pShiftToM","i32"),S.addLocal("pSConst","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r));S.addCode(h.setLocal("pShiftToM",h.i32_add(h.i32_const($),h.i32_mul(h.getLocal("totalBits"),h.i32_const(s)))),h.setLocal("pSConst",h.i32_add(h.i32_const(Z),h.i32_mul(h.getLocal("totalBits"),h.i32_const(s)))),h.call(i+"_copy",h.getLocal("first"),U),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("n"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff1"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("pBuff2"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.call(o,h.getLocal("idx2"),U,G),h.call(a+"_sub",h.getLocal("idx1"),G,h.getLocal("idx2")),h.call(o,h.getLocal("idx2"),h.getLocal("pSConst"),h.getLocal("idx2")),h.call(o,h.getLocal("idx1"),h.getLocal("pShiftToM"),h.getLocal("idx1")),h.call(a+"_sub",G,h.getLocal("idx1"),h.getLocal("idx1")),h.call(o,h.getLocal("idx1"),h.getLocal("pSConst"),h.getLocal("idx1")),h.call(i+"_mul",U,h.getLocal("inc"),U),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function K(){const S=t.addFunction(n+"_prepareLagrangeEvaluation");S.addParam("pBuff1","i32"),S.addParam("pBuff2","i32"),S.addParam("n","i32"),S.addParam("first","i32"),S.addParam("inc","i32"),S.addParam("totalBits","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32"),S.addLocal("pShiftToM","i32"),S.addLocal("pSConst","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r));S.addCode(h.setLocal("pShiftToM",h.i32_add(h.i32_const($),h.i32_mul(h.getLocal("totalBits"),h.i32_const(s)))),h.setLocal("pSConst",h.i32_add(h.i32_const(Z),h.i32_mul(h.getLocal("totalBits"),h.i32_const(s)))),h.call(i+"_copy",h.getLocal("first"),U),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("n"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff1"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("pBuff2"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.call(o,h.getLocal("idx1"),h.getLocal("pShiftToM"),G),h.call(a+"_sub",h.getLocal("idx2"),G,G),h.call(a+"_sub",h.getLocal("idx1"),h.getLocal("idx2"),h.getLocal("idx2")),h.call(o,G,h.getLocal("pSConst"),h.getLocal("idx1")),h.call(o,h.getLocal("idx2"),U,h.getLocal("idx2")),h.call(i+"_mul",U,h.getLocal("inc"),U),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function I(){const S=t.addFunction(n+"_fftMix");S.addParam("pBuff","i32"),S.addParam("n","i32"),S.addParam("exp","i32"),S.addLocal("nGroups","i32"),S.addLocal("nPerGroup","i32"),S.addLocal("nPerGroupDiv2","i32"),S.addLocal("pairOffset","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32"),S.addLocal("j","i32"),S.addLocal("pwm","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(s)),G=h.i32_const(t.alloc(r)),m=h.i32_const(t.alloc(r));S.addCode(h.setLocal("nPerGroup",h.i32_shl(h.i32_const(1),h.getLocal("exp"))),h.setLocal("nPerGroupDiv2",h.i32_shr_u(h.getLocal("nPerGroup"),h.i32_const(1))),h.setLocal("nGroups",h.i32_shr_u(h.getLocal("n"),h.getLocal("exp"))),h.setLocal("pairOffset",h.i32_mul(h.getLocal("nPerGroupDiv2"),h.i32_const(r))),h.setLocal("pwm",h.i32_add(h.i32_const(y),h.i32_mul(h.getLocal("exp"),h.i32_const(s)))),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("i"),h.getLocal("nGroups"))),h.call(i+"_one",U),h.setLocal("j",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_eq(h.getLocal("j"),h.getLocal("nPerGroupDiv2"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff"),h.i32_mul(h.i32_add(h.i32_mul(h.getLocal("i"),h.getLocal("nPerGroup")),h.getLocal("j")),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("idx1"),h.getLocal("pairOffset"))),h.call(o,h.getLocal("idx2"),U,G),h.call(a+"_copy",h.getLocal("idx1"),m),h.call(a+"_add",m,G,h.getLocal("idx1")),h.call(a+"_sub",m,G,h.getLocal("idx2")),h.call(i+"_mul",U,h.getLocal("pwm"),U),h.setLocal("j",h.i32_add(h.getLocal("j"),h.i32_const(1))),h.br(0))),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}function d(){const S=t.addFunction(n+"_fftFinal");S.addParam("pBuff","i32"),S.addParam("n","i32"),S.addParam("factor","i32"),S.addLocal("idx1","i32"),S.addLocal("idx2","i32"),S.addLocal("i","i32"),S.addLocal("ndiv2","i32");const h=S.getCodeBuilder(),U=h.i32_const(t.alloc(r));S.addCode(h.setLocal("ndiv2",h.i32_shr_u(h.getLocal("n"),h.i32_const(1))),h.if(h.i32_and(h.getLocal("n"),h.i32_const(1)),h.call(o,h.i32_add(h.getLocal("pBuff"),h.i32_mul(h.getLocal("ndiv2"),h.i32_const(r))),h.getLocal("factor"),h.i32_add(h.getLocal("pBuff"),h.i32_mul(h.getLocal("ndiv2"),h.i32_const(r))))),h.setLocal("i",h.i32_const(0)),h.block(h.loop(h.br_if(1,h.i32_ge_u(h.getLocal("i"),h.getLocal("ndiv2"))),h.setLocal("idx1",h.i32_add(h.getLocal("pBuff"),h.i32_mul(h.getLocal("i"),h.i32_const(r)))),h.setLocal("idx2",h.i32_add(h.getLocal("pBuff"),h.i32_mul(h.i32_sub(h.i32_sub(h.getLocal("n"),h.i32_const(1)),h.getLocal("i")),h.i32_const(r)))),h.call(o,h.getLocal("idx2"),h.getLocal("factor"),U),h.call(o,h.getLocal("idx1"),h.getLocal("factor"),h.getLocal("idx2")),h.call(a+"_copy",U,h.getLocal("idx1")),h.setLocal("i",h.i32_add(h.getLocal("i"),h.i32_const(1))),h.br(0))))}R(),nt(),V(),D(),q(),M(),Q(),at(),J(),k(),I(),d(),K(),t.exportFunction(n+"_fft"),t.exportFunction(n+"_ifft"),t.exportFunction(n+"_rawfft"),t.exportFunction(n+"_fftJoin"),t.exportFunction(n+"_fftJoinExt"),t.exportFunction(n+"_fftJoinExtInv"),t.exportFunction(n+"_fftMix"),t.exportFunction(n+"_fftFinal"),t.exportFunction(n+"_prepareLagrangeEvaluation")},Mo=function(t,n,a){const o=t.modules[a].n64*8;function l(){const f=t.addFunction(n+"_zero");f.addParam("px","i32"),f.addParam("n","i32"),f.addLocal("lastp","i32"),f.addLocal("p","i32");const r=f.getCodeBuilder();f.addCode(r.setLocal("p",r.getLocal("px")),r.setLocal("lastp",r.i32_add(r.getLocal("px"),r.i32_mul(r.getLocal("n"),r.i32_const(o)))),r.block(r.loop(r.br_if(1,r.i32_eq(r.getLocal("p"),r.getLocal("lastp"))),r.call(a+"_zero",r.getLocal("p")),r.setLocal("p",r.i32_add(r.getLocal("p"),r.i32_const(o))),r.br(0))))}function s(){const f=t.addFunction(n+"_constructLC");f.addParam("ppolynomials","i32"),f.addParam("psignals","i32"),f.addParam("nSignals","i32"),f.addParam("pres","i32"),f.addLocal("i","i32"),f.addLocal("j","i32"),f.addLocal("pp","i32"),f.addLocal("ps","i32"),f.addLocal("pd","i32"),f.addLocal("ncoefs","i32");const r=f.getCodeBuilder(),c=r.i32_const(t.alloc(o));f.addCode(r.setLocal("i",r.i32_const(0)),r.setLocal("pp",r.getLocal("ppolynomials")),r.setLocal("ps",r.getLocal("psignals")),r.block(r.loop(r.br_if(1,r.i32_eq(r.getLocal("i"),r.getLocal("nSignals"))),r.setLocal("ncoefs",r.i32_load(r.getLocal("pp"))),r.setLocal("pp",r.i32_add(r.getLocal("pp"),r.i32_const(4))),r.setLocal("j",r.i32_const(0)),r.block(r.loop(r.br_if(1,r.i32_eq(r.getLocal("j"),r.getLocal("ncoefs"))),r.setLocal("pd",r.i32_add(r.getLocal("pres"),r.i32_mul(r.i32_load(r.getLocal("pp")),r.i32_const(o)))),r.setLocal("pp",r.i32_add(r.getLocal("pp"),r.i32_const(4))),r.call(a+"_mul",r.getLocal("ps"),r.getLocal("pp"),c),r.call(a+"_add",c,r.getLocal("pd"),r.getLocal("pd")),r.setLocal("pp",r.i32_add(r.getLocal("pp"),r.i32_const(o))),r.setLocal("j",r.i32_add(r.getLocal("j"),r.i32_const(1))),r.br(0))),r.setLocal("ps",r.i32_add(r.getLocal("ps"),r.i32_const(o))),r.setLocal("i",r.i32_add(r.getLocal("i"),r.i32_const(1))),r.br(0))))}return l(),s(),t.exportFunction(n+"_zero"),t.exportFunction(n+"_constructLC"),n},Uo=function(t,n,a){const o=t.modules[a].n64*8;function l(){const r=t.addFunction(n+"_buildABC");r.addParam("pCoefs","i32"),r.addParam("nCoefs","i32"),r.addParam("pWitness","i32"),r.addParam("pA","i32"),r.addParam("pB","i32"),r.addParam("pC","i32"),r.addParam("offsetOut","i32"),r.addParam("nOut","i32"),r.addParam("offsetWitness","i32"),r.addParam("nWitness","i32"),r.addLocal("it","i32"),r.addLocal("ita","i32"),r.addLocal("itb","i32"),r.addLocal("last","i32"),r.addLocal("m","i32"),r.addLocal("c","i32"),r.addLocal("s","i32"),r.addLocal("pOut","i32");const c=r.getCodeBuilder(),u=c.i32_const(t.alloc(o));r.addCode(c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("nOut"),c.i32_const(o)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_zero",c.getLocal("ita")),c.call(a+"_zero",c.getLocal("itb")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(o))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(o))),c.br(0))),c.setLocal("it",c.getLocal("pCoefs")),c.setLocal("last",c.i32_add(c.getLocal("pCoefs"),c.i32_mul(c.getLocal("nCoefs"),c.i32_const(o+12)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("it"),c.getLocal("last"))),c.setLocal("s",c.i32_load(c.getLocal("it"),8)),c.if(c.i32_or(c.i32_lt_u(c.getLocal("s"),c.getLocal("offsetWitness")),c.i32_ge_u(c.getLocal("s"),c.i32_add(c.getLocal("offsetWitness"),c.getLocal("nWitness")))),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(o+12))),...c.br(1)]),c.setLocal("m",c.i32_load(c.getLocal("it"))),c.if(c.i32_eq(c.getLocal("m"),c.i32_const(0)),c.setLocal("pOut",c.getLocal("pA")),c.if(c.i32_eq(c.getLocal("m"),c.i32_const(1)),c.setLocal("pOut",c.getLocal("pB")),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(o+12))),...c.br(1)])),c.setLocal("c",c.i32_load(c.getLocal("it"),4)),c.if(c.i32_or(c.i32_lt_u(c.getLocal("c"),c.getLocal("offsetOut")),c.i32_ge_u(c.getLocal("c"),c.i32_add(c.getLocal("offsetOut"),c.getLocal("nOut")))),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(o+12))),...c.br(1)]),c.setLocal("pOut",c.i32_add(c.getLocal("pOut"),c.i32_mul(c.i32_sub(c.getLocal("c"),c.getLocal("offsetOut")),c.i32_const(o)))),c.call(a+"_mul",c.i32_add(c.getLocal("pWitness"),c.i32_mul(c.i32_sub(c.getLocal("s"),c.getLocal("offsetWitness")),c.i32_const(o))),c.i32_add(c.getLocal("it"),c.i32_const(12)),u),c.call(a+"_add",c.getLocal("pOut"),u,c.getLocal("pOut")),c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(o+12))),c.br(0))),c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("it",c.getLocal("pC")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("nOut"),c.i32_const(o)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_mul",c.getLocal("ita"),c.getLocal("itb"),c.getLocal("it")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(o))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(o))),c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(o))),c.br(0))))}function s(){const r=t.addFunction(n+"_joinABC");r.addParam("pA","i32"),r.addParam("pB","i32"),r.addParam("pC","i32"),r.addParam("n","i32"),r.addParam("pP","i32"),r.addLocal("ita","i32"),r.addLocal("itb","i32"),r.addLocal("itc","i32"),r.addLocal("itp","i32"),r.addLocal("last","i32");const c=r.getCodeBuilder(),u=c.i32_const(t.alloc(o));r.addCode(c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("itc",c.getLocal("pC")),c.setLocal("itp",c.getLocal("pP")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("n"),c.i32_const(o)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_mul",c.getLocal("ita"),c.getLocal("itb"),u),c.call(a+"_sub",u,c.getLocal("itc"),c.getLocal("itp")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(o))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(o))),c.setLocal("itc",c.i32_add(c.getLocal("itc"),c.i32_const(o))),c.setLocal("itp",c.i32_add(c.getLocal("itp"),c.i32_const(o))),c.br(0))))}function f(){const r=t.addFunction(n+"_batchAdd");r.addParam("pa","i32"),r.addParam("pb","i32"),r.addParam("n","i32"),r.addParam("pr","i32"),r.addLocal("ita","i32"),r.addLocal("itb","i32"),r.addLocal("itr","i32"),r.addLocal("last","i32");const c=r.getCodeBuilder();r.addCode(c.setLocal("ita",c.getLocal("pa")),c.setLocal("itb",c.getLocal("pb")),c.setLocal("itr",c.getLocal("pr")),c.setLocal("last",c.i32_add(c.getLocal("pa"),c.i32_mul(c.getLocal("n"),c.i32_const(o)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_add",c.getLocal("ita"),c.getLocal("itb"),c.getLocal("itr")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(o))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(o))),c.setLocal("itr",c.i32_add(c.getLocal("itr"),c.i32_const(o))),c.br(0))))}return l(),s(),f(),t.exportFunction(n+"_buildABC"),t.exportFunction(n+"_joinABC"),t.exportFunction(n+"_batchAdd"),n},Ro=function(t,n,a,i,o,l,s,f){const r=t.addFunction(n);r.addParam("pIn","i32"),r.addParam("n","i32"),r.addParam("pFirst","i32"),r.addParam("pInc","i32"),r.addParam("pOut","i32"),r.addLocal("pOldFree","i32"),r.addLocal("i","i32"),r.addLocal("pFrom","i32"),r.addLocal("pTo","i32");const c=r.getCodeBuilder(),u=c.i32_const(t.alloc(s));r.addCode(c.setLocal("pFrom",c.getLocal("pIn")),c.setLocal("pTo",c.getLocal("pOut"))),r.addCode(c.call(i+"_copy",c.getLocal("pFirst"),u)),r.addCode(c.setLocal("i",c.i32_const(0)),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("i"),c.getLocal("n"))),c.call(f,c.getLocal("pFrom"),u,c.getLocal("pTo")),c.setLocal("pFrom",c.i32_add(c.getLocal("pFrom"),c.i32_const(o))),c.setLocal("pTo",c.i32_add(c.getLocal("pTo"),c.i32_const(l))),c.call(i+"_mul",u,c.getLocal("pInc"),u),c.setLocal("i",c.i32_add(c.getLocal("i"),c.i32_const(1))),c.br(0)))),t.exportFunction(n)};const qt=$n,kc=fe,$c=Go,ze=To,Nc=Oo,qe=zo,Li=qo,Vc=Mo,Zc=Uo,wa=Ro,{bitLength:jc,modInv:Hc,isOdd:Me,isNegative:Wc}=fn;var Qc=function(t,n){const a=n||"bn128";if(t.modules[a])return a;const i=21888242871839275222246405745257275088696311157297823662689037894645226208583n,o=21888242871839275222246405745257275088548364400416034343698204186575808495617n,l=Math.floor((jc(i-1n)-1)/64)+1,s=l*8,f=s,r=s,c=r*2,u=r*12,b=t.alloc(qt.bigInt2BytesLE(o,f)),w=kc(t,i,"f1m");$c(t,o,"fr","frm");const A=t.alloc(qt.bigInt2BytesLE(P(3n),r)),x=qe(t,"g1m","f1m",A);Li(t,"frm","frm","frm","frm_mul"),Vc(t,"pol","frm"),Zc(t,"qap","frm");const v=ze(t,"f1m_neg","f2m","f1m"),F=t.alloc([...qt.bigInt2BytesLE(P(19485874751759354771024239261021720505790618469301721065564631296452457478373n),r),...qt.bigInt2BytesLE(P(266929791119991161246907387137283842545076965332900288569378510910307636690n),r)]),y=qe(t,"g2m","f2m",F);function B(ot,p){const L=t.addFunction(ot);L.addParam("pG","i32"),L.addParam("pFr","i32"),L.addParam("pr","i32");const H=L.getCodeBuilder(),tt=H.i32_const(t.alloc(s));L.addCode(H.call("frm_fromMontgomery",H.getLocal("pFr"),tt),H.call(p,H.getLocal("pG"),tt,H.i32_const(s),H.getLocal("pr"))),t.exportFunction(ot)}B("g1m_timesFr","g1m_timesScalar"),Li(t,"g1m","g1m","frm","g1m_timesFr"),B("g2m_timesFr","g2m_timesScalar"),Li(t,"g2m","g2m","frm","g2m_timesFr"),B("g1m_timesFrAffine","g1m_timesScalarAffine"),B("g2m_timesFrAffine","g2m_timesScalarAffine"),wa(t,"frm_batchApplyKey","fmr","frm",s,s,s,"frm_mul"),wa(t,"g1m_batchApplyKey","g1m","frm",s*3,s*3,s,"g1m_timesFr"),wa(t,"g1m_batchApplyKeyMixed","g1m","frm",s*2,s*3,s,"g1m_timesFrAffine"),wa(t,"g2m_batchApplyKey","g2m","frm",s*2*3,s*3*2,s,"g2m_timesFr"),wa(t,"g2m_batchApplyKeyMixed","g2m","frm",s*2*2,s*3*2,s,"g2m_timesFrAffine");function P(ot){return BigInt(ot)*(1n<<BigInt(r*8))%i}const T=[1n,2n,1n],C=t.alloc([...qt.bigInt2BytesLE(P(T[0]),r),...qt.bigInt2BytesLE(P(T[1]),r),...qt.bigInt2BytesLE(P(T[2]),r)]),_=[0n,1n,0n],g=t.alloc([...qt.bigInt2BytesLE(P(_[0]),r),...qt.bigInt2BytesLE(P(_[1]),r),...qt.bigInt2BytesLE(P(_[2]),r)]),$=[[10857046999023057135944570762232829481370756359578518086990519993285655852781n,11559732032986387107991004021392285783925812861821192530917403151452391805634n],[8495653923123431417604973247489272438418190587263600148770280649306958101930n,4082367875863433681332203403145435568316851327593401208105741076214120093531n],[1n,0n]],Z=t.alloc([...qt.bigInt2BytesLE(P($[0][0]),r),...qt.bigInt2BytesLE(P($[0][1]),r),...qt.bigInt2BytesLE(P($[1][0]),r),...qt.bigInt2BytesLE(P($[1][1]),r),...qt.bigInt2BytesLE(P($[2][0]),r),...qt.bigInt2BytesLE(P($[2][1]),r)]),j=[[0n,0n],[1n,0n],[0n,0n]],O=t.alloc([...qt.bigInt2BytesLE(P(j[0][0]),r),...qt.bigInt2BytesLE(P(j[0][1]),r),...qt.bigInt2BytesLE(P(j[1][0]),r),...qt.bigInt2BytesLE(P(j[1][1]),r),...qt.bigInt2BytesLE(P(j[2][0]),r),...qt.bigInt2BytesLE(P(j[2][1]),r)]),E=t.alloc([...qt.bigInt2BytesLE(P(1),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r),...qt.bigInt2BytesLE(P(0),r)]),q=t.alloc([...qt.bigInt2BytesLE(P(9),r),...qt.bigInt2BytesLE(P(1),r)]),M=t.alloc([...qt.bigInt2BytesLE(P(Hc(2n,i)),r),...qt.bigInt2BytesLE(0n,r)]),Q=q,D=t.alloc([...qt.bigInt2BytesLE(P(19485874751759354771024239261021720505790618469301721065564631296452457478373n),r),...qt.bigInt2BytesLE(P(266929791119991161246907387137283842545076965332900288569378510910307636690n),r)]);function V(){const ot=t.addFunction(a+"_mulNR6");ot.addParam("x","i32"),ot.addParam("pr","i32");const p=ot.getCodeBuilder();ot.addCode(p.call(v+"_mul",p.i32_const(q),p.getLocal("x"),p.getLocal("pr")))}V();const nt=Nc(t,a+"_mulNR6","f6m","f2m");function R(){const ot=t.addFunction(a+"_mulNR12");ot.addParam("x","i32"),ot.addParam("pr","i32");const p=ot.getCodeBuilder();ot.addCode(p.call(v+"_mul",p.i32_const(q),p.i32_add(p.getLocal("x"),p.i32_const(s*4)),p.getLocal("pr")),p.call(v+"_copy",p.getLocal("x"),p.i32_add(p.getLocal("pr"),p.i32_const(s*2))),p.call(v+"_copy",p.i32_add(p.getLocal("x"),p.i32_const(s*2)),p.i32_add(p.getLocal("pr"),p.i32_const(s*4))))}R();const at=ze(t,a+"_mulNR12","ftm",nt),k=W(29793968203157093288n),K=t.alloc(k),I=3*c,d=k.length-1,h=k.reduce((ot,p)=>ot+(p!=0?1:0),0)+d+1,U=6*s,G=3*s*2+h*I;t.modules[a]={n64:l,pG1gen:C,pG1zero:g,pG1b:A,pG2gen:Z,pG2zero:O,pG2b:F,pq:t.modules.f1m.pq,pr:b,pOneT:E,prePSize:U,preQSize:G,r:o.toString(),q:i.toString()};const m=4965661367192848881n;function z(ot){let p=ot;const L=[];for(;p>0n;){if(Me(p)){const H=2-Number(p%4n);L.push(H),p=p-BigInt(H)}else L.push(0);p=p>>1n}return L}function W(ot){let p=ot;const L=[];for(;p>0n;)Me(p)?L.push(1):L.push(0),p=p>>1n;return L}function it(){const ot=t.addFunction(a+"_prepareG1");ot.addParam("pP","i32"),ot.addParam("ppreP","i32");const p=ot.getCodeBuilder();ot.addCode(p.call(x+"_normalize",p.getLocal("pP"),p.getLocal("ppreP")))}function X(){const ot=t.addFunction(a+"_prepAddStep");ot.addParam("pQ","i32"),ot.addParam("pR","i32"),ot.addParam("pCoef","i32");const p=ot.getCodeBuilder(),L=p.getLocal("pQ"),H=p.i32_add(p.getLocal("pQ"),p.i32_const(c)),tt=p.getLocal("pR"),N=p.i32_add(p.getLocal("pR"),p.i32_const(c)),et=p.i32_add(p.getLocal("pR"),p.i32_const(2*c)),Y=p.getLocal("pCoef"),rt=p.i32_add(p.getLocal("pCoef"),p.i32_const(c)),ht=p.i32_add(p.getLocal("pCoef"),p.i32_const(2*c)),pt=rt,dt=p.i32_const(t.alloc(c)),Lt=p.i32_const(t.alloc(c)),Et=p.i32_const(t.alloc(c)),vt=p.i32_const(t.alloc(c)),mt=p.i32_const(t.alloc(c)),Bt=p.i32_const(t.alloc(c)),It=p.i32_const(t.alloc(c));ot.addCode(p.call(v+"_mul",L,et,pt),p.call(v+"_sub",tt,pt,pt),p.call(v+"_mul",H,et,dt),p.call(v+"_sub",N,dt,dt),p.call(v+"_square",pt,Lt),p.call(v+"_square",dt,Et),p.call(v+"_mul",pt,Lt,vt),p.call(v+"_mul",tt,Lt,mt),p.call(v+"_add",mt,mt,It),p.call(v+"_mul",et,Et,Bt),p.call(v+"_add",vt,Bt,Bt),p.call(v+"_sub",Bt,It,Bt),p.call(v+"_mul",pt,Bt,tt),p.call(v+"_mul",vt,N,N),p.call(v+"_sub",mt,Bt,It),p.call(v+"_mul",dt,It,It),p.call(v+"_sub",It,N,N),p.call(v+"_mul",et,vt,et),p.call(v+"_mul",pt,H,It),p.call(v+"_mul",dt,L,Y),p.call(v+"_sub",Y,It,Y),p.call(v+"_mul",Y,p.i32_const(Q),Y),p.call(v+"_neg",dt,ht))}function lt(){const ot=t.addFunction(a+"_prepDblStep");ot.addParam("pR","i32"),ot.addParam("pCoef","i32");const p=ot.getCodeBuilder(),L=p.getLocal("pR"),H=p.i32_add(p.getLocal("pR"),p.i32_const(c)),tt=p.i32_add(p.getLocal("pR"),p.i32_const(2*c)),N=p.getLocal("pCoef"),et=p.i32_add(p.getLocal("pCoef"),p.i32_const(c)),Y=p.i32_add(p.getLocal("pCoef"),p.i32_const(2*c)),rt=p.i32_const(t.alloc(c)),ht=p.i32_const(t.alloc(c)),pt=p.i32_const(t.alloc(c)),dt=p.i32_const(t.alloc(c)),Lt=p.i32_const(t.alloc(c)),Et=p.i32_const(t.alloc(c)),vt=p.i32_const(t.alloc(c)),mt=p.i32_const(t.alloc(c)),Bt=p.i32_const(t.alloc(c)),It=p.i32_const(t.alloc(c)),$t=p.i32_const(t.alloc(c)),Gt=p.i32_const(t.alloc(c));ot.addCode(p.call(v+"_mul",H,p.i32_const(M),rt),p.call(v+"_mul",L,rt,rt),p.call(v+"_square",H,ht),p.call(v+"_square",tt,pt),p.call(v+"_add",pt,pt,dt),p.call(v+"_add",dt,pt,dt),p.call(v+"_mul",p.i32_const(D),dt,Lt),p.call(v+"_add",Lt,Lt,Et),p.call(v+"_add",Lt,Et,Et),p.call(v+"_add",ht,Et,vt),p.call(v+"_mul",vt,p.i32_const(M),vt),p.call(v+"_add",ht,pt,Gt),p.call(v+"_add",H,tt,mt),p.call(v+"_square",mt,mt),p.call(v+"_sub",mt,Gt,mt),p.call(v+"_sub",Lt,ht,Bt),p.call(v+"_square",L,It),p.call(v+"_square",Lt,$t),p.call(v+"_sub",ht,Et,Gt),p.call(v+"_mul",rt,Gt,L),p.call(v+"_add",$t,$t,Gt),p.call(v+"_add",$t,Gt,Gt),p.call(v+"_square",vt,H),p.call(v+"_sub",H,Gt,H),p.call(v+"_mul",ht,mt,tt),p.call(v+"_mul",p.i32_const(Q),Bt,N),p.call(v+"_neg",mt,et),p.call(v+"_add",It,It,Y),p.call(v+"_add",It,Y,Y))}function _t(){const ot=t.addFunction(a+"_mulByQ");ot.addParam("p1","i32"),ot.addParam("pr","i32");const p=ot.getCodeBuilder(),L=p.getLocal("p1"),H=p.i32_add(p.getLocal("p1"),p.i32_const(c)),tt=p.i32_add(p.getLocal("p1"),p.i32_const(c*2)),N=p.getLocal("pr"),et=p.i32_add(p.getLocal("pr"),p.i32_const(c)),Y=p.i32_add(p.getLocal("pr"),p.i32_const(c*2)),rt=p.i32_const(t.alloc([...qt.bigInt2BytesLE(P("21575463638280843010398324269430826099269044274347216827212613867836435027261"),r),...qt.bigInt2BytesLE(P("10307601595873709700152284273816112264069230130616436755625194854815875713954"),r)])),ht=p.i32_const(t.alloc([...qt.bigInt2BytesLE(P("2821565182194536844548159561693502659359617185244120367078079554186484126554"),r),...qt.bigInt2BytesLE(P("3505843767911556378687030309984248845540243509899259641013678093033130930403"),r)]));ot.addCode(p.call(v+"_conjugate",L,N),p.call(v+"_mul",rt,N,N),p.call(v+"_conjugate",H,et),p.call(v+"_mul",ht,et,et),p.call(v+"_conjugate",tt,Y))}function wt(){_t();const ot=t.addFunction(a+"_prepareG2");ot.addParam("pQ","i32"),ot.addParam("ppreQ","i32"),ot.addLocal("pCoef","i32"),ot.addLocal("i","i32");const p=ot.getCodeBuilder(),L=p.getLocal("pQ"),H=t.alloc(c*3),tt=p.i32_const(H),N=p.i32_const(H),et=p.i32_const(H+c),Y=p.i32_const(H+2*c),rt=p.i32_add(p.getLocal("ppreQ"),p.i32_const(0)),ht=p.i32_add(p.getLocal("ppreQ"),p.i32_const(c)),pt=t.alloc(c*3),dt=p.i32_const(pt),Lt=t.alloc(c*3),Et=p.i32_const(Lt),vt=p.i32_const(Lt+c);ot.addCode(p.call(y+"_normalize",L,rt),p.call(v+"_copy",rt,N),p.call(v+"_copy",ht,et),p.call(v+"_one",Y)),ot.addCode(p.setLocal("pCoef",p.i32_add(p.getLocal("ppreQ"),p.i32_const(c*3))),p.setLocal("i",p.i32_const(k.length-2)),p.block(p.loop(p.call(a+"_prepDblStep",tt,p.getLocal("pCoef")),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))),p.if(p.i32_load8_s(p.getLocal("i"),K),[...p.call(a+"_prepAddStep",rt,tt,p.getLocal("pCoef")),...p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I)))]),p.br_if(1,p.i32_eqz(p.getLocal("i"))),p.setLocal("i",p.i32_sub(p.getLocal("i"),p.i32_const(1))),p.br(0)))),ot.addCode(p.call(a+"_mulByQ",rt,dt),p.call(a+"_mulByQ",dt,Et)),ot.addCode(p.call(v+"_neg",vt,vt),p.call(a+"_prepAddStep",dt,tt,p.getLocal("pCoef")),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))),p.call(a+"_prepAddStep",Et,tt,p.getLocal("pCoef")),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))))}function ft(){const ot=t.addFunction(a+"__mulBy024Old");ot.addParam("pEll0","i32"),ot.addParam("pEllVW","i32"),ot.addParam("pEllVV","i32"),ot.addParam("pR","i32");const p=ot.getCodeBuilder(),L=p.getLocal("pEll0"),H=p.getLocal("pEllVV"),tt=p.getLocal("pEllVW"),N=p.getLocal("pR"),et=t.alloc(u),Y=p.i32_const(et),rt=p.i32_const(et),ht=p.i32_const(et+c),pt=p.i32_const(et+c*2),dt=p.i32_const(et+c*3),Lt=p.i32_const(et+c*4),Et=p.i32_const(et+c*5);ot.addCode(p.call(v+"_copy",L,rt),p.call(v+"_zero",ht),p.call(v+"_copy",H,pt),p.call(v+"_zero",dt),p.call(v+"_copy",tt,Lt),p.call(v+"_zero",Et),p.call(at+"_mul",Y,N,N))}function st(){const ot=t.addFunction(a+"__mulBy024");ot.addParam("pEll0","i32"),ot.addParam("pEllVW","i32"),ot.addParam("pEllVV","i32"),ot.addParam("pR","i32");const p=ot.getCodeBuilder(),L=p.getLocal("pEll0"),H=p.getLocal("pEllVV"),tt=p.getLocal("pEllVW"),N=p.getLocal("pR"),et=p.i32_add(p.getLocal("pR"),p.i32_const(2*s)),Y=p.i32_add(p.getLocal("pR"),p.i32_const(4*s)),rt=p.i32_add(p.getLocal("pR"),p.i32_const(6*s)),ht=p.i32_add(p.getLocal("pR"),p.i32_const(8*s)),pt=p.i32_add(p.getLocal("pR"),p.i32_const(10*s)),dt=p.i32_const(t.alloc(c)),Lt=p.i32_const(t.alloc(c)),Et=p.i32_const(t.alloc(c)),vt=p.i32_const(t.alloc(c)),mt=p.i32_const(t.alloc(c)),Bt=p.i32_const(t.alloc(c)),It=p.i32_const(t.alloc(c)),$t=p.i32_const(t.alloc(c)),Gt=p.i32_const(t.alloc(c)),Tt=p.i32_const(t.alloc(c)),At=p.i32_const(t.alloc(c));ot.addCode(p.call(v+"_mul",N,L,It),p.call(v+"_mul",Y,H,$t),p.call(v+"_mul",ht,tt,Gt),p.call(v+"_add",N,ht,Et),p.call(v+"_add",N,Y,Lt),p.call(v+"_add",et,rt,vt),p.call(v+"_add",vt,pt,vt),p.call(v+"_mul",et,H,Tt),p.call(v+"_add",Tt,Gt,mt),p.call(v+"_mul",p.i32_const(q),mt,Bt),p.call(v+"_add",Bt,It,N),p.call(v+"_mul",pt,tt,mt),p.call(v+"_add",Tt,mt,Tt),p.call(v+"_add",mt,$t,mt),p.call(v+"_mul",p.i32_const(q),mt,Bt),p.call(v+"_mul",et,L,mt),p.call(v+"_add",Tt,mt,Tt),p.call(v+"_add",Bt,mt,et),p.call(v+"_add",L,H,dt),p.call(v+"_mul",Lt,dt,mt),p.call(v+"_add",It,$t,At),p.call(v+"_sub",mt,At,mt),p.call(v+"_mul",rt,tt,Bt),p.call(v+"_add",Tt,Bt,Tt),p.call(v+"_add",Y,ht,dt),p.call(v+"_add",mt,Bt,Y),p.call(v+"_add",H,tt,Lt),p.call(v+"_mul",Lt,dt,mt),p.call(v+"_add",$t,Gt,At),p.call(v+"_sub",mt,At,mt),p.call(v+"_mul",p.i32_const(q),mt,Bt),p.call(v+"_mul",rt,L,mt),p.call(v+"_add",Tt,mt,Tt),p.call(v+"_add",Bt,mt,rt),p.call(v+"_mul",pt,H,mt),p.call(v+"_add",Tt,mt,Tt),p.call(v+"_mul",p.i32_const(q),mt,Bt),p.call(v+"_add",L,tt,dt),p.call(v+"_mul",Et,dt,mt),p.call(v+"_add",It,Gt,At),p.call(v+"_sub",mt,At,mt),p.call(v+"_add",Bt,mt,ht),p.call(v+"_add",L,H,dt),p.call(v+"_add",dt,tt,dt),p.call(v+"_mul",vt,dt,mt),p.call(v+"_sub",mt,Tt,pt))}function ct(){const ot=t.addFunction(a+"_millerLoop");ot.addParam("ppreP","i32"),ot.addParam("ppreQ","i32"),ot.addParam("r","i32"),ot.addLocal("pCoef","i32"),ot.addLocal("i","i32");const p=ot.getCodeBuilder(),L=p.getLocal("ppreP"),H=p.i32_add(p.getLocal("ppreP"),p.i32_const(r)),tt=p.getLocal("pCoef"),N=p.i32_add(p.getLocal("pCoef"),p.i32_const(c)),et=p.i32_add(p.getLocal("pCoef"),p.i32_const(2*c)),Y=t.alloc(c),rt=p.i32_const(Y),ht=t.alloc(c),pt=p.i32_const(ht),dt=p.getLocal("r");ot.addCode(p.call(at+"_one",dt),p.setLocal("pCoef",p.i32_add(p.getLocal("ppreQ"),p.i32_const(c*3))),p.setLocal("i",p.i32_const(k.length-2)),p.block(p.loop(p.call(at+"_square",dt,dt),p.call(v+"_mul1",N,H,rt),p.call(v+"_mul1",et,L,pt),p.call(a+"__mulBy024",tt,rt,pt,dt),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))),p.if(p.i32_load8_s(p.getLocal("i"),K),[...p.call(v+"_mul1",N,H,rt),...p.call(v+"_mul1",et,L,pt),...p.call(a+"__mulBy024",tt,rt,pt,dt),...p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I)))]),p.br_if(1,p.i32_eqz(p.getLocal("i"))),p.setLocal("i",p.i32_sub(p.getLocal("i"),p.i32_const(1))),p.br(0)))),ot.addCode(p.call(v+"_mul1",N,H,rt),p.call(v+"_mul1",et,L,pt),p.call(a+"__mulBy024",tt,rt,pt,dt),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))),p.call(v+"_mul1",N,H,rt),p.call(v+"_mul1",et,L,pt),p.call(a+"__mulBy024",tt,rt,pt,dt),p.setLocal("pCoef",p.i32_add(p.getLocal("pCoef"),p.i32_const(I))))}function gt(ot){const p=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[8376118865763821496583973867626364092589906065868298776909617916018768340080n,16469823323077808223889137241176536799009286646108169935659301613961712198316n],[21888242871839275220042445260109153167277707414472061641714758635765020556617n,0n],[11697423496358154304825782922584725312912383441159505038794027105778954184319n,303847389135065887422783454877609941456349188919719272345083954437860409601n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[3321304630594332808241809054958361220322477375291206261884409189760185844239n,5722266937896532885780051958958348231143373700109372999374820235121374419868n],[21888242871839275222246405745257275088696311157297823662689037894645226208582n,0n],[13512124006075453725662431877630910996106405091429524885779419978626457868503n,5418419548761466998357268504080738289687024511189653727029736280683514010267n],[2203960485148121921418603742825762020974279258880205651966n,0n],[10190819375481120917420622822672549775783927716138318623895010788866272024264n,21584395482704209334823622290379665147239961968378104390343953940207365798982n],[2203960485148121921418603742825762020974279258880205651967n,0n],[18566938241244942414004596690298913868373833782006617400804628704885040364344n,16165975933942742336466353786298926857552937457188450663314217659523851788715n]]],L=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[21575463638280843010398324269430826099269044274347216827212613867836435027261n,10307601595873709700152284273816112264069230130616436755625194854815875713954n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[3772000881919853776433695186713858239009073593817195771773381919316419345261n,2236595495967245188281701248203181795121068902605861227855261137820944008926n],[2203960485148121921418603742825762020974279258880205651966n,0n],[18429021223477853657660792034369865839114504446431234726392080002137598044644n,9344045779998320333812420223237981029506012124075525679208581902008406485703n]],[[1n,0n],[2581911344467009335267311115468803099551665605076196740867805258568234346338n,19937756971775647987995932169929341994314640652964949448313374472400716661030n],[2203960485148121921418603742825762020974279258880205651966n,0n],[5324479202449903542726783395506214481928257762400643279780343368557297135718n,16208900380737693084919495127334387981393726419856888799917914180988844123039n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[13981852324922362344252311234282257507216387789820983642040889267519694726527n,7629828391165209371577384193250820201684255241773809077146787135900891633097n]]],H=t.addFunction(a+"__frobeniusMap"+ot);H.addParam("x","i32"),H.addParam("r","i32");const tt=H.getCodeBuilder();for(let et=0;et<6;et++){const Y=et==0?tt.getLocal("x"):tt.i32_add(tt.getLocal("x"),tt.i32_const(et*c)),rt=Y,ht=tt.i32_add(tt.getLocal("x"),tt.i32_const(et*c+r)),pt=et==0?tt.getLocal("r"):tt.i32_add(tt.getLocal("r"),tt.i32_const(et*c)),dt=pt,Lt=tt.i32_add(tt.getLocal("r"),tt.i32_const(et*c+r)),Et=N(p[Math.floor(et/3)][ot%12],L[et%3][ot%6]),vt=t.alloc([...qt.bigInt2BytesLE(P(Et[0]),32),...qt.bigInt2BytesLE(P(Et[1]),32)]);ot%2==1?H.addCode(tt.call(w+"_copy",rt,dt),tt.call(w+"_neg",ht,Lt),tt.call(v+"_mul",pt,tt.i32_const(vt),pt)):H.addCode(tt.call(v+"_mul",Y,tt.i32_const(vt),pt))}function N(et,Y){const rt=BigInt(et[0]),ht=BigInt(et[1]),pt=BigInt(Y[0]),dt=BigInt(Y[1]),Lt=[(rt*pt-ht*dt)%i,(rt*dt+ht*pt)%i];return Wc(Lt[0])&&(Lt[0]=Lt[0]+i),Lt}}function yt(){const ot=t.addFunction(a+"__finalExponentiationFirstChunk");ot.addParam("x","i32"),ot.addParam("r","i32");const p=ot.getCodeBuilder(),L=p.getLocal("x"),H=L,tt=p.i32_add(L,p.i32_const(s*6)),N=p.getLocal("r"),et=t.alloc(u),Y=p.i32_const(et),rt=Y,ht=p.i32_const(et+s*6),pt=p.i32_const(t.alloc(u)),dt=p.i32_const(t.alloc(u)),Lt=p.i32_const(t.alloc(u));ot.addCode(p.call(nt+"_copy",H,rt),p.call(nt+"_neg",tt,ht),p.call(at+"_inverse",L,pt),p.call(at+"_mul",Y,pt,dt),p.call(a+"__frobeniusMap2",dt,Lt),p.call(at+"_mul",dt,Lt,N))}function xt(){const ot=t.addFunction(a+"__cyclotomicSquare");ot.addParam("x","i32"),ot.addParam("r","i32");const p=ot.getCodeBuilder(),L=p.getLocal("x"),H=p.i32_add(p.getLocal("x"),p.i32_const(c)),tt=p.i32_add(p.getLocal("x"),p.i32_const(2*c)),N=p.i32_add(p.getLocal("x"),p.i32_const(3*c)),et=p.i32_add(p.getLocal("x"),p.i32_const(4*c)),Y=p.i32_add(p.getLocal("x"),p.i32_const(5*c)),rt=p.getLocal("r"),ht=p.i32_add(p.getLocal("r"),p.i32_const(c)),pt=p.i32_add(p.getLocal("r"),p.i32_const(2*c)),dt=p.i32_add(p.getLocal("r"),p.i32_const(3*c)),Lt=p.i32_add(p.getLocal("r"),p.i32_const(4*c)),Et=p.i32_add(p.getLocal("r"),p.i32_const(5*c)),vt=p.i32_const(t.alloc(c)),mt=p.i32_const(t.alloc(c)),Bt=p.i32_const(t.alloc(c)),It=p.i32_const(t.alloc(c)),$t=p.i32_const(t.alloc(c)),Gt=p.i32_const(t.alloc(c)),Tt=p.i32_const(t.alloc(c)),At=p.i32_const(t.alloc(c));ot.addCode(p.call(v+"_mul",L,et,Tt),p.call(v+"_mul",et,p.i32_const(q),vt),p.call(v+"_add",L,vt,vt),p.call(v+"_add",L,et,At),p.call(v+"_mul",At,vt,vt),p.call(v+"_mul",p.i32_const(q),Tt,At),p.call(v+"_add",Tt,At,At),p.call(v+"_sub",vt,At,vt),p.call(v+"_add",Tt,Tt,mt),p.call(v+"_mul",N,tt,Tt),p.call(v+"_mul",tt,p.i32_const(q),Bt),p.call(v+"_add",N,Bt,Bt),p.call(v+"_add",N,tt,At),p.call(v+"_mul",At,Bt,Bt),p.call(v+"_mul",p.i32_const(q),Tt,At),p.call(v+"_add",Tt,At,At),p.call(v+"_sub",Bt,At,Bt),p.call(v+"_add",Tt,Tt,It),p.call(v+"_mul",H,Y,Tt),p.call(v+"_mul",Y,p.i32_const(q),$t),p.call(v+"_add",H,$t,$t),p.call(v+"_add",H,Y,At),p.call(v+"_mul",At,$t,$t),p.call(v+"_mul",p.i32_const(q),Tt,At),p.call(v+"_add",Tt,At,At),p.call(v+"_sub",$t,At,$t),p.call(v+"_add",Tt,Tt,Gt),p.call(v+"_sub",vt,L,rt),p.call(v+"_add",rt,rt,rt),p.call(v+"_add",vt,rt,rt),p.call(v+"_add",mt,et,Lt),p.call(v+"_add",Lt,Lt,Lt),p.call(v+"_add",mt,Lt,Lt),p.call(v+"_mul",Gt,p.i32_const(Q),At),p.call(v+"_add",At,N,dt),p.call(v+"_add",dt,dt,dt),p.call(v+"_add",At,dt,dt),p.call(v+"_sub",$t,tt,pt),p.call(v+"_add",pt,pt,pt),p.call(v+"_add",$t,pt,pt),p.call(v+"_sub",Bt,H,ht),p.call(v+"_add",ht,ht,ht),p.call(v+"_add",Bt,ht,ht),p.call(v+"_add",It,Y,Et),p.call(v+"_add",Et,Et,Et),p.call(v+"_add",It,Et,Et))}function Rt(ot,p){const L=z(ot).map(ht=>ht==-1?255:ht),H=t.alloc(L),tt=t.addFunction(a+"__cyclotomicExp_"+p);tt.addParam("x","i32"),tt.addParam("r","i32"),tt.addLocal("bit","i32"),tt.addLocal("i","i32");const N=tt.getCodeBuilder(),et=N.getLocal("x"),Y=N.getLocal("r"),rt=N.i32_const(t.alloc(u));tt.addCode(N.call(at+"_conjugate",et,rt),N.call(at+"_one",Y),N.if(N.teeLocal("bit",N.i32_load8_s(N.i32_const(L.length-1),H)),N.if(N.i32_eq(N.getLocal("bit"),N.i32_const(1)),N.call(at+"_mul",Y,et,Y),N.call(at+"_mul",Y,rt,Y))),N.setLocal("i",N.i32_const(L.length-2)),N.block(N.loop(N.call(a+"__cyclotomicSquare",Y,Y),N.if(N.teeLocal("bit",N.i32_load8_s(N.getLocal("i"),H)),N.if(N.i32_eq(N.getLocal("bit"),N.i32_const(1)),N.call(at+"_mul",Y,et,Y),N.call(at+"_mul",Y,rt,Y))),N.br_if(1,N.i32_eqz(N.getLocal("i"))),N.setLocal("i",N.i32_sub(N.getLocal("i"),N.i32_const(1))),N.br(0))))}function Vt(){xt(),Rt(m,"w0");const ot=t.addFunction(a+"__finalExponentiationLastChunk");ot.addParam("x","i32"),ot.addParam("r","i32");const p=ot.getCodeBuilder(),L=p.getLocal("x"),H=p.getLocal("r"),tt=p.i32_const(t.alloc(u)),N=p.i32_const(t.alloc(u)),et=p.i32_const(t.alloc(u)),Y=p.i32_const(t.alloc(u)),rt=p.i32_const(t.alloc(u)),ht=p.i32_const(t.alloc(u)),pt=p.i32_const(t.alloc(u)),dt=p.i32_const(t.alloc(u)),Lt=p.i32_const(t.alloc(u)),Et=p.i32_const(t.alloc(u)),vt=p.i32_const(t.alloc(u)),mt=p.i32_const(t.alloc(u)),Bt=p.i32_const(t.alloc(u)),It=p.i32_const(t.alloc(u)),$t=p.i32_const(t.alloc(u)),Gt=p.i32_const(t.alloc(u)),Tt=p.i32_const(t.alloc(u)),At=p.i32_const(t.alloc(u)),Xt=p.i32_const(t.alloc(u)),mn=p.i32_const(t.alloc(u)),Tn=p.i32_const(t.alloc(u));ot.addCode(p.call(a+"__cyclotomicExp_w0",L,tt),p.call(at+"_conjugate",tt,tt),p.call(a+"__cyclotomicSquare",tt,N),p.call(a+"__cyclotomicSquare",N,et),p.call(at+"_mul",et,N,Y),p.call(a+"__cyclotomicExp_w0",Y,rt),p.call(at+"_conjugate",rt,rt),p.call(a+"__cyclotomicSquare",rt,ht),p.call(a+"__cyclotomicExp_w0",ht,pt),p.call(at+"_conjugate",pt,pt),p.call(at+"_conjugate",Y,dt),p.call(at+"_conjugate",pt,Lt),p.call(at+"_mul",Lt,rt,Et),p.call(at+"_mul",Et,dt,vt),p.call(at+"_mul",vt,N,mt),p.call(at+"_mul",vt,rt,Bt),p.call(at+"_mul",Bt,L,It),p.call(a+"__frobeniusMap1",mt,$t),p.call(at+"_mul",$t,It,Gt),p.call(a+"__frobeniusMap2",vt,Tt),p.call(at+"_mul",Tt,Gt,At),p.call(at+"_conjugate",L,Xt),p.call(at+"_mul",Xt,mt,mn),p.call(a+"__frobeniusMap3",mn,Tn),p.call(at+"_mul",Tn,At,H))}function jt(){yt(),Vt();const ot=t.addFunction(a+"_finalExponentiation");ot.addParam("x","i32"),ot.addParam("r","i32");const p=ot.getCodeBuilder(),L=p.getLocal("x"),H=p.getLocal("r"),tt=p.i32_const(t.alloc(u));ot.addCode(p.call(a+"__finalExponentiationFirstChunk",L,tt),p.call(a+"__finalExponentiationLastChunk",tt,H))}function Pt(){const ot=t.addFunction(a+"_finalExponentiationOld");ot.addParam("x","i32"),ot.addParam("r","i32");const L=t.alloc(qt.bigInt2BytesLE(552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n,352)),H=ot.getCodeBuilder();ot.addCode(H.call(at+"_exp",H.getLocal("x"),H.i32_const(L),H.i32_const(352),H.getLocal("r")))}const bt=t.alloc(U),kt=t.alloc(G);function Jt(ot){const p=t.addFunction(a+"_pairingEq"+ot);for(let N=0;N<ot;N++)p.addParam("p_"+N,"i32"),p.addParam("q_"+N,"i32");p.addParam("c","i32"),p.setReturnType("i32");const L=p.getCodeBuilder(),H=L.i32_const(t.alloc(u)),tt=L.i32_const(t.alloc(u));p.addCode(L.call(at+"_one",H));for(let N=0;N<ot;N++)p.addCode(L.call(a+"_prepareG1",L.getLocal("p_"+N),L.i32_const(bt))),p.addCode(L.call(a+"_prepareG2",L.getLocal("q_"+N),L.i32_const(kt))),p.addCode(L.call(a+"_millerLoop",L.i32_const(bt),L.i32_const(kt),tt)),p.addCode(L.call(at+"_mul",H,tt,H));p.addCode(L.call(a+"_finalExponentiation",H,H)),p.addCode(L.call(at+"_eq",H,L.getLocal("c")))}function Dt(){const ot=t.addFunction(a+"_pairing");ot.addParam("p","i32"),ot.addParam("q","i32"),ot.addParam("r","i32");const p=ot.getCodeBuilder(),L=p.i32_const(t.alloc(u));ot.addCode(p.call(a+"_prepareG1",p.getLocal("p"),p.i32_const(bt))),ot.addCode(p.call(a+"_prepareG2",p.getLocal("q"),p.i32_const(kt))),ot.addCode(p.call(a+"_millerLoop",p.i32_const(bt),p.i32_const(kt),L)),ot.addCode(p.call(a+"_finalExponentiation",L,p.getLocal("r")))}X(),lt(),it(),wt(),st(),ft(),ct();for(let ot=0;ot<10;ot++)gt(ot),t.exportFunction(a+"__frobeniusMap"+ot);Pt(),jt();for(let ot=1;ot<=5;ot++)Jt(ot),t.exportFunction(a+"_pairingEq"+ot);Dt(),t.exportFunction(a+"_pairing"),t.exportFunction(a+"_prepareG1"),t.exportFunction(a+"_prepareG2"),t.exportFunction(a+"_millerLoop"),t.exportFunction(a+"_finalExponentiation"),t.exportFunction(a+"_finalExponentiationOld"),t.exportFunction(a+"__mulBy024"),t.exportFunction(a+"__mulBy024Old"),t.exportFunction(a+"__cyclotomicSquare"),t.exportFunction(a+"__cyclotomicExp_w0")};const Ot=$n,Dc=fe,Kc=Go,Ue=To,Xc=Oo,Re=zo,gi=qo,Yc=Mo,Jc=Uo,La=Ro,{bitLength:ke,isOdd:$e,isNegative:tl}=fn;var nl=function(t,n){const a=n||"bls12381";if(t.modules[a])return a;const i=0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,o=0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n,l=Math.floor((ke(i-1n)-1)/64)+1,s=l*8,f=s,r=f*2,c=f*12,u=Math.floor((ke(o-1n)-1)/64)+1,b=u*8,w=b,A=t.alloc(Ot.bigInt2BytesLE(o,w)),x=Dc(t,i,"f1m","intq");Kc(t,o,"fr","frm","intr");const v=t.alloc(Ot.bigInt2BytesLE(C(4n),f)),F=Re(t,"g1m","f1m",v);gi(t,"frm","frm","frm","frm_mul"),Yc(t,"pol","frm"),Jc(t,"qap","frm");const y=Ue(t,"f1m_neg","f2m","f1m"),B=t.alloc([...Ot.bigInt2BytesLE(C(4n),f),...Ot.bigInt2BytesLE(C(4n),f)]),P=Re(t,"g2m","f2m",B);function T(p,L){const H=t.addFunction(p);H.addParam("pG","i32"),H.addParam("pFr","i32"),H.addParam("pr","i32");const tt=H.getCodeBuilder(),N=tt.i32_const(t.alloc(b));H.addCode(tt.call("frm_fromMontgomery",tt.getLocal("pFr"),N),tt.call(L,tt.getLocal("pG"),N,tt.i32_const(b),tt.getLocal("pr"))),t.exportFunction(p)}T("g1m_timesFr","g1m_timesScalar"),gi(t,"g1m","g1m","frm","g1m_timesFr"),T("g2m_timesFr","g2m_timesScalar"),gi(t,"g2m","g2m","frm","g2m_timesFr"),T("g1m_timesFrAffine","g1m_timesScalarAffine"),T("g2m_timesFrAffine","g2m_timesScalarAffine"),La(t,"frm_batchApplyKey","fmr","frm",b,b,b,"frm_mul"),La(t,"g1m_batchApplyKey","g1m","frm",s*3,s*3,b,"g1m_timesFr"),La(t,"g1m_batchApplyKeyMixed","g1m","frm",s*2,s*3,b,"g1m_timesFrAffine"),La(t,"g2m_batchApplyKey","g2m","frm",s*2*3,s*3*2,b,"g2m_timesFr"),La(t,"g2m_batchApplyKeyMixed","g2m","frm",s*2*2,s*3*2,b,"g2m_timesFrAffine");function C(p){return BigInt(p)*(1n<<BigInt(f*8))%i}const _=[3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,1n],g=t.alloc([...Ot.bigInt2BytesLE(C(_[0]),f),...Ot.bigInt2BytesLE(C(_[1]),f),...Ot.bigInt2BytesLE(C(_[2]),f)]),$=[0n,1n,0n],Z=t.alloc([...Ot.bigInt2BytesLE(C($[0]),f),...Ot.bigInt2BytesLE(C($[1]),f),...Ot.bigInt2BytesLE(C($[2]),f)]),j=[[352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n],[1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n],[1n,0n]],O=t.alloc([...Ot.bigInt2BytesLE(C(j[0][0]),f),...Ot.bigInt2BytesLE(C(j[0][1]),f),...Ot.bigInt2BytesLE(C(j[1][0]),f),...Ot.bigInt2BytesLE(C(j[1][1]),f),...Ot.bigInt2BytesLE(C(j[2][0]),f),...Ot.bigInt2BytesLE(C(j[2][1]),f)]),E=[[0n,0n],[1n,0n],[0n,0n]],q=t.alloc([...Ot.bigInt2BytesLE(C(E[0][0]),f),...Ot.bigInt2BytesLE(C(E[0][1]),f),...Ot.bigInt2BytesLE(C(E[1][0]),f),...Ot.bigInt2BytesLE(C(E[1][1]),f),...Ot.bigInt2BytesLE(C(E[2][0]),f),...Ot.bigInt2BytesLE(C(E[2][1]),f)]),M=t.alloc([...Ot.bigInt2BytesLE(C(1n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f),...Ot.bigInt2BytesLE(C(0n),f)]),Q=t.alloc([...Ot.bigInt2BytesLE(C(1n),f),...Ot.bigInt2BytesLE(C(1n),f)]);function D(){const p=t.addFunction(y+"_mulNR");p.addParam("x","i32"),p.addParam("pr","i32");const L=p.getCodeBuilder(),H=L.i32_const(t.alloc(f)),tt=L.getLocal("x"),N=L.i32_add(L.getLocal("x"),L.i32_const(f)),et=L.getLocal("pr"),Y=L.i32_add(L.getLocal("pr"),L.i32_const(f));p.addCode(L.call(x+"_copy",tt,H),L.call(x+"_sub",tt,N,et),L.call(x+"_add",H,N,Y))}D();const V=Xc(t,y+"_mulNR","f6m","f2m");function nt(){const p=t.addFunction(V+"_mulNR");p.addParam("x","i32"),p.addParam("pr","i32");const L=p.getCodeBuilder(),H=L.i32_const(t.alloc(f*2));p.addCode(L.call(y+"_copy",L.getLocal("x"),H),L.call(y+"_mulNR",L.i32_add(L.getLocal("x"),L.i32_const(s*4)),L.getLocal("pr")),L.call(y+"_copy",L.i32_add(L.getLocal("x"),L.i32_const(s*2)),L.i32_add(L.getLocal("pr"),L.i32_const(s*4))),L.call(y+"_copy",H,L.i32_add(L.getLocal("pr"),L.i32_const(s*2))))}nt();const R=Ue(t,V+"_mulNR","ftm",V),J=W(0xd201000000010000n),k=t.alloc(J),K=3*r,I=J.length-1,S=J.reduce((p,L)=>p+(L!=0?1:0),0)+I+1,h=6*s,U=3*s*2+S*K,G=!0,m=15132376222941642752n;t.modules[a]={n64q:l,n64r:u,n8q:s,n8r:b,pG1gen:g,pG1zero:Z,pG1b:v,pG2gen:O,pG2zero:q,pG2b:B,pq:t.modules.f1m.pq,pr:A,pOneT:M,r:o,q:i,prePSize:h,preQSize:U};function z(p){let L=p;const H=[];for(;L>0n;){if($e(L)){const tt=2-Number(L%4n);H.push(tt),L=L-BigInt(tt)}else H.push(0);L=L>>1n}return H}function W(p){let L=p;const H=[];for(;L>0n;)$e(L)?H.push(1):H.push(0),L=L>>1n;return H}function it(){const p=t.addFunction(a+"_prepareG1");p.addParam("pP","i32"),p.addParam("ppreP","i32");const L=p.getCodeBuilder();p.addCode(L.call(F+"_normalize",L.getLocal("pP"),L.getLocal("ppreP")))}function X(){const p=t.addFunction(a+"_prepDblStep");p.addParam("R","i32"),p.addParam("r","i32");const L=p.getCodeBuilder(),H=L.getLocal("R"),tt=L.i32_add(L.getLocal("R"),L.i32_const(2*s)),N=L.i32_add(L.getLocal("R"),L.i32_const(4*s)),et=L.getLocal("r"),Y=L.i32_add(L.getLocal("r"),L.i32_const(2*s)),rt=L.i32_add(L.getLocal("r"),L.i32_const(4*s)),ht=L.i32_const(t.alloc(r)),pt=L.i32_const(t.alloc(r)),dt=L.i32_const(t.alloc(r)),Lt=L.i32_const(t.alloc(r)),Et=L.i32_const(t.alloc(r));p.addCode(L.call(y+"_square",H,et),L.call(y+"_square",tt,pt),L.call(y+"_square",pt,dt),L.call(y+"_add",pt,H,Y),L.call(y+"_square",Y,Y),L.call(y+"_sub",Y,et,Y),L.call(y+"_sub",Y,dt,Y),L.call(y+"_add",Y,Y,Y),L.call(y+"_add",et,et,Lt),L.call(y+"_add",Lt,et,Lt),L.call(y+"_add",H,Lt,rt),L.call(y+"_square",Lt,Et),L.call(y+"_square",N,ht),L.call(y+"_sub",Et,Y,H),L.call(y+"_sub",H,Y,H),L.call(y+"_add",N,tt,N),L.call(y+"_square",N,N),L.call(y+"_sub",N,pt,N),L.call(y+"_sub",N,ht,N),L.call(y+"_sub",Y,H,tt),L.call(y+"_mul",tt,Lt,tt),L.call(y+"_add",dt,dt,dt),L.call(y+"_add",dt,dt,dt),L.call(y+"_add",dt,dt,dt),L.call(y+"_sub",tt,dt,tt),L.call(y+"_mul",Lt,ht,Y),L.call(y+"_add",Y,Y,Y),L.call(y+"_neg",Y,Y),L.call(y+"_square",rt,rt),L.call(y+"_sub",rt,et,rt),L.call(y+"_sub",rt,Et,rt),L.call(y+"_add",pt,pt,pt),L.call(y+"_add",pt,pt,pt),L.call(y+"_sub",rt,pt,rt),L.call(y+"_mul",N,ht,et),L.call(y+"_add",et,et,et))}function lt(){const p=t.addFunction(a+"_prepAddStep");p.addParam("R","i32"),p.addParam("Q","i32"),p.addParam("r","i32");const L=p.getCodeBuilder(),H=L.getLocal("R"),tt=L.i32_add(L.getLocal("R"),L.i32_const(2*s)),N=L.i32_add(L.getLocal("R"),L.i32_const(4*s)),et=L.getLocal("Q"),Y=L.i32_add(L.getLocal("Q"),L.i32_const(2*s)),rt=L.getLocal("r"),ht=L.i32_add(L.getLocal("r"),L.i32_const(2*s)),pt=L.i32_add(L.getLocal("r"),L.i32_const(4*s)),dt=L.i32_const(t.alloc(r)),Lt=L.i32_const(t.alloc(r)),Et=L.i32_const(t.alloc(r)),vt=L.i32_const(t.alloc(r)),mt=L.i32_const(t.alloc(r)),Bt=L.i32_const(t.alloc(r)),It=L.i32_const(t.alloc(r)),$t=L.i32_const(t.alloc(r)),Gt=L.i32_const(t.alloc(r)),Tt=L.i32_const(t.alloc(r)),At=L.i32_const(t.alloc(r));p.addCode(L.call(y+"_square",N,dt),L.call(y+"_square",Y,Lt),L.call(y+"_mul",dt,et,vt),L.call(y+"_add",Y,N,ht),L.call(y+"_square",ht,ht),L.call(y+"_sub",ht,Lt,ht),L.call(y+"_sub",ht,dt,ht),L.call(y+"_mul",ht,dt,ht),L.call(y+"_sub",vt,H,mt),L.call(y+"_square",mt,Bt),L.call(y+"_add",Bt,Bt,It),L.call(y+"_add",It,It,It),L.call(y+"_mul",It,mt,$t),L.call(y+"_sub",ht,tt,Gt),L.call(y+"_sub",Gt,tt,Gt),L.call(y+"_mul",Gt,et,pt),L.call(y+"_mul",It,H,Tt),L.call(y+"_square",Gt,H),L.call(y+"_sub",H,$t,H),L.call(y+"_sub",H,Tt,H),L.call(y+"_sub",H,Tt,H),L.call(y+"_add",N,mt,N),L.call(y+"_square",N,N),L.call(y+"_sub",N,dt,N),L.call(y+"_sub",N,Bt,N),L.call(y+"_add",Y,N,rt),L.call(y+"_sub",Tt,H,At),L.call(y+"_mul",At,Gt,At),L.call(y+"_mul",tt,$t,vt),L.call(y+"_add",vt,vt,vt),L.call(y+"_sub",At,vt,tt),L.call(y+"_square",rt,rt),L.call(y+"_sub",rt,Lt,rt),L.call(y+"_square",N,Et),L.call(y+"_sub",rt,Et,rt),L.call(y+"_add",pt,pt,pt),L.call(y+"_sub",pt,rt,pt),L.call(y+"_add",N,N,rt),L.call(y+"_neg",Gt,Gt),L.call(y+"_add",Gt,Gt,ht))}function _t(){const p=t.addFunction(a+"_prepareG2");p.addParam("pQ","i32"),p.addParam("ppreQ","i32"),p.addLocal("pCoef","i32"),p.addLocal("i","i32");const L=p.getCodeBuilder(),H=L.getLocal("pQ"),tt=t.alloc(r*3),N=L.i32_const(tt),et=L.getLocal("ppreQ");p.addCode(L.call(P+"_normalize",H,et),L.if(L.call(P+"_isZero",et),L.ret([])),L.call(P+"_copy",et,N),L.setLocal("pCoef",L.i32_add(L.getLocal("ppreQ"),L.i32_const(r*3)))),p.addCode(L.setLocal("i",L.i32_const(J.length-2)),L.block(L.loop(L.call(a+"_prepDblStep",N,L.getLocal("pCoef")),L.setLocal("pCoef",L.i32_add(L.getLocal("pCoef"),L.i32_const(K))),L.if(L.i32_load8_s(L.getLocal("i"),k),[...L.call(a+"_prepAddStep",N,et,L.getLocal("pCoef")),...L.setLocal("pCoef",L.i32_add(L.getLocal("pCoef"),L.i32_const(K)))]),L.br_if(1,L.i32_eqz(L.getLocal("i"))),L.setLocal("i",L.i32_sub(L.getLocal("i"),L.i32_const(1))),L.br(0))))}function wt(){const p=t.addFunction(V+"_mul1");p.addParam("pA","i32"),p.addParam("pC1","i32"),p.addParam("pR","i32");const L=p.getCodeBuilder(),H=L.getLocal("pA"),tt=L.i32_add(L.getLocal("pA"),L.i32_const(f*2)),N=L.i32_add(L.getLocal("pA"),L.i32_const(f*4)),et=L.getLocal("pC1"),Y=L.getLocal("pR"),rt=L.i32_add(L.getLocal("pR"),L.i32_const(f*2)),ht=L.i32_add(L.getLocal("pR"),L.i32_const(f*4)),pt=L.i32_const(t.alloc(f*2)),dt=L.i32_const(t.alloc(f*2));p.addCode(L.call(y+"_add",H,tt,pt),L.call(y+"_add",tt,N,dt),L.call(y+"_mul",tt,et,ht),L.call(y+"_mul",dt,et,Y),L.call(y+"_sub",Y,ht,Y),L.call(y+"_mulNR",Y,Y),L.call(y+"_mul",pt,et,rt),L.call(y+"_sub",rt,ht,rt))}wt();function ft(){const p=t.addFunction(V+"_mul01");p.addParam("pA","i32"),p.addParam("pC0","i32"),p.addParam("pC1","i32"),p.addParam("pR","i32");const L=p.getCodeBuilder(),H=L.getLocal("pA"),tt=L.i32_add(L.getLocal("pA"),L.i32_const(f*2)),N=L.i32_add(L.getLocal("pA"),L.i32_const(f*4)),et=L.getLocal("pC0"),Y=L.getLocal("pC1"),rt=L.getLocal("pR"),ht=L.i32_add(L.getLocal("pR"),L.i32_const(f*2)),pt=L.i32_add(L.getLocal("pR"),L.i32_const(f*4)),dt=L.i32_const(t.alloc(f*2)),Lt=L.i32_const(t.alloc(f*2)),Et=L.i32_const(t.alloc(f*2)),vt=L.i32_const(t.alloc(f*2));p.addCode(L.call(y+"_mul",H,et,dt),L.call(y+"_mul",tt,Y,Lt),L.call(y+"_add",H,tt,Et),L.call(y+"_add",H,N,vt),L.call(y+"_add",tt,N,rt),L.call(y+"_mul",rt,Y,rt),L.call(y+"_sub",rt,Lt,rt),L.call(y+"_mulNR",rt,rt),L.call(y+"_add",rt,dt,rt),L.call(y+"_add",et,Y,ht),L.call(y+"_mul",ht,Et,ht),L.call(y+"_sub",ht,dt,ht),L.call(y+"_sub",ht,Lt,ht),L.call(y+"_mul",vt,et,pt),L.call(y+"_sub",pt,dt,pt),L.call(y+"_add",pt,Lt,pt))}ft();function st(){const p=t.addFunction(R+"_mul014");p.addParam("pA","i32"),p.addParam("pC0","i32"),p.addParam("pC1","i32"),p.addParam("pC4","i32"),p.addParam("pR","i32");const L=p.getCodeBuilder(),H=L.getLocal("pA"),tt=L.i32_add(L.getLocal("pA"),L.i32_const(f*6)),N=L.getLocal("pC0"),et=L.getLocal("pC1"),Y=L.getLocal("pC4"),rt=L.i32_const(t.alloc(f*6)),ht=L.i32_const(t.alloc(f*6)),pt=L.i32_const(t.alloc(f*2)),dt=L.getLocal("pR"),Lt=L.i32_add(L.getLocal("pR"),L.i32_const(f*6));p.addCode(L.call(V+"_mul01",H,N,et,rt),L.call(V+"_mul1",tt,Y,ht),L.call(y+"_add",et,Y,pt),L.call(V+"_add",tt,H,Lt),L.call(V+"_mul01",Lt,N,pt,Lt),L.call(V+"_sub",Lt,rt,Lt),L.call(V+"_sub",Lt,ht,Lt),L.call(V+"_copy",ht,dt),L.call(V+"_mulNR",dt,dt),L.call(V+"_add",dt,rt,dt))}st();function ct(){const p=t.addFunction(a+"_ell");p.addParam("pP","i32"),p.addParam("pCoefs","i32"),p.addParam("pF","i32");const L=p.getCodeBuilder(),H=L.getLocal("pP"),tt=L.i32_add(L.getLocal("pP"),L.i32_const(s)),N=L.getLocal("pF"),et=L.getLocal("pCoefs"),Y=L.i32_add(L.getLocal("pCoefs"),L.i32_const(f)),rt=L.i32_add(L.getLocal("pCoefs"),L.i32_const(f*2)),ht=L.i32_add(L.getLocal("pCoefs"),L.i32_const(f*3)),pt=L.i32_add(L.getLocal("pCoefs"),L.i32_const(f*4)),dt=t.alloc(f*2),Lt=L.i32_const(dt),Et=L.i32_const(dt),vt=L.i32_const(dt+f),mt=t.alloc(f*2),Bt=L.i32_const(mt),It=L.i32_const(mt),$t=L.i32_const(mt+f);p.addCode(L.call(x+"_mul",et,tt,Et),L.call(x+"_mul",Y,tt,vt),L.call(x+"_mul",rt,H,It),L.call(x+"_mul",ht,H,$t),L.call(R+"_mul014",N,pt,Bt,Lt,N))}ct();function gt(){const p=t.addFunction(a+"_millerLoop");p.addParam("ppreP","i32"),p.addParam("ppreQ","i32"),p.addParam("r","i32"),p.addLocal("pCoef","i32"),p.addLocal("i","i32");const L=p.getCodeBuilder(),H=L.getLocal("ppreP"),tt=L.getLocal("pCoef"),N=L.getLocal("r");p.addCode(L.call(R+"_one",N),L.if(L.call(F+"_isZero",H),L.ret([])),L.if(L.call(F+"_isZero",L.getLocal("ppreQ")),L.ret([])),L.setLocal("pCoef",L.i32_add(L.getLocal("ppreQ"),L.i32_const(r*3))),L.setLocal("i",L.i32_const(J.length-2)),L.block(L.loop(L.call(a+"_ell",H,tt,N),L.setLocal("pCoef",L.i32_add(L.getLocal("pCoef"),L.i32_const(K))),L.if(L.i32_load8_s(L.getLocal("i"),k),[...L.call(a+"_ell",H,tt,N),...L.setLocal("pCoef",L.i32_add(L.getLocal("pCoef"),L.i32_const(K)))]),L.call(R+"_square",N,N),L.br_if(1,L.i32_eq(L.getLocal("i"),L.i32_const(1))),L.setLocal("i",L.i32_sub(L.getLocal("i"),L.i32_const(1))),L.br(0))),L.call(a+"_ell",H,tt,N)),p.addCode(L.call(R+"_conjugate",N,N))}function yt(p){const L=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n,151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n,0n],[2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n,877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],[4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n,0n],[151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n,3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n,2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n,0n],[877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n,3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]]],H=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[0n,4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[0n,1n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[0n,793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]],[[1n,0n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n,0n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n,0n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n,0n]]],tt=t.addFunction(R+"_frobeniusMap"+p);tt.addParam("x","i32"),tt.addParam("r","i32");const N=tt.getCodeBuilder();for(let Y=0;Y<6;Y++){const rt=Y==0?N.getLocal("x"):N.i32_add(N.getLocal("x"),N.i32_const(Y*r)),ht=rt,pt=N.i32_add(N.getLocal("x"),N.i32_const(Y*r+f)),dt=Y==0?N.getLocal("r"):N.i32_add(N.getLocal("r"),N.i32_const(Y*r)),Lt=dt,Et=N.i32_add(N.getLocal("r"),N.i32_const(Y*r+f)),vt=et(L[Math.floor(Y/3)][p%12],H[Y%3][p%6]),mt=t.alloc([...Ot.bigInt2BytesLE(C(vt[0]),s),...Ot.bigInt2BytesLE(C(vt[1]),s)]);p%2==1?tt.addCode(N.call(x+"_copy",ht,Lt),N.call(x+"_neg",pt,Et),N.call(y+"_mul",dt,N.i32_const(mt),dt)):tt.addCode(N.call(y+"_mul",rt,N.i32_const(mt),dt))}function et(Y,rt){const ht=Y[0],pt=Y[1],dt=rt[0],Lt=rt[1],Et=[(ht*dt-pt*Lt)%i,(ht*Lt+pt*dt)%i];return tl(Et[0])&&(Et[0]=Et[0]+i),Et}}function xt(){const p=t.addFunction(a+"__cyclotomicSquare");p.addParam("x","i32"),p.addParam("r","i32");const L=p.getCodeBuilder(),H=L.getLocal("x"),tt=L.i32_add(L.getLocal("x"),L.i32_const(r)),N=L.i32_add(L.getLocal("x"),L.i32_const(2*r)),et=L.i32_add(L.getLocal("x"),L.i32_const(3*r)),Y=L.i32_add(L.getLocal("x"),L.i32_const(4*r)),rt=L.i32_add(L.getLocal("x"),L.i32_const(5*r)),ht=L.getLocal("r"),pt=L.i32_add(L.getLocal("r"),L.i32_const(r)),dt=L.i32_add(L.getLocal("r"),L.i32_const(2*r)),Lt=L.i32_add(L.getLocal("r"),L.i32_const(3*r)),Et=L.i32_add(L.getLocal("r"),L.i32_const(4*r)),vt=L.i32_add(L.getLocal("r"),L.i32_const(5*r)),mt=L.i32_const(t.alloc(r)),Bt=L.i32_const(t.alloc(r)),It=L.i32_const(t.alloc(r)),$t=L.i32_const(t.alloc(r)),Gt=L.i32_const(t.alloc(r)),Tt=L.i32_const(t.alloc(r)),At=L.i32_const(t.alloc(r)),Xt=L.i32_const(t.alloc(r));p.addCode(L.call(y+"_mul",H,Y,At),L.call(y+"_mulNR",Y,mt),L.call(y+"_add",H,mt,mt),L.call(y+"_add",H,Y,Xt),L.call(y+"_mul",Xt,mt,mt),L.call(y+"_mulNR",At,Xt),L.call(y+"_add",At,Xt,Xt),L.call(y+"_sub",mt,Xt,mt),L.call(y+"_add",At,At,Bt),L.call(y+"_mul",et,N,At),L.call(y+"_mulNR",N,It),L.call(y+"_add",et,It,It),L.call(y+"_add",et,N,Xt),L.call(y+"_mul",Xt,It,It),L.call(y+"_mulNR",At,Xt),L.call(y+"_add",At,Xt,Xt),L.call(y+"_sub",It,Xt,It),L.call(y+"_add",At,At,$t),L.call(y+"_mul",tt,rt,At),L.call(y+"_mulNR",rt,Gt),L.call(y+"_add",tt,Gt,Gt),L.call(y+"_add",tt,rt,Xt),L.call(y+"_mul",Xt,Gt,Gt),L.call(y+"_mulNR",At,Xt),L.call(y+"_add",At,Xt,Xt),L.call(y+"_sub",Gt,Xt,Gt),L.call(y+"_add",At,At,Tt),L.call(y+"_sub",mt,H,ht),L.call(y+"_add",ht,ht,ht),L.call(y+"_add",mt,ht,ht),L.call(y+"_add",Bt,Y,Et),L.call(y+"_add",Et,Et,Et),L.call(y+"_add",Bt,Et,Et),L.call(y+"_mul",Tt,L.i32_const(Q),Xt),L.call(y+"_add",Xt,et,Lt),L.call(y+"_add",Lt,Lt,Lt),L.call(y+"_add",Xt,Lt,Lt),L.call(y+"_sub",Gt,N,dt),L.call(y+"_add",dt,dt,dt),L.call(y+"_add",Gt,dt,dt),L.call(y+"_sub",It,tt,pt),L.call(y+"_add",pt,pt,pt),L.call(y+"_add",It,pt,pt),L.call(y+"_add",$t,rt,vt),L.call(y+"_add",vt,vt,vt),L.call(y+"_add",$t,vt,vt))}function Rt(p,L,H){const tt=z(p).map(dt=>dt==-1?255:dt),N=t.alloc(tt),et=t.addFunction(a+"__cyclotomicExp_"+H);et.addParam("x","i32"),et.addParam("r","i32"),et.addLocal("bit","i32"),et.addLocal("i","i32");const Y=et.getCodeBuilder(),rt=Y.getLocal("x"),ht=Y.getLocal("r"),pt=Y.i32_const(t.alloc(c));et.addCode(Y.call(R+"_conjugate",rt,pt),Y.call(R+"_one",ht),Y.if(Y.teeLocal("bit",Y.i32_load8_s(Y.i32_const(tt.length-1),N)),Y.if(Y.i32_eq(Y.getLocal("bit"),Y.i32_const(1)),Y.call(R+"_mul",ht,rt,ht),Y.call(R+"_mul",ht,pt,ht))),Y.setLocal("i",Y.i32_const(tt.length-2)),Y.block(Y.loop(Y.call(a+"__cyclotomicSquare",ht,ht),Y.if(Y.teeLocal("bit",Y.i32_load8_s(Y.getLocal("i"),N)),Y.if(Y.i32_eq(Y.getLocal("bit"),Y.i32_const(1)),Y.call(R+"_mul",ht,rt,ht),Y.call(R+"_mul",ht,pt,ht))),Y.br_if(1,Y.i32_eqz(Y.getLocal("i"))),Y.setLocal("i",Y.i32_sub(Y.getLocal("i"),Y.i32_const(1))),Y.br(0)))),et.addCode(Y.call(R+"_conjugate",ht,ht))}function Vt(){xt(),Rt(m,G,"w0");const p=t.addFunction(a+"_finalExponentiation");p.addParam("x","i32"),p.addParam("r","i32");const L=p.getCodeBuilder(),H=L.getLocal("x"),tt=L.getLocal("r"),N=L.i32_const(t.alloc(c)),et=L.i32_const(t.alloc(c)),Y=L.i32_const(t.alloc(c)),rt=L.i32_const(t.alloc(c)),ht=L.i32_const(t.alloc(c)),pt=L.i32_const(t.alloc(c)),dt=L.i32_const(t.alloc(c));p.addCode(L.call(R+"_frobeniusMap6",H,N),L.call(R+"_inverse",H,et),L.call(R+"_mul",N,et,Y),L.call(R+"_copy",Y,et),L.call(R+"_frobeniusMap2",Y,Y),L.call(R+"_mul",Y,et,Y),L.call(a+"__cyclotomicSquare",Y,et),L.call(R+"_conjugate",et,et),L.call(a+"__cyclotomicExp_w0",Y,rt),L.call(a+"__cyclotomicSquare",rt,ht),L.call(R+"_mul",et,rt,pt),L.call(a+"__cyclotomicExp_w0",pt,et),L.call(a+"__cyclotomicExp_w0",et,N),L.call(a+"__cyclotomicExp_w0",N,dt),L.call(R+"_mul",dt,ht,dt),L.call(a+"__cyclotomicExp_w0",dt,ht),L.call(R+"_conjugate",pt,pt),L.call(R+"_mul",ht,pt,ht),L.call(R+"_mul",ht,Y,ht),L.call(R+"_conjugate",Y,pt),L.call(R+"_mul",et,Y,et),L.call(R+"_frobeniusMap3",et,et),L.call(R+"_mul",dt,pt,dt),L.call(R+"_frobeniusMap1",dt,dt),L.call(R+"_mul",rt,N,rt),L.call(R+"_frobeniusMap2",rt,rt),L.call(R+"_mul",rt,et,rt),L.call(R+"_mul",rt,dt,rt),L.call(R+"_mul",rt,ht,tt))}function jt(){const p=t.addFunction(a+"_finalExponentiationOld");p.addParam("x","i32"),p.addParam("r","i32");const H=t.alloc(Ot.bigInt2BytesLE(322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n,544)),tt=p.getCodeBuilder();p.addCode(tt.call(R+"_exp",tt.getLocal("x"),tt.i32_const(H),tt.i32_const(544),tt.getLocal("r")))}const Pt=t.alloc(h),bt=t.alloc(U);function kt(p){const L=t.addFunction(a+"_pairingEq"+p);for(let et=0;et<p;et++)L.addParam("p_"+et,"i32"),L.addParam("q_"+et,"i32");L.addParam("c","i32"),L.setReturnType("i32");const H=L.getCodeBuilder(),tt=H.i32_const(t.alloc(c)),N=H.i32_const(t.alloc(c));L.addCode(H.call(R+"_one",tt));for(let et=0;et<p;et++)L.addCode(H.call(a+"_prepareG1",H.getLocal("p_"+et),H.i32_const(Pt))),L.addCode(H.call(a+"_prepareG2",H.getLocal("q_"+et),H.i32_const(bt))),L.addCode(H.if(H.i32_eqz(H.call(F+"_inGroupAffine",H.i32_const(Pt))),H.ret(H.i32_const(0))),H.if(H.i32_eqz(H.call(P+"_inGroupAffine",H.i32_const(bt))),H.ret(H.i32_const(0)))),L.addCode(H.call(a+"_millerLoop",H.i32_const(Pt),H.i32_const(bt),N)),L.addCode(H.call(R+"_mul",tt,N,tt));L.addCode(H.call(a+"_finalExponentiation",tt,tt)),L.addCode(H.call(R+"_eq",tt,H.getLocal("c")))}function Jt(){const p=t.addFunction(a+"_pairing");p.addParam("p","i32"),p.addParam("q","i32"),p.addParam("r","i32");const L=p.getCodeBuilder(),H=L.i32_const(t.alloc(c));p.addCode(L.call(a+"_prepareG1",L.getLocal("p"),L.i32_const(Pt))),p.addCode(L.call(a+"_prepareG2",L.getLocal("q"),L.i32_const(bt))),p.addCode(L.call(a+"_millerLoop",L.i32_const(Pt),L.i32_const(bt),H)),p.addCode(L.call(a+"_finalExponentiation",H,L.getLocal("r")))}function Dt(){const p=t.addFunction(P+"_inGroupAffine");p.addParam("p","i32"),p.setReturnType("i32");const L=p.getCodeBuilder(),H=[2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n],tt=4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,N=[2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],et=L.i32_const(t.alloc([...Ot.bigInt2BytesLE(C(H[0]),s),...Ot.bigInt2BytesLE(C(H[1]),s)])),Y=L.i32_const(t.alloc(Ot.bigInt2BytesLE(C(tt),s))),rt=L.i32_const(t.alloc([...Ot.bigInt2BytesLE(C(N[0]),s),...Ot.bigInt2BytesLE(C(N[1]),s)])),ht=L.i32_const(t.alloc(Ot.bigInt2BytesLE(m,8))),pt=L.getLocal("p"),dt=L.i32_add(L.getLocal("p"),L.i32_const(r)),Lt=L.i32_const(t.alloc(f)),Et=L.i32_const(t.alloc(r)),vt=L.i32_const(t.alloc(r)),mt=t.alloc(r*2),Bt=L.i32_const(mt),It=L.i32_const(mt),$t=L.i32_const(mt),Gt=L.i32_const(mt+f),Tt=L.i32_const(mt+r),At=L.i32_const(mt+r),Xt=L.i32_const(mt+r+f),mn=t.alloc(r*3),Tn=L.i32_const(mn),Ms=L.i32_const(mn),ri=L.i32_const(mn),di=L.i32_const(mn+f),Us=L.i32_const(mn+r),ui=L.i32_const(mn+r),fi=L.i32_const(mn+r+f),Rs=L.i32_const(mn+r*2);p.addCode(L.if(L.call(P+"_isZeroAffine",L.getLocal("p")),L.ret(L.i32_const(1))),L.if(L.i32_eqz(L.call(P+"_inCurveAffine",L.getLocal("p"))),L.ret(L.i32_const(0))),L.call(y+"_mul",pt,et,Et),L.call(y+"_mul",dt,et,vt),L.call(y+"_mul1",Et,Y,It),L.call(y+"_neg",vt,Tt),L.call(y+"_neg",Et,Ms),L.call(y+"_mul",vt,rt,Us),L.call(x+"_sub",$t,Gt,Lt),L.call(x+"_add",$t,Gt,Gt),L.call(x+"_copy",Lt,$t),L.call(x+"_sub",At,Xt,Lt),L.call(x+"_add",At,Xt,Xt),L.call(x+"_copy",Lt,At),L.call(x+"_add",ri,di,Lt),L.call(x+"_sub",ri,di,di),L.call(x+"_copy",Lt,ri),L.call(x+"_sub",fi,ui,Lt),L.call(x+"_add",ui,fi,fi),L.call(x+"_copy",Lt,ui),L.call(y+"_one",Rs),L.call(P+"_timesScalar",Tn,ht,L.i32_const(8),Tn),L.call(P+"_addMixed",Tn,Bt,Tn),L.ret(L.call(P+"_eqMixed",Tn,L.getLocal("p"))));const ka=t.addFunction(P+"_inGroup");ka.addParam("pIn","i32"),ka.setReturnType("i32");const _a=ka.getCodeBuilder(),ve=_a.i32_const(t.alloc(r*2));ka.addCode(_a.call(P+"_toAffine",_a.getLocal("pIn"),ve),_a.ret(_a.call(P+"_inGroupAffine",ve)))}function ot(){const p=t.addFunction(F+"_inGroupAffine");p.addParam("p","i32"),p.setReturnType("i32");const L=p.getCodeBuilder(),H=4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,tt=793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,N=(m*m-1n)/3n,et=L.i32_const(t.alloc(Ot.bigInt2BytesLE(C(H),s))),Y=L.i32_const(t.alloc(Ot.bigInt2BytesLE(C(tt),s))),rt=L.i32_const(t.alloc(Ot.bigInt2BytesLE(N,16))),ht=L.getLocal("p"),pt=L.i32_add(L.getLocal("p"),L.i32_const(f)),dt=t.alloc(f*3),Lt=L.i32_const(dt),Et=L.i32_const(dt),vt=L.i32_const(dt+f),mt=t.alloc(f*2),Bt=L.i32_const(mt),It=L.i32_const(mt),$t=L.i32_const(mt+f);p.addCode(L.if(L.call(F+"_isZeroAffine",L.getLocal("p")),L.ret(L.i32_const(1))),L.if(L.i32_eqz(L.call(F+"_inCurveAffine",L.getLocal("p"))),L.ret(L.i32_const(0))),L.call(x+"_mul",ht,et,Et),L.call(x+"_copy",pt,vt),L.call(x+"_mul",ht,Y,It),L.call(x+"_copy",pt,$t),L.call(F+"_doubleAffine",Lt,Lt),L.call(F+"_subMixed",Lt,L.getLocal("p"),Lt),L.call(F+"_subMixed",Lt,Bt,Lt),L.call(F+"_timesScalar",Lt,rt,L.i32_const(16),Lt),L.ret(L.call(F+"_eqMixed",Lt,Bt)));const Gt=t.addFunction(F+"_inGroup");Gt.addParam("pIn","i32"),Gt.setReturnType("i32");const Tt=Gt.getCodeBuilder(),At=Tt.i32_const(t.alloc(f*2));Gt.addCode(Tt.call(F+"_toAffine",Tt.getLocal("pIn"),At),Tt.ret(Tt.call(F+"_inGroupAffine",At)))}for(let p=0;p<10;p++)yt(p),t.exportFunction(R+"_frobeniusMap"+p);ot(),Dt(),lt(),X(),it(),_t(),gt(),jt(),Vt();for(let p=1;p<=5;p++)kt(p),t.exportFunction(a+"_pairingEq"+p);Jt(),t.exportFunction(a+"_pairing"),t.exportFunction(a+"_prepareG1"),t.exportFunction(a+"_prepareG2"),t.exportFunction(a+"_millerLoop"),t.exportFunction(a+"_finalExponentiation"),t.exportFunction(a+"_finalExponentiationOld"),t.exportFunction(a+"__cyclotomicSquare"),t.exportFunction(a+"__cyclotomicExp_w0"),t.exportFunction(V+"_mul1"),t.exportFunction(V+"_mul01"),t.exportFunction(R+"_mul014"),t.exportFunction(F+"_inGroupAffine"),t.exportFunction(F+"_inGroup"),t.exportFunction(P+"_inGroupAffine"),t.exportFunction(P+"_inGroup")},al=Qc,il=nl;function Ui(e){if(typeof e=="bigint"||e.eq!==void 0)return e.toString(10);if(e instanceof Uint8Array)return Ta(e,0);if(Array.isArray(e))return e.map(Ui);if(typeof e=="object"){const t={};return Object.keys(e).forEach(a=>{t[a]=Ui(e[a])}),t}else return e}function Ri(e){if(typeof e=="string"&&/^[0-9]+$/.test(e))return BigInt(e);if(typeof e=="string"&&/^0x[0-9a-fA-F]+$/.test(e))return BigInt(e);if(Array.isArray(e))return e.map(Ri);if(typeof e=="object"){if(e===null)return null;const t={};return Object.keys(e).forEach(a=>{t[a]=Ri(e[a])}),t}else return e}function el(e){let t=BigInt(0),n=e.length,a=0;const i=new DataView(e.buffer,e.byteOffset,e.byteLength);for(;n>0;)n>=4?(n-=4,t+=BigInt(i.getUint32(n))<<BigInt(a*8),a+=4):n>=2?(n-=2,t+=BigInt(i.getUint16(n))<<BigInt(a*8),a+=2):(n-=1,t+=BigInt(i.getUint8(n))<<BigInt(a*8),a+=1);return t}function ol(e,t){let n=e;const a=new Uint8Array(t),i=new DataView(a.buffer);let o=t;for(;o>0;)o-4>=0?(o-=4,i.setUint32(o,Number(n&BigInt(4294967295))),n=n>>BigInt(32)):o-2>=0?(o-=2,i.setUint16(o,Number(n&BigInt(65535))),n=n>>BigInt(16)):(o-=1,i.setUint8(o,Number(n&BigInt(255))),n=n>>BigInt(8));if(n)throw new Error("Number does not fit in this length");return a}function sl(e){let t=BigInt(0),n=0;const a=new DataView(e.buffer,e.byteOffset,e.byteLength);for(;n<e.length;)n+4<=e.length?(t+=BigInt(a.getUint32(n,!0))<<BigInt(n*8),n+=4):n+2<=e.length?(t+=BigInt(a.getUint16(n,!0))<<BigInt(n*8),n+=2):(t+=BigInt(a.getUint8(n,!0))<<BigInt(n*8),n+=1);return t}function ko(e,t){let n=e;typeof t>"u"&&(t=Math.floor((Oa(e)-1)/8)+1,t==0&&(t=1));const a=new Uint8Array(t),i=new DataView(a.buffer);let o=0;for(;o<t;)o+4<=t?(i.setUint32(o,Number(n&BigInt(4294967295)),!0),o+=4,n=n>>BigInt(32)):o+2<=t?(i.setUint16(o,Number(n&BigInt(65535)),!0),o+=2,n=n>>BigInt(16)):(i.setUint8(o,Number(n&BigInt(255)),!0),o+=1,n=n>>BigInt(8));if(n)throw new Error("Number does not fit in this length");return a}function ki(e,t){if(typeof t=="bigint"||t.eq!==void 0)return t.toString(10);if(t instanceof Uint8Array)return e.toString(e.e(t));if(Array.isArray(t))return t.map(ki.bind(this,e));if(typeof t=="object"){const n={};return Object.keys(t).forEach(i=>{n[i]=ki(e,t[i])}),n}else return t}function $i(e,t){if(typeof t=="string"&&/^[0-9]+$/.test(t))return e.e(t);if(typeof t=="string"&&/^0x[0-9a-fA-F]+$/.test(t))return e.e(t);if(Array.isArray(t))return t.map($i.bind(this,e));if(typeof t=="object"){if(t===null)return null;const n={};return Object.keys(t).forEach(i=>{n[i]=$i(e,t[i])}),n}else return t}const Ca=[];for(let e=0;e<256;e++)Ca[e]=cl(e,8);function cl(e,t){let n=0,a=e;for(let i=0;i<t;i++)n<<=1,n=n|a&1,a>>=1;return n}function $o(e,t){return(Ca[e>>>24]|Ca[e>>>16&255]<<8|Ca[e>>>8&255]<<16|Ca[e&255]<<24)>>>32-t}function pn(e){return((e&4294901760)!==0?(e&=4294901760,16):0)|((e&4278255360)!==0?(e&=4278255360,8):0)|((e&4042322160)!==0?(e&=4042322160,4):0)|((e&3435973836)!==0?(e&=3435973836,2):0)|(e&2863311530)!==0}function No(e,t){const n=e.byteLength/t,a=pn(n);if(n!=1<<a)throw new Error("Invalid number of pointers");for(let i=0;i<n;i++){const o=$o(i,a);if(i>o){const l=e.slice(i*t,(i+1)*t);e.set(e.slice(o*t,(o+1)*t),i*t),e.set(l,o*t)}}}function _e(e,t){const n=new Uint8Array(t*e.length);for(let a=0;a<e.length;a++)n.set(e[a],a*t);return n}function Da(e,t){const n=e.byteLength/t,a=new Array(n);for(let i=0;i<n;i++)a[i]=e.slice(i*t,i*t+t);return a}var ll=Object.freeze({__proto__:null,array2buffer:_e,beBuff2int:el,beInt2Buff:ol,bitReverse:$o,buffReverseBits:No,buffer2array:Da,leBuff2int:sl,leInt2Buff:ko,log2:pn,stringifyBigInts:Ui,stringifyFElements:ki,unstringifyBigInts:Ri,unstringifyFElements:$i});const ln=1<<30;class ut{constructor(t){this.buffers=[],this.byteLength=t;for(let n=0;n<t;n+=ln){const a=Math.min(t-n,ln);this.buffers.push(new Uint8Array(a))}}slice(t,n){n===void 0&&(n=this.byteLength),t===void 0&&(t=0);const a=n-t,i=Math.floor(t/ln),o=Math.floor((t+a-1)/ln);if(i==o||a==0)return this.buffers[i].slice(t%ln,t%ln+a);let l,s=i,f=t%ln,r=a;for(;r>0;){const c=f+r>ln?ln-f:r,u=new Uint8Array(this.buffers[s].buffer,this.buffers[s].byteOffset+f,c);if(c==a)return u.slice();l||(a<=ln?l=new Uint8Array(a):l=new ut(a)),l.set(u,a-r),r=r-c,s++,f=0}return l}set(t,n){n===void 0&&(n=0);const a=t.byteLength;if(a==0)return;const i=Math.floor(n/ln),o=Math.floor((n+a-1)/ln);if(i==o)return t instanceof ut&&t.buffers.length==1?this.buffers[i].set(t.buffers[0],n%ln):this.buffers[i].set(t,n%ln);let l=i,s=n%ln,f=a;for(;f>0;){const r=s+f>ln?ln-s:f,c=t.slice(a-f,a-f+r);new Uint8Array(this.buffers[l].buffer,this.buffers[l].byteOffset+s,r).set(c),f=f-r,l++,s=0}}}function Mn(e,t,n,a){return async function(o){const l=Math.floor(o.byteLength/n);if(l*n!==o.byteLength)throw new Error("Invalid buffer size");const s=Math.floor(l/e.concurrency),f=[];for(let b=0;b<e.concurrency;b++){let w;if(b<e.concurrency-1?w=s:w=l-b*s,w==0)continue;const x=[{cmd:"ALLOCSET",var:0,buff:o.slice(b*s*n,b*s*n+w*n)},{cmd:"ALLOC",var:1,len:a*w},{cmd:"CALL",fnName:t,params:[{var:0},{val:w},{var:1}]},{cmd:"GET",out:0,var:1,len:a*w}];f.push(e.queueAction(x))}const r=await Promise.all(f);let c;o instanceof ut?c=new ut(l*a):c=new Uint8Array(l*a);let u=0;for(let b=0;b<r.length;b++)c.set(r[b][0],u),u+=r[b][0].byteLength;return c}}class Ne{constructor(t,n,a,i){if(this.tm=t,this.prefix=n,this.p=i,this.n8=a,this.type="F1",this.m=1,this.half=na(i,jn),this.bitLength=Oa(i),this.mask=Gn(Wa(jn,this.bitLength),jn),this.pOp1=t.alloc(a),this.pOp2=t.alloc(a),this.pOp3=t.alloc(a),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=this.tm.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.n64=Math.floor(a/8),this.n32=Math.floor(a/4),this.n64*8!=this.n8)throw new Error("n8 must be a multiple of 8");this.half=na(this.p,jn),this.nqr=this.two;let o=this.exp(this.nqr,this.half);for(;!this.eq(o,this.negone);)this.nqr=this.add(this.nqr,this.one),o=this.exp(this.nqr,this.half);this.shift=this.mul(this.nqr,this.nqr),this.shiftInv=this.inv(this.shift),this.s=0;let l=Gn(this.p,jn);for(;!ae(l);)this.s=this.s+1,l=na(l,jn);this.w=[],this.w[this.s]=this.exp(this.nqr,l);for(let s=this.s-1;s>=0;s--)this.w[s]=this.square(this.w[s+1]);if(!this.eq(this.w[0],this.one))throw new Error("Error calculating roots of unity");this.batchToMontgomery=Mn(t,n+"_batchToMontgomery",this.n8,this.n8),this.batchFromMontgomery=Mn(t,n+"_batchFromMontgomery",this.n8,this.n8)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){return this.op2("_add",t,n)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=oa(en(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}isNegative(t){return this.op1Bool("_isNegative",t)}e(t,n){if(t instanceof Uint8Array)return t;let a=en(t,n);po(a)?(a=mo(a),Mi(a,this.p)&&(a=vn(a,this.p)),a=Gn(this.p,a)):Mi(a,this.p)&&(a=vn(a,this.p));const i=ko(a,this.n8);return this.toMontgomery(i)}toString(t,n){const a=this.fromMontgomery(t),i=Ta(a,0);return oe(i,n)}fromRng(t){let n;const a=new Uint8Array(this.n8);do{n=So;for(let i=0;i<this.n64;i++)n=ie(n,Wa(t.nextU64(),64*i));n=ee(n,this.mask)}while(yo(n,this.p));return Ga(a,0,n,this.n8),a}random(){return this.fromRng(se())}toObject(t){const n=this.fromMontgomery(t);return Ta(n,0)}fromObject(t){const n=new Uint8Array(this.n8);return Ga(n,0,t,this.n8),this.toMontgomery(n)}toRprLE(t,n,a){t.set(this.fromMontgomery(a),n)}toRprBE(t,n,a){const i=this.fromMontgomery(a);for(let o=0;o<this.n8/2;o++){const l=i[o];i[o]=i[this.n8-1-o],i[this.n8-1-o]=l}t.set(i,n)}fromRprLE(t,n){n=n||0;const a=t.slice(n,n+this.n8);return this.toMontgomery(a)}async batchInverse(t){let n=!1;const a=this.n8,i=this.n8;Array.isArray(t)?(t=_e(t,a),n=!0):t=t.slice(0,t.byteLength);const o=Math.floor(t.byteLength/a);if(o*a!==t.byteLength)throw new Error("Invalid buffer size");const l=Math.floor(o/this.tm.concurrency),s=[];for(let u=0;u<this.tm.concurrency;u++){let b;if(u<this.tm.concurrency-1?b=l:b=o-u*l,b==0)continue;const A=[{cmd:"ALLOCSET",var:0,buff:t.slice(u*l*a,u*l*a+b*a)},{cmd:"ALLOC",var:1,len:i*b},{cmd:"CALL",fnName:this.prefix+"_batchInverse",params:[{var:0},{val:a},{val:b},{var:1},{val:i}]},{cmd:"GET",out:0,var:1,len:i*b}];s.push(this.tm.queueAction(A))}const f=await Promise.all(s);let r;t instanceof ut?r=new ut(o*i):r=new Uint8Array(o*i);let c=0;for(let u=0;u<f.length;u++)r.set(f[u][0],c),c+=f[u][0].byteLength;return n?Da(r,i):r}}class Ve{constructor(t,n,a){this.tm=t,this.prefix=n,this.F=a,this.type="F2",this.m=a.m*2,this.n8=this.F.n8*2,this.n32=this.F.n32*2,this.n64=this.F.n64*2,this.pOp1=t.alloc(a.n8*2),this.pOp2=t.alloc(a.n8*2),this.pOp3=t.alloc(a.n8*2),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){return this.op2("_add",t,n)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}mul1(t,n){return this.op2("_mul1",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=oa(en(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}e(t,n){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&t.length==2){const a=this.F.e(t[0],n),i=this.F.e(t[1],n),o=new Uint8Array(this.F.n8*2);return o.set(a),o.set(i,this.F.n8*2),o}else throw new Error("invalid F2")}toString(t,n){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8),n);return`[${a}, ${i}]`}fromRng(t){const n=this.F.fromRng(t),a=this.F.fromRng(t),i=new Uint8Array(this.F.n8*2);return i.set(n),i.set(a,this.F.n8),i}random(){return this.fromRng(se())}toObject(t){const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2));return[n,a]}fromObject(t){const n=new Uint8Array(this.F.n8*2),a=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]);return n.set(a),n.set(i,this.F.n8),n}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8)}}class rl{constructor(t,n,a){this.tm=t,this.prefix=n,this.F=a,this.type="F3",this.m=a.m*3,this.n8=this.F.n8*3,this.n32=this.F.n32*3,this.n64=this.F.n64*3,this.pOp1=t.alloc(a.n8*3),this.pOp2=t.alloc(a.n8*3),this.pOp3=t.alloc(a.n8*3),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}add(t,n){return this.op2("_add",t,n)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=oa(en(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.getBuff(this.pOp3,this.n8)}e(t,n){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&t.length==3){const a=this.F.e(t[0],n),i=this.F.e(t[1],n),o=this.F.e(t[2],n),l=new Uint8Array(this.F.n8*3);return l.set(a),l.set(i,this.F.n8),l.set(o,this.F.n8*2),l}else throw new Error("invalid F3")}toString(t,n){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8,this.F.n8*2),n),o=this.F.toString(t.slice(this.F.n8*2),n);return`[${a}, ${i}, ${o}]`}fromRng(t){const n=this.F.fromRng(t),a=this.F.fromRng(t),i=this.F.fromRng(t),o=new Uint8Array(this.F.n8*3);return o.set(n),o.set(a,this.F.n8),o.set(i,this.F.n8*2),o}random(){return this.fromRng(se())}toObject(t){const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2)),i=this.F.toObject(t.slice(this.F.n8*2,this.F.n8*3));return[n,a,i]}fromObject(t){const n=new Uint8Array(this.F.n8*3),a=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]),o=this.F.fromObject(t[2]);return n.set(a),n.set(i,this.F.n8),n.set(o,this.F.n8*2),n}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8,this.F.n8*2)}c3(t){return t.slice(this.F.n8*2)}}class Ze{constructor(t,n,a,i,o,l){this.tm=t,this.prefix=n,this.F=a,this.pOp1=t.alloc(a.n8*3),this.pOp2=t.alloc(a.n8*3),this.pOp3=t.alloc(a.n8*3),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,a.n8*3),this.tm.instance.exports[n+"_zeroAffine"](this.pOp1),this.zeroAffine=this.tm.getBuff(this.pOp1,a.n8*2),this.one=this.tm.getBuff(i,a.n8*3),this.g=this.one,this.oneAffine=this.tm.getBuff(i,a.n8*2),this.gAffine=this.oneAffine,this.b=this.tm.getBuff(o,a.n8),l&&(this.cofactor=oa(l)),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.batchLEMtoC=Mn(t,n+"_batchLEMtoC",a.n8*2,a.n8),this.batchLEMtoU=Mn(t,n+"_batchLEMtoU",a.n8*2,a.n8*2),this.batchCtoLEM=Mn(t,n+"_batchCtoLEM",a.n8,a.n8*2),this.batchUtoLEM=Mn(t,n+"_batchUtoLEM",a.n8*2,a.n8*2),this.batchToJacobian=Mn(t,n+"_batchToJacobian",a.n8*2,a.n8*3),this.batchToAffine=Mn(t,n+"_batchToAffine",a.n8*3,a.n8*2)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}op2bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}op1Affine(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*2)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2("_add",t,n);if(n.byteLength==this.F.n8*2)return this.op2("_addMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2("_addMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2("_addAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}sub(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2("_sub",t,n);if(n.byteLength==this.F.n8*2)return this.op2("_subMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2("_subMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2("_subAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}neg(t){if(t.byteLength==this.F.n8*3)return this.op1("_neg",t);if(t.byteLength==this.F.n8*2)return this.op1Affine("_negAffine",t);throw new Error("invalid point size")}double(t){if(t.byteLength==this.F.n8*3)return this.op1("_double",t);if(t.byteLength==this.F.n8*2)return this.op1("_doubleAffine",t);throw new Error("invalid point size")}isZero(t){if(t.byteLength==this.F.n8*3)return this.op1Bool("_isZero",t);if(t.byteLength==this.F.n8*2)return this.op1Bool("_isZeroAffine",t);throw new Error("invalid point size")}timesScalar(t,n){n instanceof Uint8Array||(n=oa(en(n)));let a;if(t.byteLength==this.F.n8*3)a=this.prefix+"_timesScalar";else if(t.byteLength==this.F.n8*2)a=this.prefix+"_timesScalarAffine";else throw new Error("invalid point size");return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[a](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}timesFr(t,n){let a;if(t.byteLength==this.F.n8*3)a=this.prefix+"_timesFr";else if(t.byteLength==this.F.n8*2)a=this.prefix+"_timesFrAffine";else throw new Error("invalid point size");return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}eq(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2bool("_eq",t,n);if(n.byteLength==this.F.n8*2)return this.op2bool("_eqMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2bool("_eqMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2bool("_eqAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}toAffine(t){if(t.byteLength==this.F.n8*3)return this.op1Affine("_toAffine",t);if(t.byteLength==this.F.n8*2)return t;throw new Error("invalid point size")}toJacobian(t){if(t.byteLength==this.F.n8*3)return t;if(t.byteLength==this.F.n8*2)return this.op1("_toJacobian",t);throw new Error("invalid point size")}toRprUncompressed(t,n,a){if(this.tm.setBuff(this.pOp1,a),a.byteLength==this.F.n8*3)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(a.byteLength!=this.F.n8*2)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoU"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8*2);t.set(i,n)}fromRprUncompressed(t,n){const a=t.slice(n,n+this.F.n8*2);return this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_UtoLEM"](this.pOp1,this.pOp1),this.tm.getBuff(this.pOp1,this.F.n8*2)}toRprCompressed(t,n,a){if(this.tm.setBuff(this.pOp1,a),a.byteLength==this.F.n8*3)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(a.byteLength!=this.F.n8*2)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoC"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8);t.set(i,n)}fromRprCompressed(t,n){const a=t.slice(n,n+this.F.n8);return this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_CtoLEM"](this.pOp1,this.pOp2),this.tm.getBuff(this.pOp2,this.F.n8*2)}toUncompressed(t){const n=new Uint8Array(this.F.n8*2);return this.toRprUncompressed(n,0,t),n}toRprLEM(t,n,a){if(a.byteLength==this.F.n8*2){t.set(a,n);return}else if(a.byteLength==this.F.n8*3){this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8*2);t.set(i,n)}else throw new Error("invalid point size")}fromRprLEM(t,n){return n=n||0,t.slice(n,n+this.F.n8*2)}toString(t,n){if(t.byteLength==this.F.n8*3){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8,this.F.n8*2),n),o=this.F.toString(t.slice(this.F.n8*2),n);return`[ ${a}, ${i}, ${o} ]`}else if(t.byteLength==this.F.n8*2){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8),n);return`[ ${a}, ${i} ]`}else throw new Error("invalid point size")}isValid(t){if(this.isZero(t))return!0;const n=this.F,a=this.toAffine(t),i=a.slice(0,this.F.n8),o=a.slice(this.F.n8,this.F.n8*2),l=n.add(n.mul(n.square(i),i),this.b),s=n.square(o);return n.eq(l,s)}fromRng(t){const n=this.F;let a=[],i,o;do a[0]=n.fromRng(t),i=t.nextBool(),o=n.add(n.mul(n.square(a[0]),a[0]),this.b);while(!n.isSquare(o));a[1]=n.sqrt(o);const l=n.isNegative(a[1]);i^l&&(a[1]=n.neg(a[1]));let s=new Uint8Array(this.F.n8*2);return s.set(a[0]),s.set(a[1],this.F.n8),this.cofactor&&(s=this.timesScalar(s,this.cofactor)),s}toObject(t){if(this.isZero(t))return[this.F.toObject(this.F.zero),this.F.toObject(this.F.one),this.F.toObject(this.F.zero)];const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2));let i;return t.byteLength==this.F.n8*3?i=this.F.toObject(t.slice(this.F.n8*2,this.F.n8*3)):i=this.F.toObject(this.F.one),[n,a,i]}fromObject(t){const n=this.F.fromObject(t[0]),a=this.F.fromObject(t[1]);let i;if(t.length==3?i=this.F.fromObject(t[2]):i=this.F.one,this.F.isZero(i,this.F.one))return this.zeroAffine;if(this.F.eq(i,this.F.one)){const o=new Uint8Array(this.F.n8*2);return o.set(n),o.set(a,this.F.n8),o}else{const o=new Uint8Array(this.F.n8*3);return o.set(n),o.set(a,this.F.n8),o.set(i,this.F.n8*2),o}}e(t){return t instanceof Uint8Array?t:this.fromObject(t)}x(t){return this.toAffine(t).slice(0,this.F.n8)}y(t){return this.toAffine(t).slice(this.F.n8)}}function dl(e){let n,a;async function i(c){const u=new Uint8Array(c.code),b=await WebAssembly.compile(u);a=new WebAssembly.Memory({initial:c.init,maximum:32767}),n=await WebAssembly.instantiate(b,{env:{memory:a}})}function o(c){const u=new Uint32Array(a.buffer,0,1);for(;u[0]&3;)u[0]++;const b=u[0];if(u[0]+=c,u[0]+c>a.buffer.byteLength){const w=a.buffer.byteLength/65536;let A=Math.floor((u[0]+c)/65536)+1;A>32767&&(A=32767),a.grow(A-w)}return b}function l(c){const u=o(c.byteLength);return f(u,c),u}function s(c,u){const b=new Uint8Array(a.buffer);return new Uint8Array(b.buffer,b.byteOffset+c,u)}function f(c,u){new Uint8Array(a.buffer).set(new Uint8Array(u),c)}function r(c){if(c[0].cmd=="INIT")return i(c[0]);const u={vars:[],out:[]},w=new Uint32Array(a.buffer,0,1)[0];for(let x=0;x<c.length;x++)switch(c[x].cmd){case"ALLOCSET":u.vars[c[x].var]=l(c[x].buff);break;case"ALLOC":u.vars[c[x].var]=o(c[x].len);break;case"SET":f(u.vars[c[x].var],c[x].buff);break;case"CALL":{const v=[];for(let F=0;F<c[x].params.length;F++){const y=c[x].params[F];typeof y.var<"u"?v.push(u.vars[y.var]+(y.offset||0)):typeof y.val<"u"&&v.push(y.val)}n.exports[c[x].fnName](...v);break}case"GET":u.out[c[x].out]=s(u.vars[c[x].var],c[x].len).slice();break;default:throw new Error("Invalid cmd")}const A=new Uint32Array(a.buffer,0,1);return A[0]=w,u.out}return r}const mi=25;class je{constructor(){this.promise=new Promise((t,n)=>{this.reject=n,this.resolve=t})}}function ul(e){return new Promise(t=>setTimeout(t,e))}let Ni;const He=`(function thread(self) {
    const MAXMEM = 32767;
    let instance;
    let memory;

    if (self) {
        self.onmessage = function(e) {
            let data;
            if (e.data) {
                data = e.data;
            } else {
                data = e;
            }

            if (data[0].cmd == "INIT") {
                init(data[0]).then(function() {
                    self.postMessage(data.result);
                });
            } else if (data[0].cmd == "TERMINATE") {
                self.close();
            } else {
                const res = runTask(data);
                self.postMessage(res);
            }
        };
    }

    async function init(data) {
        const code = new Uint8Array(data.code);
        const wasmModule = await WebAssembly.compile(code);
        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});

        instance = await WebAssembly.instantiate(wasmModule, {
            env: {
                "memory": memory
            }
        });
    }



    function alloc(length) {
        const u32 = new Uint32Array(memory.buffer, 0, 1);
        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers
        const res = u32[0];
        u32[0] += length;
        if (u32[0] + length > memory.buffer.byteLength) {
            const currentPages = memory.buffer.byteLength / 0x10000;
            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;
            if (requiredPages>MAXMEM) requiredPages=MAXMEM;
            memory.grow(requiredPages-currentPages);
        }
        return res;
    }

    function allocBuffer(buffer) {
        const p = alloc(buffer.byteLength);
        setBuffer(p, buffer);
        return p;
    }

    function getBuffer(pointer, length) {
        const u8 = new Uint8Array(memory.buffer);
        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
    }

    function setBuffer(pointer, buffer) {
        const u8 = new Uint8Array(memory.buffer);
        u8.set(new Uint8Array(buffer), pointer);
    }

    function runTask(task) {
        if (task[0].cmd == "INIT") {
            return init(task[0]);
        }
        const ctx = {
            vars: [],
            out: []
        };
        const u32a = new Uint32Array(memory.buffer, 0, 1);
        const oldAlloc = u32a[0];
        for (let i=0; i<task.length; i++) {
            switch (task[i].cmd) {
            case "ALLOCSET":
                ctx.vars[task[i].var] = allocBuffer(task[i].buff);
                break;
            case "ALLOC":
                ctx.vars[task[i].var] = alloc(task[i].len);
                break;
            case "SET":
                setBuffer(ctx.vars[task[i].var], task[i].buff);
                break;
            case "CALL": {
                const params = [];
                for (let j=0; j<task[i].params.length; j++) {
                    const p = task[i].params[j];
                    if (typeof p.var !== "undefined") {
                        params.push(ctx.vars[p.var] + (p.offset || 0));
                    } else if (typeof p.val != "undefined") {
                        params.push(p.val);
                    }
                }
                instance.exports[task[i].fnName](...params);
                break;
            }
            case "GET":
                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
                break;
            default:
                throw new Error("Invalid cmd");
            }
        }
        const u32b = new Uint32Array(memory.buffer, 0, 1);
        u32b[0] = oldAlloc;
        return ctx.out;
    }


    return runTask;
})(self)`;if(globalThis?.Blob){const e=new TextEncoder().encode(He),t=new Blob([e],{type:"application/javascript"});Ni=URL.createObjectURL(t)}else Ni="data:application/javascript;base64,"+globalThis.btoa(He);async function fl(e,t){const n=new _l;n.memory=new WebAssembly.Memory({initial:mi}),n.u8=new Uint8Array(n.memory.buffer),n.u32=new Uint32Array(n.memory.buffer);const a=await WebAssembly.compile(e.code);if(n.instance=await WebAssembly.instantiate(a,{env:{memory:n.memory}}),globalThis?.Worker||(t=!0),n.singleThread=t,n.initalPFree=n.u32[0],n.pq=e.pq,n.pr=e.pr,n.pG1gen=e.pG1gen,n.pG1zero=e.pG1zero,n.pG2gen=e.pG2gen,n.pG2zero=e.pG2zero,n.pOneT=e.pOneT,t)n.code=e.code,n.taskManager=dl(),await n.taskManager([{cmd:"INIT",init:mi,code:n.code.slice()}]),n.concurrency=1;else{n.workers=[],n.pendingDeferreds=[],n.working=[];let o=2;typeof navigator=="object"&&navigator.hardwareConcurrency&&(o=navigator.hardwareConcurrency),o==0&&(o=2),o>64&&(o=64),n.concurrency=o;for(let s=0;s<o;s++)n.workers[s]=new Worker(Ni),n.workers[s].addEventListener("message",i(s)),n.working[s]=!1;const l=[];for(let s=0;s<n.workers.length;s++){const f=e.code.slice();l.push(n.postAction(s,[{cmd:"INIT",init:mi,code:f}],[f.buffer]))}await Promise.all(l)}return n;function i(o){return function(l){let s;l&&l.data?s=l.data:s=l,n.working[o]=!1,n.pendingDeferreds[o].resolve(s),n.processWorks()}}}class _l{constructor(){this.actionQueue=[],this.oldPFree=0}startSyncOp(){if(this.oldPFree!=0)throw new Error("Sync operation in progress");this.oldPFree=this.u32[0]}endSyncOp(){if(this.oldPFree==0)throw new Error("No sync operation in progress");this.u32[0]=this.oldPFree,this.oldPFree=0}postAction(t,n,a,i){if(this.working[t])throw new Error("Posting a job t a working worker");return this.working[t]=!0,this.pendingDeferreds[t]=i||new je,this.workers[t].postMessage(n,a),this.pendingDeferreds[t].promise}processWorks(){for(let t=0;t<this.workers.length&&this.actionQueue.length>0;t++)if(this.working[t]==!1){const n=this.actionQueue.shift();this.postAction(t,n.data,n.transfers,n.deferred)}}queueAction(t,n){const a=new je;if(this.singleThread){const i=this.taskManager(t);a.resolve(i)}else this.actionQueue.push({data:t,transfers:n,deferred:a}),this.processWorks();return a.promise}resetMemory(){this.u32[0]=this.initalPFree}allocBuff(t){const n=this.alloc(t.byteLength);return this.setBuff(n,t),n}getBuff(t,n){return this.u8.slice(t,t+n)}setBuff(t,n){this.u8.set(new Uint8Array(n),t)}alloc(t){for(;this.u32[0]&3;)this.u32[0]++;const n=this.u32[0];return this.u32[0]+=t,n}async terminate(){for(let t=0;t<this.workers.length;t++)this.workers[t].postMessage([{cmd:"TERMINATE"}]);await ul(200)}}function bi(e,t){const n=e[t],a=e.Fr,i=e.tm;e[t].batchApplyKey=async function(o,l,s,f,r){f=f||"affine",r=r||"affine";let c,u,b,w,A;if(t=="G1")f=="jacobian"?(b=n.F.n8*3,c="g1m_batchApplyKey"):(b=n.F.n8*2,c="g1m_batchApplyKeyMixed"),w=n.F.n8*3,r=="jacobian"?A=n.F.n8*3:(u="g1m_batchToAffine",A=n.F.n8*2);else if(t=="G2")f=="jacobian"?(b=n.F.n8*3,c="g2m_batchApplyKey"):(b=n.F.n8*2,c="g2m_batchApplyKeyMixed"),w=n.F.n8*3,r=="jacobian"?A=n.F.n8*3:(u="g2m_batchToAffine",A=n.F.n8*2);else if(t=="Fr")c="frm_batchApplyKey",b=n.n8,w=n.n8,A=n.n8;else throw new Error("Invalid group: "+t);const x=Math.floor(o.byteLength/b),v=Math.floor(x/i.concurrency),F=[];s=a.e(s);let y=a.e(l);for(let C=0;C<i.concurrency;C++){let _;if(C<i.concurrency-1?_=v:_=x-C*v,_==0)continue;const g=[];g.push({cmd:"ALLOCSET",var:0,buff:o.slice(C*v*b,C*v*b+_*b)}),g.push({cmd:"ALLOCSET",var:1,buff:y}),g.push({cmd:"ALLOCSET",var:2,buff:s}),g.push({cmd:"ALLOC",var:3,len:_*Math.max(w,A)}),g.push({cmd:"CALL",fnName:c,params:[{var:0},{val:_},{var:1},{var:2},{var:3}]}),u&&g.push({cmd:"CALL",fnName:u,params:[{var:3},{val:_},{var:3}]}),g.push({cmd:"GET",out:0,var:3,len:_*A}),F.push(i.queueAction(g)),y=a.mul(y,a.exp(s,_))}const B=await Promise.all(F);let P;o instanceof ut?P=new ut(x*A):P=new Uint8Array(x*A);let T=0;for(let C=0;C<B.length;C++)P.set(B[C][0],T),T+=B[C][0].byteLength;return P}}function hl(e){const t=e.tm;e.pairing=function(a,i){t.startSyncOp();const o=t.allocBuff(e.G1.toJacobian(a)),l=t.allocBuff(e.G2.toJacobian(i)),s=t.alloc(e.Gt.n8);t.instance.exports[e.name+"_pairing"](o,l,s);const f=t.getBuff(s,e.Gt.n8);return t.endSyncOp(),f},e.pairingEq=async function(){let a,i;arguments.length%2==1?(a=arguments[arguments.length-1],i=(arguments.length-1)/2):(a=e.Gt.one,i=arguments.length/2);const o=[];for(let c=0;c<i;c++){const u=[],b=e.G1.toJacobian(arguments[c*2]);u.push({cmd:"ALLOCSET",var:0,buff:b}),u.push({cmd:"ALLOC",var:1,len:e.prePSize});const w=e.G2.toJacobian(arguments[c*2+1]);u.push({cmd:"ALLOCSET",var:2,buff:w}),u.push({cmd:"ALLOC",var:3,len:e.preQSize}),u.push({cmd:"ALLOC",var:4,len:e.Gt.n8}),u.push({cmd:"CALL",fnName:e.name+"_prepareG1",params:[{var:0},{var:1}]}),u.push({cmd:"CALL",fnName:e.name+"_prepareG2",params:[{var:2},{var:3}]}),u.push({cmd:"CALL",fnName:e.name+"_millerLoop",params:[{var:1},{var:3},{var:4}]}),u.push({cmd:"GET",out:0,var:4,len:e.Gt.n8}),o.push(t.queueAction(u))}const l=await Promise.all(o);t.startSyncOp();const s=t.alloc(e.Gt.n8);t.instance.exports.ftm_one(s);for(let c=0;c<l.length;c++){const u=t.allocBuff(l[c][0]);t.instance.exports.ftm_mul(s,u,s)}t.instance.exports[e.name+"_finalExponentiation"](s,s);const f=t.allocBuff(a),r=!!t.instance.exports.ftm_eq(s,f);return t.endSyncOp(),r},e.prepareG1=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.prePSize);this.tm.instance.exports[this.name+"_prepareG1"](a,i);const o=this.tm.getBuff(i,this.prePSize);return this.tm.endSyncOp(),o},e.prepareG2=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.preQSize);this.tm.instance.exports[this.name+"_prepareG2"](a,i);const o=this.tm.getBuff(i,this.preQSize);return this.tm.endSyncOp(),o},e.millerLoop=function(n,a){this.tm.startSyncOp();const i=this.tm.allocBuff(n),o=this.tm.allocBuff(a),l=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_millerLoop"](i,o,l);const s=this.tm.getBuff(l,this.Gt.n8);return this.tm.endSyncOp(),s},e.finalExponentiation=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_finalExponentiation"](a,i);const o=this.tm.getBuff(i,this.Gt.n8);return this.tm.endSyncOp(),o}}const We=[1,1,1,1,2,3,4,5,6,7,7,8,9,10,11,12,13,13,14,15,16,16,17,17,17,17,17,17,17,17,17,17];function Qe(e,t){const n=e[t],a=n.tm;async function i(l,s,f,r,c){if(!(l instanceof Uint8Array))throw r&&r.error(`${c} _multiExpChunk buffBases is not Uint8Array`),new Error(`${c} _multiExpChunk buffBases is not Uint8Array`);if(!(s instanceof Uint8Array))throw r&&r.error(`${c} _multiExpChunk buffScalars is not Uint8Array`),new Error(`${c} _multiExpChunk buffScalars is not Uint8Array`);f=f||"affine";let u,b;if(t=="G1")f=="affine"?(b="g1m_multiexpAffine_chunk",u=n.F.n8*2):(b="g1m_multiexp_chunk",u=n.F.n8*3);else if(t=="G2")f=="affine"?(b="g2m_multiexpAffine_chunk",u=n.F.n8*2):(b="g2m_multiexp_chunk",u=n.F.n8*3);else throw new Error("Invalid group");const w=Math.floor(l.byteLength/u);if(w==0)return n.zero;const A=Math.floor(s.byteLength/w);if(A*w!=s.byteLength)throw new Error("Scalar size does not match");const x=We[pn(w)],v=Math.floor((A*8-1)/x)+1,F=[];for(let P=0;P<v;P++){const T=[{cmd:"ALLOCSET",var:0,buff:l},{cmd:"ALLOCSET",var:1,buff:s},{cmd:"ALLOC",var:2,len:n.F.n8*3},{cmd:"CALL",fnName:b,params:[{var:0},{var:1},{val:A},{val:w},{val:P*x},{val:Math.min(A*8-P*x,x)},{var:2}]},{cmd:"GET",out:0,var:2,len:n.F.n8*3}];F.push(n.tm.queueAction(T))}const y=await Promise.all(F);let B=n.zero;for(let P=y.length-1;P>=0;P--){if(!n.isZero(B))for(let T=0;T<x;T++)B=n.double(B);B=n.add(B,y[P][0])}return B}async function o(l,s,f,r,c){let w;if(t=="G1")f=="affine"?w=n.F.n8*2:w=n.F.n8*3;else if(t=="G2")f=="affine"?w=n.F.n8*2:w=n.F.n8*3;else throw new Error("Invalid group");const A=Math.floor(l.byteLength/w);if(A==0)return n.zero;const x=Math.floor(s.byteLength/A);if(x*A!=s.byteLength)throw new Error("Scalar size does not match");const v=We[pn(A)],F=Math.floor((x*8-1)/v)+1;let y;y=Math.floor(A/(a.concurrency/F)),y>4194304&&(y=4194304),y<1024&&(y=1024);const B=[];for(let C=0;C<A;C+=y){r&&r.debug(`Multiexp start: ${c}: ${C}/${A}`);const _=Math.min(A-C,y),g=l.slice(C*w,(C+_)*w),$=s.slice(C*x,(C+_)*x);B.push(i(g,$,f,r,c).then(Z=>(r&&r.debug(`Multiexp end: ${c}: ${C}/${A}`),Z)))}const P=await Promise.all(B);let T=n.zero;for(let C=P.length-1;C>=0;C--)T=n.add(T,P[C]);return T}n.multiExp=async function(s,f,r,c){return await o(s,f,"jacobian",r,c)},n.multiExpAffine=async function(s,f,r,c){return await o(s,f,"affine",r,c)}}function yi(e,t){const n=e[t],a=e.Fr,i=n.tm;async function o(r,c,u,b,w,A){u=u||"affine",b=b||"affine";const x=14;let v,F,y,B,P,T,C,_;t=="G1"?(u=="affine"?(v=n.F.n8*2,B="g1m_batchToJacobian"):v=n.F.n8*3,F=n.F.n8*3,c&&(_="g1m_fftFinal"),C="g1m_fftJoin",T="g1m_fftMix",b=="affine"?(y=n.F.n8*2,P="g1m_batchToAffine"):y=n.F.n8*3):t=="G2"?(u=="affine"?(v=n.F.n8*2,B="g2m_batchToJacobian"):v=n.F.n8*3,F=n.F.n8*3,c&&(_="g2m_fftFinal"),C="g2m_fftJoin",T="g2m_fftMix",b=="affine"?(y=n.F.n8*2,P="g2m_batchToAffine"):y=n.F.n8*3):t=="Fr"&&(v=n.n8,F=n.n8,y=n.n8,c&&(_="frm_fftFinal"),T="frm_fftMix",C="frm_fftJoin");let g=!1;Array.isArray(r)?(r=_e(r,v),g=!0):r=r.slice(0,r.byteLength);const $=r.byteLength/v,Z=pn($);if(1<<Z!=$)throw new Error("fft must be multiple of 2");if(Z==a.s+1){let V;return c?V=await s(r,u,b,w,A):V=await l(r,u,b,w,A),g?Da(V,y):V}let j;c&&(j=a.inv(a.e($)));let O;No(r,v);let E,q=Math.min(1<<x,$),M=$/q;for(;M<i.concurrency&&q>=16;)M*=2,q/=2;const Q=pn(q),D=[];for(let V=0;V<M;V++){w&&w.debug(`${A}: fft ${Z} mix start: ${V}/${M}`);const nt=[];nt.push({cmd:"ALLOC",var:0,len:F*q});const R=r.slice(q*V*v,q*(V+1)*v);nt.push({cmd:"SET",var:0,buff:R}),B&&nt.push({cmd:"CALL",fnName:B,params:[{var:0},{val:q},{var:0}]});for(let at=1;at<=Q;at++)nt.push({cmd:"CALL",fnName:T,params:[{var:0},{val:q},{val:at}]});Q==Z?(_&&(nt.push({cmd:"ALLOCSET",var:1,buff:j}),nt.push({cmd:"CALL",fnName:_,params:[{var:0},{val:q},{var:1}]})),P&&nt.push({cmd:"CALL",fnName:P,params:[{var:0},{val:q},{var:0}]}),nt.push({cmd:"GET",out:0,var:0,len:q*y})):nt.push({cmd:"GET",out:0,var:0,len:F*q}),D.push(i.queueAction(nt).then(at=>(w&&w.debug(`${A}: fft ${Z} mix end: ${V}/${M}`),at)))}E=await Promise.all(D);for(let V=0;V<M;V++)E[V]=E[V][0];for(let V=Q+1;V<=Z;V++){w&&w.debug(`${A}: fft  ${Z}  join: ${V}/${Z}`);const nt=1<<Z-V,R=M/nt,at=[];for(let k=0;k<nt;k++)for(let K=0;K<R/2;K++){const I=a.exp(a.w[V],K*q),d=a.w[V],S=k*R+K,h=k*R+K+R/2,U=[];U.push({cmd:"ALLOCSET",var:0,buff:E[S]}),U.push({cmd:"ALLOCSET",var:1,buff:E[h]}),U.push({cmd:"ALLOCSET",var:2,buff:I}),U.push({cmd:"ALLOCSET",var:3,buff:d}),U.push({cmd:"CALL",fnName:C,params:[{var:0},{var:1},{val:q},{var:2},{var:3}]}),V==Z?(_&&(U.push({cmd:"ALLOCSET",var:4,buff:j}),U.push({cmd:"CALL",fnName:_,params:[{var:0},{val:q},{var:4}]}),U.push({cmd:"CALL",fnName:_,params:[{var:1},{val:q},{var:4}]})),P&&(U.push({cmd:"CALL",fnName:P,params:[{var:0},{val:q},{var:0}]}),U.push({cmd:"CALL",fnName:P,params:[{var:1},{val:q},{var:1}]})),U.push({cmd:"GET",out:0,var:0,len:q*y}),U.push({cmd:"GET",out:1,var:1,len:q*y})):(U.push({cmd:"GET",out:0,var:0,len:q*F}),U.push({cmd:"GET",out:1,var:1,len:q*F})),at.push(i.queueAction(U).then(G=>(w&&w.debug(`${A}: fft ${Z} join  ${V}/${Z}  ${k+1}/${nt} ${K}/${R/2}`),G)))}const J=await Promise.all(at);for(let k=0;k<nt;k++)for(let K=0;K<R/2;K++){const I=k*R+K,d=k*R+K+R/2,S=J.shift();E[I]=S[0],E[d]=S[1]}}if(r instanceof ut?O=new ut($*y):O=new Uint8Array($*y),c){O.set(E[0].slice((q-1)*y));let V=y;for(let nt=M-1;nt>0;nt--)O.set(E[nt],V),V+=q*y,delete E[nt];O.set(E[0].slice(0,(q-1)*y),V),delete E[0]}else for(let V=0;V<M;V++)O.set(E[V],q*y*V),delete E[V];return g?Da(O,y):O}async function l(r,c,u,b,w){let A,x;A=r.slice(0,r.byteLength/2),x=r.slice(r.byteLength/2,r.byteLength);const v=[];[A,x]=await f(A,x,"fftJoinExt",a.one,a.shift,c,"jacobian",b,w),v.push(o(A,!1,"jacobian",u,b,w)),v.push(o(x,!1,"jacobian",u,b,w));const F=await Promise.all(v);let y;return F[0].byteLength>1<<28?y=new ut(F[0].byteLength*2):y=new Uint8Array(F[0].byteLength*2),y.set(F[0]),y.set(F[1],F[0].byteLength),y}async function s(r,c,u,b,w){let A,x;A=r.slice(0,r.byteLength/2),x=r.slice(r.byteLength/2,r.byteLength);const v=[];v.push(o(A,!0,c,"jacobian",b,w)),v.push(o(x,!0,c,"jacobian",b,w)),[A,x]=await Promise.all(v);const F=await f(A,x,"fftJoinExtInv",a.one,a.shiftInv,"jacobian",u,b,w);let y;return F[0].byteLength>1<<28?y=new ut(F[0].byteLength*2):y=new Uint8Array(F[0].byteLength*2),y.set(F[0]),y.set(F[1],F[0].byteLength),y}async function f(r,c,u,b,w,A,x,v,F){let P,T,C,_,g,$;if(t=="G1")A=="affine"?(g=n.F.n8*2,T="g1m_batchToJacobian"):g=n.F.n8*3,$=n.F.n8*3,P="g1m_"+u,x=="affine"?(C="g1m_batchToAffine",_=n.F.n8*2):_=n.F.n8*3;else if(t=="G2")A=="affine"?(g=n.F.n8*2,T="g2m_batchToJacobian"):g=n.F.n8*3,P="g2m_"+u,$=n.F.n8*3,x=="affine"?(C="g2m_batchToAffine",_=n.F.n8*2):_=n.F.n8*3;else if(t=="Fr")g=a.n8,_=a.n8,$=a.n8,P="frm_"+u;else throw new Error("Invalid group");if(r.byteLength!=c.byteLength)throw new Error("Invalid buffer size");const Z=Math.floor(r.byteLength/g);if(Z!=1<<pn(Z))throw new Error("Invalid number of points");let j=Math.floor(Z/i.concurrency);j<16&&(j=16),j>65536&&(j=65536);const O=[];for(let D=0;D<Z;D+=j){v&&v.debug(`${F}: fftJoinExt Start: ${D}/${Z}`);const V=Math.min(Z-D,j),nt=a.mul(b,a.exp(w,D)),R=[],at=r.slice(D*g,(D+V)*g),J=c.slice(D*g,(D+V)*g);R.push({cmd:"ALLOC",var:0,len:$*V}),R.push({cmd:"SET",var:0,buff:at}),R.push({cmd:"ALLOC",var:1,len:$*V}),R.push({cmd:"SET",var:1,buff:J}),R.push({cmd:"ALLOCSET",var:2,buff:nt}),R.push({cmd:"ALLOCSET",var:3,buff:w}),T&&(R.push({cmd:"CALL",fnName:T,params:[{var:0},{val:V},{var:0}]}),R.push({cmd:"CALL",fnName:T,params:[{var:1},{val:V},{var:1}]})),R.push({cmd:"CALL",fnName:P,params:[{var:0},{var:1},{val:V},{var:2},{var:3},{val:a.s}]}),C&&(R.push({cmd:"CALL",fnName:C,params:[{var:0},{val:V},{var:0}]}),R.push({cmd:"CALL",fnName:C,params:[{var:1},{val:V},{var:1}]})),R.push({cmd:"GET",out:0,var:0,len:V*_}),R.push({cmd:"GET",out:1,var:1,len:V*_}),O.push(i.queueAction(R).then(k=>(v&&v.debug(`${F}: fftJoinExt End: ${D}/${Z}`),k)))}const E=await Promise.all(O);let q,M;Z*_>1<<28?(q=new ut(Z*_),M=new ut(Z*_)):(q=new Uint8Array(Z*_),M=new Uint8Array(Z*_));let Q=0;for(let D=0;D<E.length;D++)q.set(E[D][0],Q),M.set(E[D][1],Q),Q+=E[D][0].byteLength;return[q,M]}n.fft=async function(r,c,u,b,w){return await o(r,!1,c,u,b,w)},n.ifft=async function(r,c,u,b,w){return await o(r,!0,c,u,b,w)},n.lagrangeEvaluations=async function(r,c,u,b,w){c=c||"affine",u=u||"affine";let A;if(t=="G1")c=="affine"?A=n.F.n8*2:A=n.F.n8*3;else if(t=="G2")c=="affine"?A=n.F.n8*2:A=n.F.n8*3;else if(t=="Fr")A=a.n8;else throw new Error("Invalid group");const x=r.byteLength/A,v=pn(x);if(2**v*A!=r.byteLength)throw b&&b.error("lagrangeEvaluations iinvalid input size"),new Error("lagrangeEvaluations invalid Input size");if(v<=a.s)return await n.ifft(r,c,u,b,w);if(v>a.s+1)throw b&&b.error("lagrangeEvaluations input too big"),new Error("lagrangeEvaluations input too big");let F=r.slice(0,r.byteLength/2),y=r.slice(r.byteLength/2,r.byteLength);const B=a.exp(a.shift,x/2),P=a.inv(a.sub(a.one,B));[F,y]=await f(F,y,"prepareLagrangeEvaluation",P,a.shiftInv,c,"jacobian",b,w+" prep");const T=[];T.push(o(F,!0,"jacobian",u,b,w+" t0")),T.push(o(y,!0,"jacobian",u,b,w+" t1")),[F,y]=await Promise.all(T);let C;return F.byteLength>1<<28?C=new ut(F.byteLength*2):C=new Uint8Array(F.byteLength*2),C.set(F),C.set(y,F.byteLength),C},n.fftMix=async function(c){const u=n.F.n8*3;let b,w;if(t=="G1")b="g1m_fftMix",w="g1m_fftJoin";else if(t=="G2")b="g2m_fftMix",w="g2m_fftJoin";else if(t=="Fr")b="frm_fftMix",w="frm_fftJoin";else throw new Error("Invalid group");const A=Math.floor(c.byteLength/u),x=pn(A);let v=1<<pn(i.concurrency);A<=v*2&&(v=1);const F=A/v,y=pn(F),B=[];for(let g=0;g<v;g++){const $=[],Z=c.slice(g*F*u,(g+1)*F*u);$.push({cmd:"ALLOCSET",var:0,buff:Z});for(let j=1;j<=y;j++)$.push({cmd:"CALL",fnName:b,params:[{var:0},{val:F},{val:j}]});$.push({cmd:"GET",out:0,var:0,len:F*u}),B.push(i.queueAction($))}const P=await Promise.all(B),T=[];for(let g=0;g<P.length;g++)T[g]=P[g][0];for(let g=y+1;g<=x;g++){const $=1<<x-g,Z=v/$,j=[];for(let E=0;E<$;E++)for(let q=0;q<Z/2;q++){const M=a.exp(a.w[g],q*F),Q=a.w[g],D=E*Z+q,V=E*Z+q+Z/2,nt=[];nt.push({cmd:"ALLOCSET",var:0,buff:T[D]}),nt.push({cmd:"ALLOCSET",var:1,buff:T[V]}),nt.push({cmd:"ALLOCSET",var:2,buff:M}),nt.push({cmd:"ALLOCSET",var:3,buff:Q}),nt.push({cmd:"CALL",fnName:w,params:[{var:0},{var:1},{val:F},{var:2},{var:3}]}),nt.push({cmd:"GET",out:0,var:0,len:F*u}),nt.push({cmd:"GET",out:1,var:1,len:F*u}),j.push(i.queueAction(nt))}const O=await Promise.all(j);for(let E=0;E<$;E++)for(let q=0;q<Z/2;q++){const M=E*Z+q,Q=E*Z+q+Z/2,D=O.shift();T[M]=D[0],T[Q]=D[1]}}let C;c instanceof ut?C=new ut(A*u):C=new Uint8Array(A*u);let _=0;for(let g=0;g<v;g++)C.set(T[g],_),_+=T[g].byteLength;return C},n.fftJoin=async function(c,u,b,w){const A=n.F.n8*3;let x;if(t=="G1")x="g1m_fftJoin";else if(t=="G2")x="g2m_fftJoin";else if(t=="Fr")x="frm_fftJoin";else throw new Error("Invalid group");if(c.byteLength!=u.byteLength)throw new Error("Invalid buffer size");const v=Math.floor(c.byteLength/A);if(v!=1<<pn(v))throw new Error("Invalid number of points");let F=1<<pn(i.concurrency);v<=F*2&&(F=1);const y=v/F,B=[];for(let g=0;g<F;g++){const $=[],Z=a.mul(b,a.exp(w,g*y)),j=c.slice(g*y*A,(g+1)*y*A),O=u.slice(g*y*A,(g+1)*y*A);$.push({cmd:"ALLOCSET",var:0,buff:j}),$.push({cmd:"ALLOCSET",var:1,buff:O}),$.push({cmd:"ALLOCSET",var:2,buff:Z}),$.push({cmd:"ALLOCSET",var:3,buff:w}),$.push({cmd:"CALL",fnName:x,params:[{var:0},{var:1},{val:y},{var:2},{var:3}]}),$.push({cmd:"GET",out:0,var:0,len:y*A}),$.push({cmd:"GET",out:1,var:1,len:y*A}),B.push(i.queueAction($))}const P=await Promise.all(B);let T,C;c instanceof ut?(T=new ut(v*A),C=new ut(v*A)):(T=new Uint8Array(v*A),C=new Uint8Array(v*A));let _=0;for(let g=0;g<P.length;g++)T.set(P[g][0],_),C.set(P[g][1],_),_+=P[g][0].byteLength;return[T,C]},n.fftFinal=async function(c,u){const b=n.F.n8*3,w=n.F.n8*2;let A,x;if(t=="G1")A="g1m_fftFinal",x="g1m_batchToAffine";else if(t=="G2")A="g2m_fftFinal",x="g2m_batchToAffine";else throw new Error("Invalid group");const v=Math.floor(c.byteLength/b);if(v!=1<<pn(v))throw new Error("Invalid number of points");const F=Math.floor(v/i.concurrency),y=[];for(let C=0;C<i.concurrency;C++){let _;if(C<i.concurrency-1?_=F:_=v-C*F,_==0)continue;const g=[],$=c.slice(C*F*b,(C*F+_)*b);g.push({cmd:"ALLOCSET",var:0,buff:$}),g.push({cmd:"ALLOCSET",var:1,buff:u}),g.push({cmd:"CALL",fnName:A,params:[{var:0},{val:_},{var:1}]}),g.push({cmd:"CALL",fnName:x,params:[{var:0},{val:_},{var:0}]}),g.push({cmd:"GET",out:0,var:0,len:_*w}),y.push(i.queueAction(g))}const B=await Promise.all(y);let P;c instanceof ut?P=new ut(v*w):P=new Uint8Array(v*w);let T=0;for(let C=B.length-1;C>=0;C--)P.set(B[C][0],T),T+=B[C][0].byteLength;return P}}async function Vo(e){const t=await fl(e.wasm,e.singleThread),n={};return n.q=en(e.wasm.q.toString()),n.r=en(e.wasm.r.toString()),n.name=e.name,n.tm=t,n.prePSize=e.wasm.prePSize,n.preQSize=e.wasm.preQSize,n.Fr=new Ne(t,"frm",e.n8r,e.r),n.F1=new Ne(t,"f1m",e.n8q,e.q),n.F2=new Ve(t,"f2m",n.F1),n.G1=new Ze(t,"g1m",n.F1,e.wasm.pG1gen,e.wasm.pG1b,e.cofactorG1),n.G2=new Ze(t,"g2m",n.F2,e.wasm.pG2gen,e.wasm.pG2b,e.cofactorG2),n.F6=new rl(t,"f6m",n.F2),n.F12=new Ve(t,"ftm",n.F6),n.Gt=n.F12,bi(n,"G1"),bi(n,"G2"),bi(n,"Fr"),Qe(n,"G1"),Qe(n,"G2"),yi(n,"G1"),yi(n,"G2"),yi(n,"Fr"),hl(n),n.array2buffer=function(a,i){const o=new Uint8Array(i*a.length);for(let l=0;l<a.length;l++)o.set(a[l],l*i);return o},n.buffer2array=function(a,i){const o=a.byteLength/i,l=new Array(o);for(let s=0;s<o;s++)l[s]=a.slice(s*i,s*i+i);return l},n}function la(e){return BigInt(e)}function Zo(e){return e<0n}function pl(e){return e===0n}function wl(e){return Zo(e)?e.toString(2).length-1:e.toString(2).length}function Ci(e){const t=[],n=la(e);return t.push(Number(n&0xFFn)),t.push(Number(n>>8n&0xFFn)),t.push(Number(n>>16n&0xFFn)),t.push(Number(n>>24n&0xFFn)),t}function Ll(e){for(var t=[],n=0;n<e.length;n++){var a=e.charCodeAt(n);a<128?t.push(a):a<2048?t.push(192|a>>6,128|a&63):a<55296||a>=57344?t.push(224|a>>12,128|a>>6&63,128|a&63):(n++,a=65536+((a&1023)<<10|e.charCodeAt(n)&1023),t.push(240|a>>18,128|a>>12&63,128|a>>6&63,128|a&63))}return t}function ga(e){const t=Ll(e);return[...zt(t.length),...t]}function jo(e){const t=[];let n=la(e);if(Zo(n))throw new Error("Number cannot be negative");for(;!pl(n);)t.push(Number(n&0x7Fn)),n=n>>7n;t.length==0&&t.push(0);for(let a=0;a<t.length-1;a++)t[a]=t[a]|128;return t}function Ho(e){let t,n;const a=wl(e);e<0?(n=!0,t=(1n<<BigInt(a))+e):(n=!1,t=la(e));const i=7-a%7,o=(1n<<BigInt(i))-1n<<BigInt(a),l=(1<<7-i)-1|128,s=jo(t+o);return n||(s[s.length-1]=s[s.length-1]&l),s}function Vi(e){let t=la(e);if(t>0xFFFFFFFFn)throw new Error("Number too big");if(t>0x7FFFFFFFn&&(t=t-0x100000000n),t<-2147483648n)throw new Error("Number too small");return Ho(t)}function gl(e){let t=la(e);if(t>0xFFFFFFFFFFFFFFFFn)throw new Error("Number too big");if(t>0x7FFFFFFFFFFFFFFFn&&(t=t-0x10000000000000000n),t<-9223372036854775808n)throw new Error("Number too small");return Ho(t)}function zt(e){let t=la(e);if(t>0xFFFFFFFFn)throw new Error("Number too big");return jo(t)}function De(e){return Array.from(e,function(t){return("0"+(t&255).toString(16)).slice(-2)}).join("")}class ml{constructor(t){this.func=t,this.functionName=t.functionName,this.module=t.module}setLocal(t,n){const a=this.func.localIdxByName[t];if(a===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[...n,33,...zt(a)]}teeLocal(t,n){const a=this.func.localIdxByName[t];if(a===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[...n,34,...zt(a)]}getLocal(t){const n=this.func.localIdxByName[t];if(n===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[32,...zt(n)]}i64_load8_s(t,n,a){const i=n||0,o=a===void 0?0:a;return[...t,48,o,...zt(i)]}i64_load8_u(t,n,a){const i=n||0,o=a===void 0?0:a;return[...t,49,o,...zt(i)]}i64_load16_s(t,n,a){const i=n||0,o=a===void 0?1:a;return[...t,50,o,...zt(i)]}i64_load16_u(t,n,a){const i=n||0,o=a===void 0?1:a;return[...t,51,o,...zt(i)]}i64_load32_s(t,n,a){const i=n||0,o=a===void 0?2:a;return[...t,52,o,...zt(i)]}i64_load32_u(t,n,a){const i=n||0,o=a===void 0?2:a;return[...t,53,o,...zt(i)]}i64_load(t,n,a){const i=n||0,o=a===void 0?3:a;return[...t,41,o,...zt(i)]}i64_store(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=3,s=n):Array.isArray(a)?(o=n,l=3,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,55,l,...zt(o)]}i64_store32(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=2,s=n):Array.isArray(a)?(o=n,l=2,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,62,l,...zt(o)]}i64_store16(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=1,s=n):Array.isArray(a)?(o=n,l=1,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,61,l,...zt(o)]}i64_store8(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=0,s=n):Array.isArray(a)?(o=n,l=0,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,60,l,...zt(o)]}i32_load8_s(t,n,a){const i=n||0,o=a===void 0?0:a;return[...t,44,o,...zt(i)]}i32_load8_u(t,n,a){const i=n||0,o=a===void 0?0:a;return[...t,45,o,...zt(i)]}i32_load16_s(t,n,a){const i=n||0,o=a===void 0?1:a;return[...t,46,o,...zt(i)]}i32_load16_u(t,n,a){const i=n||0,o=a===void 0?1:a;return[...t,47,o,...zt(i)]}i32_load(t,n,a){const i=n||0,o=a===void 0?2:a;return[...t,40,o,...zt(i)]}i32_store(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=2,s=n):Array.isArray(a)?(o=n,l=2,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,54,l,...zt(o)]}i32_store16(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=1,s=n):Array.isArray(a)?(o=n,l=1,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,59,l,...zt(o)]}i32_store8(t,n,a,i){let o,l,s;return Array.isArray(n)?(o=0,l=0,s=n):Array.isArray(a)?(o=n,l=0,s=a):Array.isArray(i)&&(o=n,l=a,s=i),[...t,...s,58,l,...zt(o)]}call(t,...n){const a=this.module.functionIdxByName[t];if(a===void 0)throw new Error(`Function not defined: Function: ${t}`);return[...[].concat(...n),16,...zt(a)]}call_indirect(t,...n){return[...[].concat(...n),...t,17,0,0]}if(t,n,a){return a?[...t,4,64,...n,5,...a,11]:[...t,4,64,...n,11]}block(t){return[2,64,...t,11]}loop(...t){return[3,64,...[].concat(...t),11]}br_if(t,n){return[...n,13,...zt(t)]}br(t){return[12,...zt(t)]}ret(t){return[...t,15]}drop(t){return[...t,26]}i64_const(t){return[66,...gl(t)]}i32_const(t){return[65,...Vi(t)]}i64_eqz(t){return[...t,80]}i64_eq(t,n){return[...t,...n,81]}i64_ne(t,n){return[...t,...n,82]}i64_lt_s(t,n){return[...t,...n,83]}i64_lt_u(t,n){return[...t,...n,84]}i64_gt_s(t,n){return[...t,...n,85]}i64_gt_u(t,n){return[...t,...n,86]}i64_le_s(t,n){return[...t,...n,87]}i64_le_u(t,n){return[...t,...n,88]}i64_ge_s(t,n){return[...t,...n,89]}i64_ge_u(t,n){return[...t,...n,90]}i64_add(t,n){return[...t,...n,124]}i64_sub(t,n){return[...t,...n,125]}i64_mul(t,n){return[...t,...n,126]}i64_div_s(t,n){return[...t,...n,127]}i64_div_u(t,n){return[...t,...n,128]}i64_rem_s(t,n){return[...t,...n,129]}i64_rem_u(t,n){return[...t,...n,130]}i64_and(t,n){return[...t,...n,131]}i64_or(t,n){return[...t,...n,132]}i64_xor(t,n){return[...t,...n,133]}i64_shl(t,n){return[...t,...n,134]}i64_shr_s(t,n){return[...t,...n,135]}i64_shr_u(t,n){return[...t,...n,136]}i64_extend_i32_s(t){return[...t,172]}i64_extend_i32_u(t){return[...t,173]}i64_clz(t){return[...t,121]}i64_ctz(t){return[...t,122]}i32_eqz(t){return[...t,69]}i32_eq(t,n){return[...t,...n,70]}i32_ne(t,n){return[...t,...n,71]}i32_lt_s(t,n){return[...t,...n,72]}i32_lt_u(t,n){return[...t,...n,73]}i32_gt_s(t,n){return[...t,...n,74]}i32_gt_u(t,n){return[...t,...n,75]}i32_le_s(t,n){return[...t,...n,76]}i32_le_u(t,n){return[...t,...n,77]}i32_ge_s(t,n){return[...t,...n,78]}i32_ge_u(t,n){return[...t,...n,79]}i32_add(t,n){return[...t,...n,106]}i32_sub(t,n){return[...t,...n,107]}i32_mul(t,n){return[...t,...n,108]}i32_div_s(t,n){return[...t,...n,109]}i32_div_u(t,n){return[...t,...n,110]}i32_rem_s(t,n){return[...t,...n,111]}i32_rem_u(t,n){return[...t,...n,112]}i32_and(t,n){return[...t,...n,113]}i32_or(t,n){return[...t,...n,114]}i32_xor(t,n){return[...t,...n,115]}i32_shl(t,n){return[...t,...n,116]}i32_shr_s(t,n){return[...t,...n,117]}i32_shr_u(t,n){return[...t,...n,118]}i32_rotl(t,n){return[...t,...n,119]}i32_rotr(t,n){return[...t,...n,120]}i32_wrap_i64(t){return[...t,167]}i32_clz(t){return[...t,103]}i32_ctz(t){return[...t,104]}unreachable(){return[0]}current_memory(){return[63,0]}comment(){return[]}}const Fi={i32:127,i64:126,f32:125,f64:124,anyfunc:112,func:96,emptyblock:64};class Ke{constructor(t,n,a,i,o){if(a=="import")this.fnType="import",this.moduleName=i,this.fieldName=o;else if(a=="internal")this.fnType="internal";else throw new Error("Invalid function fnType: "+a);this.module=t,this.fnName=n,this.params=[],this.locals=[],this.localIdxByName={},this.code=[],this.returnType=null,this.nextLocal=0}addParam(t,n){if(this.localIdxByName[t])throw new Error(`param already exists. Function: ${this.fnName}, Param: ${t} `);const a=this.nextLocal++;this.localIdxByName[t]=a,this.params.push({type:n})}addLocal(t,n,a){const i=a||1;if(this.localIdxByName[t])throw new Error(`local already exists. Function: ${this.fnName}, Param: ${t} `);const o=this.nextLocal++;this.localIdxByName[t]=o,this.locals.push({type:n,length:i})}setReturnType(t){if(this.returnType)throw new Error(`returnType already defined. Function: ${this.fnName}`);this.returnType=t}getSignature(){const t=[...zt(this.params.length),...this.params.map(a=>Fi[a.type])],n=this.returnType?[1,Fi[this.returnType]]:[0];return[96,...t,...n]}getBody(){const t=this.locals.map(a=>[...zt(a.length),Fi[a.type]]),n=[...zt(this.locals.length),...[].concat(...t),...this.code,11];return[...zt(n.length),...n]}addCode(...t){this.code.push(...[].concat(...t))}getCodeBuilder(){return new ml(this)}}class Wo{constructor(){this.functions=[],this.functionIdxByName={},this.nImportFunctions=0,this.nInternalFunctions=0,this.memory={pagesSize:1,moduleName:"env",fieldName:"memory"},this.free=8,this.datas=[],this.modules={},this.exports=[],this.functionsTable=[]}build(){return this._setSignatures(),new Uint8Array([...Ci(1836278016),...Ci(1),...this._buildType(),...this._buildImport(),...this._buildFunctionDeclarations(),...this._buildFunctionsTable(),...this._buildExports(),...this._buildElements(),...this._buildCode(),...this._buildData()])}addFunction(t){if(typeof this.functionIdxByName[t]<"u")throw new Error(`Function already defined: ${t}`);const n=this.functions.length;return this.functionIdxByName[t]=n,this.functions.push(new Ke(this,t,"internal")),this.nInternalFunctions++,this.functions[n]}addIimportFunction(t,n,a){if(typeof this.functionIdxByName[t]<"u")throw new Error(`Function already defined: ${t}`);if(this.functions.length>0&&this.functions[this.functions.length-1].type=="internal")throw new Error(`Import functions must be declared before internal: ${t}`);let i=a||t;const o=this.functions.length;return this.functionIdxByName[t]=o,this.functions.push(new Ke(this,t,"import",n,i)),this.nImportFunctions++,this.functions[o]}setMemory(t,n,a){this.memory={pagesSize:t,moduleName:n||"env",fieldName:a||"memory"}}exportFunction(t,n){const a=n||t;if(typeof this.functionIdxByName[t]>"u")throw new Error(`Function not defined: ${t}`);const i=this.functionIdxByName[t];a!=t&&(this.functionIdxByName[a]=i),this.exports.push({exportName:a,idx:i})}addFunctionToTable(t){const n=this.functionIdxByName[t];this.functionsTable.push(n)}addData(t,n){this.datas.push({offset:t,bytes:n})}alloc(t,n){let a,i;(Array.isArray(t)||ArrayBuffer.isView(t))&&typeof n>"u"?(a=t.length,i=t):(a=t,i=n),a=(a-1>>3)+1<<3;const o=this.free;return this.free+=a,i&&this.addData(o,i),o}allocString(t){const a=new globalThis.TextEncoder().encode(t);return this.alloc([...a,0])}_setSignatures(){this.signatures=[];const t={};if(this.functionsTable.length>0){const n=this.functions[this.functionsTable[0]].getSignature(),a="s_"+De(n);t[a]=0,this.signatures.push(n)}for(let n=0;n<this.functions.length;n++){const a=this.functions[n].getSignature(),i="s_"+De(a);typeof t[i]>"u"&&(t[i]=this.signatures.length,this.signatures.push(a)),this.functions[n].signatureIdx=t[i]}}_buildSection(t,n){return[t,...zt(n.length),...n]}_buildType(){return this._buildSection(1,[...zt(this.signatures.length),...[].concat(...this.signatures)])}_buildImport(){const t=[];t.push([...ga(this.memory.moduleName),...ga(this.memory.fieldName),2,0,...zt(this.memory.pagesSize)]);for(let n=0;n<this.nImportFunctions;n++)t.push([...ga(this.functions[n].moduleName),...ga(this.functions[n].fieldName),0,...zt(this.functions[n].signatureIdx)]);return this._buildSection(2,zt(t.length).concat(...t))}_buildFunctionDeclarations(){const t=[];for(let n=this.nImportFunctions;n<this.nImportFunctions+this.nInternalFunctions;n++)t.push(...zt(this.functions[n].signatureIdx));return this._buildSection(3,[...zt(t.length),...t])}_buildFunctionsTable(){return this.functionsTable.length==0?[]:this._buildSection(4,[...zt(1),112,0,...zt(this.functionsTable.length)])}_buildElements(){if(this.functionsTable.length==0)return[];const t=[];for(let n=0;n<this.functionsTable.length;n++)t.push(...zt(this.functionsTable[n]));return this._buildSection(9,[...zt(1),...zt(0),65,...Vi(0),11,...zt(this.functionsTable.length),...t])}_buildExports(){const t=[];for(let n=0;n<this.exports.length;n++)t.push([...ga(this.exports[n].exportName),0,...zt(this.exports[n].idx)]);return this._buildSection(7,zt(t.length).concat(...t))}_buildCode(){const t=[];for(let n=this.nImportFunctions;n<this.nImportFunctions+this.nInternalFunctions;n++)t.push(this.functions[n].getBody());return this._buildSection(10,zt(t.length).concat(...t))}_buildData(){const t=[];t.push([0,65,0,11,4,...Ci(this.free)]);for(let n=0;n<this.datas.length;n++)t.push([0,65,...Vi(this.datas[n].offset),11,...zt(this.datas[n].bytes.length),...this.datas[n].bytes]);return this._buildSection(11,zt(t.length).concat(...t))}}globalThis.curve_bn128=null;async function ei(e,t){if(!e&&globalThis.curve_bn128)return globalThis.curve_bn128;const n=new Wo;n.setMemory(25),al(n);const a={};a.code=n.build(),a.pq=n.modules.f1m.pq,a.pr=n.modules.frm.pq,a.pG1gen=n.modules.bn128.pG1gen,a.pG1zero=n.modules.bn128.pG1zero,a.pG1b=n.modules.bn128.pG1b,a.pG2gen=n.modules.bn128.pG2gen,a.pG2zero=n.modules.bn128.pG2zero,a.pG2b=n.modules.bn128.pG2b,a.pOneT=n.modules.bn128.pOneT,a.prePSize=n.modules.bn128.prePSize,a.preQSize=n.modules.bn128.preQSize,a.n8q=32,a.n8r=32,a.q=n.modules.bn128.q,a.r=n.modules.bn128.r;const i={name:"bn128",wasm:a,q:en("21888242871839275222246405745257275088696311157297823662689037894645226208583"),r:en("21888242871839275222246405745257275088548364400416034343698204186575808495617"),n8q:32,n8r:32,cofactorG2:en("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d",16),singleThread:!!e},o=await Vo(i);return o.terminate=async function(){i.singleThread||(globalThis.curve_bn128=null,await this.tm.terminate())},e||(globalThis.curve_bn128=o),o}globalThis.curve_bls12381=null;async function oi(e,t){if(!e&&globalThis.curve_bls12381)return globalThis.curve_bls12381;const n=new Wo;n.setMemory(25),il(n);const a={};a.code=n.build(),a.pq=n.modules.f1m.pq,a.pr=n.modules.frm.pq,a.pG1gen=n.modules.bls12381.pG1gen,a.pG1zero=n.modules.bls12381.pG1zero,a.pG1b=n.modules.bls12381.pG1b,a.pG2gen=n.modules.bls12381.pG2gen,a.pG2zero=n.modules.bls12381.pG2zero,a.pG2b=n.modules.bls12381.pG2b,a.pOneT=n.modules.bls12381.pOneT,a.prePSize=n.modules.bls12381.prePSize,a.preQSize=n.modules.bls12381.preQSize,a.n8q=48,a.n8r=32,a.q=n.modules.bls12381.q,a.r=n.modules.bls12381.r;const i={name:"bls12381",wasm:a,q:en("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),r:en("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n8q:48,n8r:32,cofactorG1:en("0x396c8c005555e1568c00aaab0000aaab",16),cofactorG2:en("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5",16),singleThread:!!e},o=await Vo(i);return o.terminate=async function(){i.singleThread||(globalThis.curve_bls12381=null,await this.tm.terminate())},e||(globalThis.curve_bls12381=o),o}const bl=en("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),yl=en("21888242871839275222246405745257275088548364400416034343698204186575808495617");en("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16);en("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function Cl(e,t,n){let a;if(In(e,yl))a=await ei(t);else if(In(e,bl))a=await oi(t);else throw new Error(`Curve not supported: ${oe(e)}`);return a}const St=ic,rn=ll;var Qo={};async function Do(e,t,n,a){if(n=n||4096*64,typeof t!="number"&&["w+","wx+","r","ax+","a+"].indexOf(t)<0)throw new Error("Invalid open option");const i=await Qo.promises.open(e,t),o=await i.stat();return new Fl(i,o,n,a,e)}class Fl{constructor(t,n,a,i,o){for(this.fileName=o,this.fd=t,this.pos=0,this.pageSize=i||256;this.pageSize<n.blksize;)this.pageSize*=2;this.totalSize=n.size,this.totalPages=Math.floor((n.size-1)/this.pageSize)+1,this.maxPagesLoaded=Math.floor(a/this.pageSize)+1,this.pages={},this.pendingLoads=[],this.writing=!1,this.reading=!1,this.avBuffs=[],this.history={}}_loadPage(t){const n=this,a=new Promise((i,o)=>{n.pendingLoads.push({page:t,resolve:i,reject:o})});return n.__statusPage("After Load request: ",t),a}__statusPage(t,n){const a=[],i=this;if(!i.logHistory)return;a.push("=="+t+" "+n);let o="";for(let l=0;l<i.pendingLoads.length;l++)i.pendingLoads[l].page==n&&(o=o+" "+l);if(o&&a.push("Pending loads:"+o),typeof i.pages[n]<"u"){const l=i.pages[n];a.push("Loaded"),a.push("pendingOps: "+l.pendingOps),l.loading&&a.push("loading: "+l.loading),l.writing&&a.push("writing"),l.dirty&&a.push("dirty")}a.push("=="),i.history[n]||(i.history[n]=[]),i.history[n].push(a)}__printHistory(t){const n=this;n.history[t]||console.log("Empty History ",t),console.log("History "+t);for(let a=0;a<n.history[t].length;a++)for(let i=0;i<n.history[t][a].length;i++)console.log("-> "+n.history[t][a][i])}_triggerLoad(){const t=this;if(t.reading||t.pendingLoads.length==0)return;const n=Object.keys(t.pages),a=[];for(let s=0;s<n.length;s++){const f=t.pages[parseInt(n[s])];f.dirty==!1&&f.pendingOps==0&&!f.writing&&!f.loading&&a.push(parseInt(n[s]))}let i=t.maxPagesLoaded-n.length;const o=[];for(;t.pendingLoads.length>0&&(typeof t.pages[t.pendingLoads[0].page]<"u"||i>0||a.length>0);){const s=t.pendingLoads.shift();if(typeof t.pages[s.page]<"u"){t.pages[s.page].pendingOps++;const f=a.indexOf(s.page);f>=0&&a.splice(f,1),t.pages[s.page].loading?t.pages[s.page].loading.push(s):s.resolve(),t.__statusPage("After Load (cached): ",s.page)}else{if(i)i--;else{const f=a.shift();t.__statusPage("Before Unload: ",f),t.avBuffs.unshift(t.pages[f]),delete t.pages[f],t.__statusPage("After Unload: ",f)}s.page>=t.totalPages?(t.pages[s.page]=l(),s.resolve(),t.__statusPage("After Load (new): ",s.page)):(t.reading=!0,t.pages[s.page]=l(),t.pages[s.page].loading=[s],o.push(t.fd.read(t.pages[s.page].buff,0,t.pageSize,s.page*t.pageSize).then(f=>{t.pages[s.page].size=f.bytesRead;const r=t.pages[s.page].loading;delete t.pages[s.page].loading;for(let c=0;c<r.length;c++)r[c].resolve();return t.__statusPage("After Load (loaded): ",s.page),f},f=>{s.reject(f)})),t.__statusPage("After Load (loading): ",s.page))}}Promise.all(o).then(()=>{t.reading=!1,t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t)),t._tryClose()});function l(){if(t.avBuffs.length>0){const s=t.avBuffs.shift();return s.dirty=!1,s.pendingOps=1,s.size=0,s}else return{dirty:!1,buff:new Uint8Array(t.pageSize),pendingOps:1,size:0}}}_triggerWrite(){const t=this;if(t.writing)return;const n=Object.keys(t.pages),a=[];for(let i=0;i<n.length;i++){const o=t.pages[parseInt(n[i])];o.dirty&&(o.dirty=!1,o.writing=!0,t.writing=!0,a.push(t.fd.write(o.buff,0,o.size,parseInt(n[i])*t.pageSize).then(()=>{o.writing=!1},l=>{console.log("ERROR Writing: "+l),t.error=l,t._tryClose()})))}t.writing&&Promise.all(a).then(()=>{t.writing=!1,setImmediate(t._triggerWrite.bind(t)),t._tryClose(),t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t))})}_getDirtyPage(){for(let t in this.pages)if(this.pages[t].dirty)return t;return-1}async write(t,n){if(t.byteLength==0)return;const a=this;if(typeof n>"u"&&(n=a.pos),a.pos=n+t.byteLength,a.totalSize<n+t.byteLength&&(a.totalSize=n+t.byteLength),a.pendingClose)throw new Error("Writing a closing file");const i=Math.floor(n/a.pageSize),o=Math.floor((n+t.byteLength-1)/a.pageSize),l=[];for(let c=i;c<=o;c++)l.push(a._loadPage(c));a._triggerLoad();let s=i,f=n%a.pageSize,r=t.byteLength;for(;r>0;){await l[s-i];const c=f+r>a.pageSize?a.pageSize-f:r,u=t.slice(t.byteLength-r,t.byteLength-r+c);new Uint8Array(a.pages[s].buff.buffer,f,c).set(u),a.pages[s].dirty=!0,a.pages[s].pendingOps--,a.pages[s].size=Math.max(f+c,a.pages[s].size),s>=a.totalPages&&(a.totalPages=s+1),r=r-c,s++,f=0,a.writing||setImmediate(a._triggerWrite.bind(a))}}async read(t,n){const a=this;let i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}async readToBuffer(t,n,a,i){if(a==0)return;const o=this;if(a>o.pageSize*o.maxPagesLoaded*.8){const b=Math.floor(a*1.1);this.maxPagesLoaded=Math.floor(b/o.pageSize)+1}if(typeof i>"u"&&(i=o.pos),o.pos=i+a,o.pendingClose)throw new Error("Reading a closing file");const l=Math.floor(i/o.pageSize),s=Math.floor((i+a-1)/o.pageSize),f=[];for(let b=l;b<=s;b++)f.push(o._loadPage(b));o._triggerLoad();let r=l,c=i%o.pageSize,u=i+a>o.totalSize?a-(i+a-o.totalSize):a;for(;u>0;){await f[r-l],o.__statusPage("After Await (read): ",r);const b=c+u>o.pageSize?o.pageSize-c:u,w=new Uint8Array(o.pages[r].buff.buffer,o.pages[r].buff.byteOffset+c,b);t.set(w,n+a-u),o.pages[r].pendingOps--,o.__statusPage("After Op done: ",r),u=u-b,r++,c=0,o.pendingLoads.length>0&&setImmediate(o._triggerLoad.bind(o))}this.pos=i+a}_tryClose(){const t=this;!t.pendingClose||(t.error&&t.pendingCloseReject(t.error),t._getDirtyPage()>=0||t.writing||t.reading||t.pendingLoads.length>0)||t.pendingClose()}close(){const t=this;if(t.pendingClose)throw new Error("Closing the file twice");return new Promise((n,a)=>{t.pendingClose=n,t.pendingCloseReject=a,t._tryClose()}).then(()=>{t.fd.close()},n=>{throw t.fd.close(),n})}async discard(){await this.close(),await Qo.promises.unlink(this.fileName)}async writeULE32(t,n){const a=this,i=new Uint8Array(4);new DataView(i.buffer).setUint32(0,t,!0),await a.write(i,n)}async writeUBE32(t,n){const a=this,i=new Uint8Array(4);new DataView(i.buffer).setUint32(0,t,!1),await a.write(i,n)}async writeULE64(t,n){const a=this,i=new Uint8Array(8),o=new DataView(i.buffer);o.setUint32(0,t&4294967295,!0),o.setUint32(4,Math.floor(t/4294967296),!0),await a.write(i,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this;if(n.pendingClose)throw new Error("Reading a closing file");let a=typeof t>"u"?n.pos:t,i=Math.floor(a/n.pageSize),o=!1,l="";for(;!o;){let s=n._loadPage(i);n._triggerLoad(),await s,n.__statusPage("After Await (read): ",i);let f=a%n.pageSize;const r=new Uint8Array(n.pages[i].buff.buffer,n.pages[i].buff.byteOffset+f,n.pageSize-f);let c=r.findIndex(u=>u===0);o=c!==-1,o?(l+=new TextDecoder().decode(r.slice(0,c)),n.pos=i*this.pageSize+f+c+1):(l+=new TextDecoder().decode(r),n.pos=i*this.pageSize+f+r.length),n.pages[i].pendingOps--,n.__statusPage("After Op done: ",i),a=n.pos,i++,n.pendingLoads.length>0&&setImmediate(n._triggerLoad.bind(n))}return l}}function Sl(e){const t=e.initialSize||1048576,n=new Xo;return n.o=e,n.o.data=new Uint8Array(t),n.allocSize=t,n.totalSize=0,n.readOnly=!1,n.pos=0,n}function vl(e){const t=new Xo;return t.o=e,t.allocSize=e.data.byteLength,t.totalSize=e.data.byteLength,t.readOnly=!0,t.pos=0,t}const Zi=new Uint8Array(4),Xe=new DataView(Zi.buffer),Ko=new Uint8Array(8),Ye=new DataView(Ko.buffer);class Xo{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t>this.allocSize){const n=Math.max(this.allocSize+1048576,Math.floor(this.allocSize*1.1),t),a=new Uint8Array(n);a.set(this.o.data),this.o.data=a,this.allocSize=n}}async write(t,n){if(typeof n>"u"&&(n=this.pos),this.readOnly)throw new Error("Writing a read only file");this._resizeIfNeeded(n+t.byteLength),this.o.data.set(t.slice(),n),n+t.byteLength>this.totalSize&&(this.totalSize=n+t.byteLength),this.pos=n+t.byteLength}async readToBuffer(t,n,a,i){if(typeof i>"u"&&(i=this.pos),this.readOnly&&i+a>this.totalSize)throw new Error("Reading out of bounds");this._resizeIfNeeded(i+a);const l=new Uint8Array(this.o.data.buffer,this.o.data.byteOffset+i,a);t.set(l,n),this.pos=i+a}async read(t,n){const a=this,i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}close(){this.o.data.byteLength!=this.totalSize&&(this.o.data=this.o.data.slice(0,this.totalSize))}async discard(){}async writeULE32(t,n){const a=this;Xe.setUint32(0,t,!0),await a.write(Zi,n)}async writeUBE32(t,n){const a=this;Xe.setUint32(0,t,!1),await a.write(Zi,n)}async writeULE64(t,n){const a=this;Ye.setUint32(0,t&4294967295,!0),Ye.setUint32(4,Math.floor(t/4294967296),!0),await a.write(Ko,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this;let a=typeof t>"u"?n.pos:t;if(a>this.totalSize){if(this.readOnly)throw new Error("Reading out of bounds");this._resizeIfNeeded(t)}const i=new Uint8Array(n.o.data.buffer,a,this.totalSize-a);let o=i.findIndex(f=>f===0),l=o!==-1,s="";return l?(s=new TextDecoder().decode(i.slice(0,o)),n.pos=a+o+1):n.pos=a,s}}const cn=1<<22;function El(e){const t=e.initialSize||0,n=new Jo;n.o=e;const a=t?Math.floor((t-1)/cn)+1:0;n.o.data=[];for(let i=0;i<a-1;i++)n.o.data.push(new Uint8Array(cn));return a&&n.o.data.push(new Uint8Array(t-cn*(a-1))),n.totalSize=0,n.readOnly=!1,n.pos=0,n}function Al(e){const t=new Jo;return t.o=e,t.totalSize=(e.data.length-1)*cn+e.data[e.data.length-1].byteLength,t.readOnly=!0,t.pos=0,t}const ji=new Uint8Array(4),Je=new DataView(ji.buffer),Yo=new Uint8Array(8),to=new DataView(Yo.buffer);class Jo{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t<=this.totalSize)return;if(this.readOnly)throw new Error("Reading out of file bounds");const n=Math.floor((t-1)/cn)+1;for(let a=Math.max(this.o.data.length-1,0);a<n;a++){const i=a<n-1?cn:t-(n-1)*cn,o=new Uint8Array(i);a==this.o.data.length-1&&o.set(this.o.data[a]),this.o.data[a]=o}this.totalSize=t}async write(t,n){const a=this;if(typeof n>"u"&&(n=a.pos),this.readOnly)throw new Error("Writing a read only file");this._resizeIfNeeded(n+t.byteLength);let o=Math.floor(n/cn),l=n%cn,s=t.byteLength;for(;s>0;){const f=l+s>cn?cn-l:s,r=t.slice(t.byteLength-s,t.byteLength-s+f);new Uint8Array(a.o.data[o].buffer,l,f).set(r),s=s-f,o++,l=0}this.pos=n+t.byteLength}async readToBuffer(t,n,a,i){const o=this;if(typeof i>"u"&&(i=o.pos),this.readOnly&&i+a>this.totalSize)throw new Error("Reading out of bounds");this._resizeIfNeeded(i+a);let s=Math.floor(i/cn),f=i%cn,r=a;for(;r>0;){const c=f+r>cn?cn-f:r,u=new Uint8Array(o.o.data[s].buffer,f,c);t.set(u,n+a-r),r=r-c,s++,f=0}this.pos=i+a}async read(t,n){const a=this,i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}close(){}async discard(){}async writeULE32(t,n){const a=this;Je.setUint32(0,t,!0),await a.write(ji,n)}async writeUBE32(t,n){const a=this;Je.setUint32(0,t,!1),await a.write(ji,n)}async writeULE64(t,n){const a=this;to.setUint32(0,t&4294967295,!0),to.setUint32(4,Math.floor(t/4294967296),!0),await a.write(Yo,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this,a=2048;let i=typeof t>"u"?n.pos:t;if(i>this.totalSize){if(this.readOnly)throw new Error("Reading out of bounds");this._resizeIfNeeded(t)}let o=!1,l="";for(;!o;){let s=Math.floor(i/cn),f=i%cn;if(n.o.data[s]===void 0)throw new Error("ERROR");let r=Math.min(a,n.o.data[s].length-f);const c=new Uint8Array(n.o.data[s].buffer,f,r);let u=c.findIndex(b=>b===0);o=u!==-1,o?(l+=new TextDecoder().decode(c.slice(0,u)),n.pos=s*cn+f+u+1):(l+=new TextDecoder().decode(c),n.pos=s*cn+f+c.length),i=n.pos}return l}}const xl=1024,Bl=512,Il=2,Pl=0,Gl=65536,Tl=8192;async function ra(e,t,n){if(typeof e=="string"&&(e={type:"file",fileName:e,cacheSize:t||Gl,pageSize:n||Tl}),e.type=="file")return await Do(e.fileName,xl|Bl|Il,e.cacheSize,e.pageSize);if(e.type=="mem")return Sl(e);if(e.type=="bigMem")return El(e);throw new Error("Invalid FastFile type: "+e.type)}async function Nn(e,t,n){if(e instanceof Uint8Array&&(e={type:"mem",data:e}),typeof e=="string"&&(e={type:"mem",data:await fetch(e).then(function(i){return i.arrayBuffer()}).then(function(i){return new Uint8Array(i)})}),e.type=="file")return await Do(e.fileName,Pl,e.cacheSize,e.pageSize);if(e.type=="mem")return await vl(e);if(e.type=="bigMem")return await Al(e);throw new Error("Invalid FastFile type: "+e.type)}async function Ht(e,t,n,a,i){const o=await Nn(e),l=await o.read(4);let s="";for(let u=0;u<4;u++)s+=String.fromCharCode(l[u]);if(s!=t)throw new Error(e+": Invalid File format");if(await o.readULE32()>n)throw new Error("Version not supported");const r=await o.readULE32();let c=[];for(let u=0;u<r;u++){let b=await o.readULE32(),w=await o.readULE64();typeof c[b]>"u"&&(c[b]=[]),c[b].push({p:o.pos,size:w}),o.pos+=w}return{fd:o,sections:c}}async function _n(e,t,n,a,i,o){const l=await ra(e,i,o),s=new Uint8Array(4);for(let f=0;f<4;f++)s[f]=t.charCodeAt(f);return await l.write(s,0),await l.writeULE32(n),await l.writeULE32(a),l}async function Mt(e,t){if(typeof e.writingSection<"u")throw new Error("Already writing a section");await e.writeULE32(t),e.writingSection={pSectionSize:e.pos},await e.writeULE64(0)}async function Ut(e){if(typeof e.writingSection>"u")throw new Error("Not writing a section");const t=e.pos-e.writingSection.pSectionSize-8,n=e.pos;e.pos=e.writingSection.pSectionSize,await e.writeULE64(t),e.pos=n,delete e.writingSection}async function Wt(e,t,n){if(typeof e.readingSection<"u")throw new Error("Already reading a section");if(!t[n])throw new Error(e.fileName+": Missing section "+n);if(t[n].length>1)throw new Error(e.fileName+": Section Duplicated "+n);e.pos=t[n][0].p,e.readingSection=t[n][0]}async function Qt(e,t){if(typeof e.readingSection>"u")throw new Error("Not reading a section");if(!t&&e.pos-e.readingSection.p!=e.readingSection.size)throw new Error("Invalid section size reading");delete e.readingSection}async function yn(e,t,n,a){const i=new Uint8Array(n);St.toRprLE(i,0,t,n),await e.write(i,a)}async function En(e,t,n){const a=await e.read(t,n);return St.fromRprLE(a,0,t)}async function Nt(e,t,n,a,i){typeof i>"u"&&(i=t[a][0].size);const o=e.pageSize;await Wt(e,t,a),await Mt(n,a);for(let l=0;l<i;l+=o){const s=Math.min(i-l,o),f=await e.read(s);await n.write(f)}await Ut(n),await Qt(e,i!=t[a][0].size)}async function Zt(e,t,n,a,i){if(a=typeof a>"u"?0:a,i=typeof i>"u"?t[n][0].size-a:i,a+i>t[n][0].size)throw new Error("Reading out of the range of the section");let o;return i<1<<30?o=new Uint8Array(i):o=new ut(i),await e.readToBuffer(o,0,i,t[n][0].p+a),o}async function ma(e,t,n,a,i){const o=e.pageSize*16;if(await Wt(e,t,i),await Wt(n,a,i),t[i][0].size!=a[i][0].size)return!1;const l=t[i][0].size;for(let s=0;s<l;s+=o){const f=Math.min(l-s,o),r=await e.read(f),c=await n.read(f);for(let u=0;u<f;u++)if(r[u]!=c[u])return!1}return await Qt(e),await Qt(n),!0}const Ol=St.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),zl=St.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),ql=St.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),Ml=St.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function ts(e,t){let n,a=t&&t.singleThread;if(St.eq(e,zl))n=await ei(a);else if(St.eq(e,Ol))n=await oi(a);else throw new Error(`Curve not supported: ${St.toString(e)}`);return n}async function hn(e,t){let n,a=t&&t.singleThread;if(St.eq(e,Ml))n=await ei(a);else if(St.eq(e,ql))n=await oi(a);else throw new Error(`Curve not supported: ${St.toString(e)}`);return n}async function Yn(e,t){let n,a=t&&t.singleThread;const i=o(e);if(["BN128","BN254","ALTBN128"].indexOf(i)>=0)n=await ei(a);else if(["BLS12381"].indexOf(i)>=0)n=await oi(a);else throw new Error(`Curve not supported: ${e}`);return n;function o(l){return l.toUpperCase().match(/[A-Za-z0-9]+/g).join("")}}var Tu=Object.freeze({__proto__:null,getCurveFromR:ts,getCurveFromQ:hn,getCurveFromName:Yn});function Fa(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Ul(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function he(e,...t){if(!Ul(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Ka(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function ns(e,t){he(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xn=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Pn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,as=e=>e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255,Bn=Pn?e=>e:e=>as(e);function Un(e){for(let t=0;t<e.length;t++)e[t]=as(e[t])}function Rl(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Qn(e){return typeof e=="string"&&(e=Rl(e)),he(e),e}class is{clone(){return this._cloneInto()}}function kl(e){const t=a=>e().update(Qn(a)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function $l(e){const t=(a,i)=>e(i).update(Qn(a)).digest(),n=e({});return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=a=>e(a),t}const Nl=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3]);class Vl extends is{constructor(t,n,a={},i,o,l){if(super(),this.blockLen=t,this.outputLen=n,this.length=0,this.pos=0,this.finished=!1,this.destroyed=!1,Fa(t),Fa(n),Fa(i),n<0||n>i)throw new Error("outputLen bigger than keyLen");if(a.key!==void 0&&(a.key.length<1||a.key.length>i))throw new Error(`key must be up 1..${i} byte long or undefined`);if(a.salt!==void 0&&a.salt.length!==o)throw new Error(`salt must be ${o} byte long or undefined`);if(a.personalization!==void 0&&a.personalization.length!==l)throw new Error(`personalization must be ${l} byte long or undefined`);this.buffer32=Xn(this.buffer=new Uint8Array(t))}update(t){Ka(this);const{blockLen:n,buffer:a,buffer32:i}=this;t=Qn(t);const o=t.length,l=t.byteOffset,s=t.buffer;for(let f=0;f<o;){this.pos===n&&(Pn||Un(i),this.compress(i,0,!1),Pn||Un(i),this.pos=0);const r=Math.min(n-this.pos,o-f),c=l+f;if(r===n&&!(c%4)&&f+r<o){const u=new Uint32Array(s,c,Math.floor((o-f)/4));Pn||Un(u);for(let b=0;f+n<o;b+=i.length,f+=n)this.length+=n,this.compress(u,b,!1);Pn||Un(u);continue}a.set(t.subarray(f,f+r),this.pos),this.pos+=r,this.length+=r,f+=r}return this}digestInto(t){Ka(this),ns(t,this);const{pos:n,buffer32:a}=this;this.finished=!0,this.buffer.subarray(n).fill(0),Pn||Un(a),this.compress(a,0,!0),Pn||Un(a);const i=Xn(t);this.get().forEach((o,l)=>i[l]=Bn(o))}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const a=t.slice(0,n);return this.destroy(),a}_cloneInto(t){const{buffer:n,length:a,finished:i,destroyed:o,outputLen:l,pos:s}=this;return t||(t=new this.constructor({dkLen:l})),t.set(...this.get()),t.length=a,t.finished=i,t.destroyed=o,t.outputLen=l,t.buffer.set(n),t.pos=s,t}}const Va=BigInt(2**32-1),Hi=BigInt(32);function es(e,t=!1){return t?{h:Number(e&Va),l:Number(e>>Hi&Va)}:{h:Number(e>>Hi&Va)|0,l:Number(e&Va)|0}}function os(e,t=!1){let n=new Uint32Array(e.length),a=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:o,l}=es(e[i],t);[n[i],a[i]]=[o,l]}return[n,a]}const Zl=(e,t)=>BigInt(e>>>0)<<Hi|BigInt(t>>>0),jl=(e,t,n)=>e>>>n,Hl=(e,t,n)=>e<<32-n|t>>>n,Wl=(e,t,n)=>e>>>n|t<<32-n,Ql=(e,t,n)=>e<<32-n|t>>>n,Dl=(e,t,n)=>e<<64-n|t>>>n-32,Kl=(e,t,n)=>e>>>n-32|t<<64-n,Xl=(e,t)=>t,Yl=(e,t)=>e,ss=(e,t,n)=>e<<n|t>>>32-n,cs=(e,t,n)=>t<<n|e>>>32-n,ls=(e,t,n)=>t<<n-32|e>>>64-n,rs=(e,t,n)=>e<<n-32|t>>>64-n;function Jl(e,t,n,a){const i=(t>>>0)+(a>>>0);return{h:e+n+(i/2**32|0)|0,l:i|0}}const tr=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),nr=(e,t,n,a)=>t+n+a+(e/2**32|0)|0,ar=(e,t,n,a)=>(e>>>0)+(t>>>0)+(n>>>0)+(a>>>0),ir=(e,t,n,a,i)=>t+n+a+i+(e/2**32|0)|0,er=(e,t,n,a,i)=>(e>>>0)+(t>>>0)+(n>>>0)+(a>>>0)+(i>>>0),or=(e,t,n,a,i,o)=>t+n+a+i+o+(e/2**32|0)|0,sr={fromBig:es,split:os,toBig:Zl,shrSH:jl,shrSL:Hl,rotrSH:Wl,rotrSL:Ql,rotrBH:Dl,rotrBL:Kl,rotr32H:Xl,rotr32L:Yl,rotlSH:ss,rotlSL:cs,rotlBH:ls,rotlBL:rs,add:Jl,add3L:tr,add3H:nr,add4L:ar,add4H:ir,add5H:or,add5L:er};var un=sr;const sn=new Uint32Array([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),Ct=new Uint32Array(32);function zn(e,t,n,a,i,o){const l=i[o],s=i[o+1];let f=Ct[2*e],r=Ct[2*e+1],c=Ct[2*t],u=Ct[2*t+1],b=Ct[2*n],w=Ct[2*n+1],A=Ct[2*a],x=Ct[2*a+1],v=un.add3L(f,c,l);r=un.add3H(v,r,u,s),f=v|0,{Dh:x,Dl:A}={Dh:x^r,Dl:A^f},{Dh:x,Dl:A}={Dh:un.rotr32H(x,A),Dl:un.rotr32L(x,A)},{h:w,l:b}=un.add(w,b,x,A),{Bh:u,Bl:c}={Bh:u^w,Bl:c^b},{Bh:u,Bl:c}={Bh:un.rotrSH(u,c,24),Bl:un.rotrSL(u,c,24)},Ct[2*e]=f,Ct[2*e+1]=r,Ct[2*t]=c,Ct[2*t+1]=u,Ct[2*n]=b,Ct[2*n+1]=w,Ct[2*a]=A,Ct[2*a+1]=x}function qn(e,t,n,a,i,o){const l=i[o],s=i[o+1];let f=Ct[2*e],r=Ct[2*e+1],c=Ct[2*t],u=Ct[2*t+1],b=Ct[2*n],w=Ct[2*n+1],A=Ct[2*a],x=Ct[2*a+1],v=un.add3L(f,c,l);r=un.add3H(v,r,u,s),f=v|0,{Dh:x,Dl:A}={Dh:x^r,Dl:A^f},{Dh:x,Dl:A}={Dh:un.rotrSH(x,A,16),Dl:un.rotrSL(x,A,16)},{h:w,l:b}=un.add(w,b,x,A),{Bh:u,Bl:c}={Bh:u^w,Bl:c^b},{Bh:u,Bl:c}={Bh:un.rotrBH(u,c,63),Bl:un.rotrBL(u,c,63)},Ct[2*e]=f,Ct[2*e+1]=r,Ct[2*t]=c,Ct[2*t+1]=u,Ct[2*n]=b,Ct[2*n+1]=w,Ct[2*a]=A,Ct[2*a+1]=x}class cr extends Vl{constructor(t={}){super(128,t.dkLen===void 0?64:t.dkLen,t,64,16,16),this.v0l=sn[0]|0,this.v0h=sn[1]|0,this.v1l=sn[2]|0,this.v1h=sn[3]|0,this.v2l=sn[4]|0,this.v2h=sn[5]|0,this.v3l=sn[6]|0,this.v3h=sn[7]|0,this.v4l=sn[8]|0,this.v4h=sn[9]|0,this.v5l=sn[10]|0,this.v5h=sn[11]|0,this.v6l=sn[12]|0,this.v6h=sn[13]|0,this.v7l=sn[14]|0,this.v7h=sn[15]|0;const n=t.key?t.key.length:0;if(this.v0l^=this.outputLen|n<<8|65536|1<<24,t.salt){const a=Xn(Qn(t.salt));this.v4l^=Bn(a[0]),this.v4h^=Bn(a[1]),this.v5l^=Bn(a[2]),this.v5h^=Bn(a[3])}if(t.personalization){const a=Xn(Qn(t.personalization));this.v6l^=Bn(a[0]),this.v6h^=Bn(a[1]),this.v7l^=Bn(a[2]),this.v7h^=Bn(a[3])}if(t.key){const a=new Uint8Array(this.blockLen);a.set(Qn(t.key)),this.update(a)}}get(){let{v0l:t,v0h:n,v1l:a,v1h:i,v2l:o,v2h:l,v3l:s,v3h:f,v4l:r,v4h:c,v5l:u,v5h:b,v6l:w,v6h:A,v7l:x,v7h:v}=this;return[t,n,a,i,o,l,s,f,r,c,u,b,w,A,x,v]}set(t,n,a,i,o,l,s,f,r,c,u,b,w,A,x,v){this.v0l=t|0,this.v0h=n|0,this.v1l=a|0,this.v1h=i|0,this.v2l=o|0,this.v2h=l|0,this.v3l=s|0,this.v3h=f|0,this.v4l=r|0,this.v4h=c|0,this.v5l=u|0,this.v5h=b|0,this.v6l=w|0,this.v6h=A|0,this.v7l=x|0,this.v7h=v|0}compress(t,n,a){this.get().forEach((f,r)=>Ct[r]=f),Ct.set(sn,16);let{h:i,l:o}=un.fromBig(BigInt(this.length));Ct[24]=sn[8]^o,Ct[25]=sn[9]^i,a&&(Ct[28]=~Ct[28],Ct[29]=~Ct[29]);let l=0;const s=Nl;for(let f=0;f<12;f++)zn(0,4,8,12,t,n+2*s[l++]),qn(0,4,8,12,t,n+2*s[l++]),zn(1,5,9,13,t,n+2*s[l++]),qn(1,5,9,13,t,n+2*s[l++]),zn(2,6,10,14,t,n+2*s[l++]),qn(2,6,10,14,t,n+2*s[l++]),zn(3,7,11,15,t,n+2*s[l++]),qn(3,7,11,15,t,n+2*s[l++]),zn(0,5,10,15,t,n+2*s[l++]),qn(0,5,10,15,t,n+2*s[l++]),zn(1,6,11,12,t,n+2*s[l++]),qn(1,6,11,12,t,n+2*s[l++]),zn(2,7,8,13,t,n+2*s[l++]),qn(2,7,8,13,t,n+2*s[l++]),zn(3,4,9,14,t,n+2*s[l++]),qn(3,4,9,14,t,n+2*s[l++]);this.v0l^=Ct[0]^Ct[16],this.v0h^=Ct[1]^Ct[17],this.v1l^=Ct[2]^Ct[18],this.v1h^=Ct[3]^Ct[19],this.v2l^=Ct[4]^Ct[20],this.v2h^=Ct[5]^Ct[21],this.v3l^=Ct[6]^Ct[22],this.v3h^=Ct[7]^Ct[23],this.v4l^=Ct[8]^Ct[24],this.v4h^=Ct[9]^Ct[25],this.v5l^=Ct[10]^Ct[26],this.v5h^=Ct[11]^Ct[27],this.v6l^=Ct[12]^Ct[28],this.v6h^=Ct[13]^Ct[29],this.v7l^=Ct[14]^Ct[30],this.v7h^=Ct[15]^Ct[31],Ct.fill(0)}destroy(){this.destroyed=!0,this.buffer32.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Yt=$l(e=>new cr(e));function Vn(e){return((e&4294901760)!==0?(e&=4294901760,16):0)|((e&4278255360)!==0?(e&=4278255360,8):0)|((e&4042322160)!==0?(e&=4042322160,4):0)|((e&3435973836)!==0?(e&=3435973836,2):0)|(e&2863311530)!==0}function an(e,t){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let a="";for(let i=0;i<4;i++){i>0&&(a+=`
`),a+="		";for(let o=0;o<4;o++)o>0&&(a+=" "),a+=n.getUint32(i*16+o*4).toString(16).padStart(8,"0")}return t&&(a=t+`
`+a),a}function Rn(e,t){if(e.byteLength!=t.byteLength)return!1;for(var n=new Int8Array(e),a=new Int8Array(t),i=0;i!=e.byteLength;i++)if(n[i]!=a[i])return!1;return!0}function lr(e){return e.clone()}function ds(e){const t=e.subarray(0,128),n=Xn(e.subarray(128)),a=Yt.create({dkLen:64});a.buffer.set(t),a.v0l=n[0]|0,a.v0h=n[1]|0,a.v1l=n[2]|0,a.v1h=n[3]|0,a.v2l=n[4]|0,a.v2h=n[5]|0,a.v3l=n[6]|0,a.v3h=n[7]|0,a.v4l=n[8]|0,a.v4h=n[9]|0,a.v5l=n[10]|0,a.v5h=n[11]|0,a.v6l=n[12]|0,a.v6h=n[13]|0,a.v7l=n[14]|0,a.v7h=n[15]|0;const i=2**32,o=n[16]+n[17]*i,l=n[18]+n[19]*i;return a.length=o+l,a.pos=l,a}function pe(e){const t=new Uint8Array(216),n=Xn(t.subarray(128));return t.set(e.buffer),n[0]=e.v0l,n[1]=e.v0h,n[2]=e.v1l,n[3]=e.v1h,n[4]=e.v2l,n[5]=e.v2h,n[6]=e.v3l,n[7]=e.v3h,n[8]=e.v4l,n[9]=e.v4h,n[10]=e.v5l,n[11]=e.v5h,n[12]=e.v6l,n[13]=e.v6h,n[14]=e.v7l,n[15]=e.v7h,n[18]=e.pos,n[16]=e.length-e.pos,t}async function us(e,t,n,a,i){return e.G1.isZero(t)||e.G1.isZero(n)||e.G2.isZero(a)||e.G2.isZero(i)?!1:await e.pairingEq(t,i,e.G1.neg(n),a)}function rr(){return window.prompt("Enter a random text. (Entropy): ","")}function aa(e){let t=new Uint8Array(e);return globalThis.crypto.getRandomValues(t),t}async function dr(e){{const t=await globalThis.crypto.subtle.digest("SHA-256",e.buffer);return new Uint8Array(t)}}function Xa(e,t){return new DataView(e.buffer).getUint32(t,!1)}async function si(e){for(;!e;)e=await rr();const t=Yt.create(64);t.update(aa(64));const n=new TextEncoder;t.update(n.encode(e));const a=t.digest(),i=[];for(let l=0;l<8;l++)i[l]=Xa(a,l*4);return new Kn(i)}async function we(e,t){let n,a;t<32?(n=1<<t>>>0,a=1):(n=4294967296,a=1<<t-32>>>0);let i=e;for(let f=0;f<a;f++)for(let r=0;r<n;r++)i=await dr(i);const o=new DataView(i.buffer,i.byteOffset,i.byteLength),l=[];for(let f=0;f<8;f++)l[f]=o.getUint32(f*4,!1);return new Kn(l)}function fs(e){return e instanceof Uint8Array?e:(e.slice(0,2)=="0x"&&(e=e.slice(2)),new Uint8Array(e.match(/[\da-f]{2}/gi).map(function(t){return parseInt(t,16)})))}function _s(e){return Array.prototype.map.call(e,function(t){return("0"+(t&255).toString(16)).slice(-2)}).join("")}function Ya(e,t){if(t instanceof Uint8Array)return e.toString(t);if(Array.isArray(t))return t.map(Ya.bind(null,e));if(typeof t=="object"){const n={};return Object.keys(t).forEach(i=>{n[i]=Ya(e,t[i])}),n}else return typeof t=="bigint"||t.eq!==void 0?t.toString(10):t}const no=1,ur=1,fr=2,Ma=10,_r=3,hr=17,Wi=2,Ja=3,Qi=4,Di=5,Ki=6,Sa=7,va=8,Ea=9,Aa=10,xa=11,Ba=12,Ia=13,Pa=14,Xi=15,ti=16,Yi=17;async function Le(e,t){await Mt(e,1),await e.writeULE32(1),await Ut(e);const n=await hn(t.q);await Mt(e,2);const a=n.q,i=(Math.floor((St.bitLength(a)-1)/64)+1)*8,o=n.r,l=(Math.floor((St.bitLength(o)-1)/64)+1)*8;await e.writeULE32(i),await yn(e,a,i),await e.writeULE32(l),await yn(e,o,l),await e.writeULE32(t.nVars),await e.writeULE32(t.nPublic),await e.writeULE32(t.domainSize),await ia(e,n,t.vk_alpha_1),await ia(e,n,t.vk_beta_1),await ja(e,n,t.vk_beta_2),await ja(e,n,t.vk_gamma_2),await ia(e,n,t.vk_delta_1),await ja(e,n,t.vk_delta_2),await Ut(e)}async function ia(e,t,n){const a=new Uint8Array(t.G1.F.n8*2);t.G1.toRprLEM(a,0,n),await e.write(a)}async function ja(e,t,n){const a=new Uint8Array(t.G2.F.n8*2);t.G2.toRprLEM(a,0,n),await e.write(a)}async function on(e,t,n){const a=await e.read(t.G1.F.n8*2),i=t.G1.fromRprLEM(a,0);return n?t.G1.toObject(i):i}async function Dn(e,t,n){const a=await e.read(t.G2.F.n8*2),i=t.G2.fromRprLEM(a,0);return n?t.G2.toObject(i):i}async function Cn(e,t,n,a){await Wt(e,t,1);const i=await e.readULE32();if(await Qt(e),i===ur)return await pr(e,t,n,a);if(i===fr)return await wr(e,t,n,a);if(i===Ma)return await Lr(e,t,n,a);throw new Error("Protocol not supported: ")}async function pr(e,t,n,a){const i={};i.protocol="groth16",await Wt(e,t,2);const o=await e.readULE32();i.n8q=o,i.q=await En(e,o);const l=await e.readULE32();return i.n8r=l,i.r=await En(e,l),i.curve=await hn(i.q,a),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=Vn(i.domainSize),i.vk_alpha_1=await on(e,i.curve,n),i.vk_beta_1=await on(e,i.curve,n),i.vk_beta_2=await Dn(e,i.curve,n),i.vk_gamma_2=await Dn(e,i.curve,n),i.vk_delta_1=await on(e,i.curve,n),i.vk_delta_2=await Dn(e,i.curve,n),await Qt(e),i}async function wr(e,t,n,a){const i={};i.protocol="plonk",await Wt(e,t,2);const o=await e.readULE32();i.n8q=o,i.q=await En(e,o);const l=await e.readULE32();return i.n8r=l,i.r=await En(e,l),i.curve=await hn(i.q,a),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=Vn(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(l),i.k2=await e.read(l),i.Qm=await on(e,i.curve,n),i.Ql=await on(e,i.curve,n),i.Qr=await on(e,i.curve,n),i.Qo=await on(e,i.curve,n),i.Qc=await on(e,i.curve,n),i.S1=await on(e,i.curve,n),i.S2=await on(e,i.curve,n),i.S3=await on(e,i.curve,n),i.X_2=await Dn(e,i.curve,n),await Qt(e),i}async function Lr(e,t,n,a){const i={};i.protocol="fflonk",i.protocolId=Ma,await Wt(e,t,Wi);const o=await e.readULE32();i.n8q=o,i.q=await En(e,o),i.curve=await hn(i.q,a);const l=await e.readULE32();return i.n8r=l,i.r=await En(e,l),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=Vn(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstraints=await e.readULE32(),i.k1=await e.read(l),i.k2=await e.read(l),i.w3=await e.read(l),i.w4=await e.read(l),i.w8=await e.read(l),i.wr=await e.read(l),i.X_2=await Dn(e,i.curve,n),i.C0=await on(e,i.curve,n),await Qt(e),i}async function gr(e,t){const{fd:n,sections:a}=await Ht(e,"zkey",1),i=await Cn(n,a,t),o=new ce(i.r),l=St.mod(St.shl(1,i.n8r*8),i.r),s=o.inv(l),f=o.mul(s,s);let r=await hn(i.q);await Wt(n,a,3),i.IC=[];for(let b=0;b<=i.nPublic;b++){const w=await on(n,r,t);i.IC.push(w)}await Qt(n),await Wt(n,a,4);const c=await n.readULE32();i.ccoefs=[];for(let b=0;b<c;b++){const w=await n.readULE32(),A=await n.readULE32(),x=await n.readULE32(),v=await u();i.ccoefs.push({matrix:w,constraint:A,signal:x,value:v})}await Qt(n),await Wt(n,a,5),i.A=[];for(let b=0;b<i.nVars;b++){const w=await on(n,r,t);i.A[b]=w}await Qt(n),await Wt(n,a,6),i.B1=[];for(let b=0;b<i.nVars;b++){const w=await on(n,r,t);i.B1[b]=w}await Qt(n),await Wt(n,a,7),i.B2=[];for(let b=0;b<i.nVars;b++){const w=await Dn(n,r,t);i.B2[b]=w}await Qt(n),await Wt(n,a,8),i.C=[];for(let b=i.nPublic+1;b<i.nVars;b++){const w=await on(n,r,t);i.C[b]=w}await Qt(n),await Wt(n,a,9),i.hExps=[];for(let b=0;b<i.domainSize;b++){const w=await on(n,r,t);i.hExps.push(w)}return await Qt(n),await n.close(),i;async function u(){const b=await En(n,i.n8r);return o.mul(b,f)}}async function mr(e,t,n){const a={delta:{}};a.deltaAfter=await on(e,t,n),a.delta.g1_s=await on(e,t,n),a.delta.g1_sx=await on(e,t,n),a.delta.g2_spx=await Dn(e,t,n),a.transcript=await e.read(64),a.type=await e.readULE32();const i=await e.readULE32(),o=e.pos;let l=0;for(;e.pos-o<i;){const s=await e.read(1);if(s[0]<=l)throw new Error("Parameters in the contribution must be sorted");if(l=s[0],s[0]==1){const f=await e.read(1),r=await e.read(f[0]);a.name=new TextDecoder().decode(r)}else if(s[0]==2){const f=await e.read(1);a.numIterationsExp=f[0]}else if(s[0]==3){const f=await e.read(1);a.beaconHash=await e.read(f[0])}else throw new Error("Parameter not recognized")}if(e.pos!=o+i)throw new Error("Parameters do not match");return a}async function ca(e,t,n){await Wt(e,n,10);const a={contributions:[]};a.csHash=await e.read(64);const i=await e.readULE32();for(let o=0;o<i;o++){const l=await mr(e,t);a.contributions.push(l)}return await Qt(e),a}async function br(e,t,n){await ia(e,t,n.deltaAfter),await ia(e,t,n.delta.g1_s),await ia(e,t,n.delta.g1_sx),await ja(e,t,n.delta.g2_spx),await e.write(n.transcript),await e.writeULE32(n.type||0);const a=[];if(n.name){a.push(1);const i=new TextEncoder("utf-8").encode(n.name.substring(0,64));a.push(i.byteLength);for(let o=0;o<i.byteLength;o++)a.push(i[o])}if(n.type==1){a.push(2),a.push(n.numIterationsExp),a.push(3),a.push(n.beaconHash.byteLength);for(let i=0;i<n.beaconHash.byteLength;i++)a.push(n.beaconHash[i])}if(a.length>0){const i=new Uint8Array(a);await e.writeULE32(i.byteLength),await e.write(i)}else await e.writeULE32(0)}async function ge(e,t,n){await Mt(e,10),await e.write(n.csHash),await e.writeULE32(n.contributions.length);for(let a=0;a<n.contributions.length;a++)await br(e,t,n.contributions[a]);await Ut(e)}function bn(e,t,n){const a=new Uint8Array(t.G1.F.n8*2);t.G1.toRprUncompressed(a,0,n),e.update(a)}function yr(e,t,n){const a=new Uint8Array(t.G2.F.n8*2);t.G2.toRprUncompressed(a,0,n),e.update(a)}function kn(e,t,n){bn(e,t,n.deltaAfter),bn(e,t,n.delta.g1_s),bn(e,t,n.delta.g1_sx),yr(e,t,n.delta.g2_spx),e.update(n.transcript)}async function Cr(e,t,n){await Mt(e,1);const a=(Math.floor((St.bitLength(n)-1)/64)+1)*8;await e.writeULE32(a),await yn(e,n,a),await e.writeULE32(t.length),await Ut(e),await Mt(e,2);for(let i=0;i<t.length;i++)await yn(e,t[i],a);await Ut(e)}async function Fr(e,t,n){await Mt(e,1);const a=(Math.floor((St.bitLength(n)-1)/64)+1)*8;if(await e.writeULE32(a),await yn(e,n,a),t.byteLength%a!=0)throw new Error("Invalid witness length");await e.writeULE32(t.byteLength/a),await Ut(e),await Mt(e,2),await e.write(t),await Ut(e)}async function Ua(e,t){await Wt(e,t,1);const n=await e.readULE32(),a=await En(e,n),i=await e.readULE32();return await Qt(e),{n8:n,q:a,nWitness:i}}async function Sr(e){const{fd:t,sections:n}=await Ht(e,"wtns",2),{n8:a,nWitness:i}=await Ua(t,n);await Wt(t,n,2);const o=[];for(let l=0;l<i;l++){const s=await En(t,a);o.push(s)}return await Qt(t),await t.close(),o}const{stringifyBigInts:ao}=rn;async function hs(e,t,n,a){const{fd:i,sections:o}=await Ht(t,"wtns",2),l=await Ua(i,o),{fd:s,sections:f}=await Ht(e,"zkey",2),r=await Cn(s,f,void 0,a);if(r.protocol!="groth16")throw new Error("zkey file is not groth16");if(!St.eq(r.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!=r.nVars)throw new Error(`Invalid witness length. Circuit: ${r.nVars}, witness: ${l.nWitness}`);const c=r.curve,u=c.Fr,b=c.G1,w=c.G2,A=Vn(r.domainSize);n&&n.debug("Reading Wtns");const x=await Zt(i,o,2);n&&n.debug("Reading Coeffs");const v=await Zt(s,f,4);n&&n.debug("Building ABC");const[F,y,B]=await vr(c,r,x,v,n),P=A==u.s?c.Fr.shift:c.Fr.w[A+1],T=await u.ifft(F,"","",n,"IFFT_A"),C=await u.batchApplyKey(T,u.e(1),P),_=await u.fft(C,"","",n,"FFT_A"),g=await u.ifft(y,"","",n,"IFFT_B"),$=await u.batchApplyKey(g,u.e(1),P),Z=await u.fft($,"","",n,"FFT_B"),j=await u.ifft(B,"","",n,"IFFT_C"),O=await u.batchApplyKey(j,u.e(1),P),E=await u.fft(O,"","",n,"FFT_C");n&&n.debug("Join ABC");const q=await Er(c,r,_,Z,E,n);let M={};n&&n.debug("Reading A Points");const Q=await Zt(s,f,5);M.pi_a=await c.G1.multiExpAffine(Q,x,n,"multiexp A"),n&&n.debug("Reading B1 Points");const D=await Zt(s,f,6);let V=await c.G1.multiExpAffine(D,x,n,"multiexp B1");n&&n.debug("Reading B2 Points");const nt=await Zt(s,f,7);M.pi_b=await c.G2.multiExpAffine(nt,x,n,"multiexp B2"),n&&n.debug("Reading C Points");const R=await Zt(s,f,8);M.pi_c=await c.G1.multiExpAffine(R,x.slice((r.nPublic+1)*c.Fr.n8),n,"multiexp C"),n&&n.debug("Reading H Points");const at=await Zt(s,f,9),J=await c.G1.multiExpAffine(at,q,n,"multiexp H"),k=c.Fr.random(),K=c.Fr.random();M.pi_a=b.add(M.pi_a,r.vk_alpha_1),M.pi_a=b.add(M.pi_a,b.timesFr(r.vk_delta_1,k)),M.pi_b=w.add(M.pi_b,r.vk_beta_2),M.pi_b=w.add(M.pi_b,w.timesFr(r.vk_delta_2,K)),V=b.add(V,r.vk_beta_1),V=b.add(V,b.timesFr(r.vk_delta_1,K)),M.pi_c=b.add(M.pi_c,J),M.pi_c=b.add(M.pi_c,b.timesFr(M.pi_a,K)),M.pi_c=b.add(M.pi_c,b.timesFr(V,k)),M.pi_c=b.add(M.pi_c,b.timesFr(r.vk_delta_1,u.neg(u.mul(k,K))));let I=[];for(let d=1;d<=r.nPublic;d++){const S=x.slice(d*u.n8,d*u.n8+u.n8);I.push(St.fromRprLE(S))}return M.pi_a=b.toObject(b.toAffine(M.pi_a)),M.pi_b=w.toObject(w.toAffine(M.pi_b)),M.pi_c=b.toObject(b.toAffine(M.pi_c)),M.protocol="groth16",M.curve=c.name,await s.close(),await i.close(),M=ao(M),I=ao(I),{proof:M,publicSignals:I}}async function vr(e,t,n,a,i){const o=e.Fr.n8,l=12+t.n8r,s=(a.byteLength-4)/l,f=new ut(t.domainSize*o),r=new ut(t.domainSize*o),c=new ut(t.domainSize*o),u=[f,r];for(let b=0;b<s;b++){i&&b%1e6==0&&i.debug(`QAP AB: ${b}/${s}`);const w=a.slice(4+b*l,4+b*l+l),A=new DataView(w.buffer),x=A.getUint32(0,!0),v=A.getUint32(4,!0),F=A.getUint32(8,!0),y=w.slice(12,12+o);u[x].set(e.Fr.add(u[x].slice(v*o,v*o+o),e.Fr.mul(y,n.slice(F*o,F*o+o))),v*o)}for(let b=0;b<t.domainSize;b++)i&&b%1e6==0&&i.debug(`QAP C: ${b}/${t.domainSize}`),c.set(e.Fr.mul(f.slice(b*o,b*o+o),r.slice(b*o,b*o+o)),b*o);return[f,r,c]}async function Er(e,t,n,a,i,o){const s=e.Fr.n8,f=Math.floor(n.byteLength/e.Fr.n8),r=[];for(let w=0;w<f;w+=4194304){o&&o.debug(`JoinABC: ${w}/${f}`);const A=Math.min(f-w,4194304),x=[],v=n.slice(w*s,(w+A)*s),F=a.slice(w*s,(w+A)*s),y=i.slice(w*s,(w+A)*s);x.push({cmd:"ALLOCSET",var:0,buff:v}),x.push({cmd:"ALLOCSET",var:1,buff:F}),x.push({cmd:"ALLOCSET",var:2,buff:y}),x.push({cmd:"ALLOC",var:3,len:A*s}),x.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:A},{var:3}]}),x.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:A},{var:3}]}),x.push({cmd:"GET",out:0,var:3,len:A*s}),r.push(e.tm.queueAction(x))}const c=await Promise.all(r);let u;n instanceof ut?u=new ut(n.byteLength):u=new Uint8Array(n.byteLength);let b=0;for(let w=0;w<c.length;w++)u.set(c[w][0],b),b+=c[w][0].byteLength;return u}function ps(e){let t=[];return n(t,e),t;function n(a,i){if(Array.isArray(i))for(let o=0;o<i.length;o++)n(a,i[o]);else a.push(i)}}function Ar(e,t){let n=BigInt(e)%t;return n<0&&(n+=t),n}function ws(e){const t=BigInt(2)**BigInt(64);let n=BigInt("0xCBF29CE484222325");for(let o=0;o<e.length;o++)n^=BigInt(e[o].charCodeAt(0)),n*=BigInt(1099511628211),n%=t;let a=n.toString(16),i=16-a.length;return a="0".repeat(i).concat(a),a}function xr(e,t){const n=[];let a=BigInt(e);const i=BigInt(4294967296);for(;a;)n.unshift(Number(a%i)),a=a/i;if(t){let o=t-n.length;for(;o>0;)n.unshift(0),o--}return n}async function Ls(e,t){let n,a,i;t=t||{};let o=1,l=0,s=0,f=!1;if(e instanceof WebAssembly.Instance)n=e,f=!0;else{let b=32767;if(t.memorySize&&(b=parseInt(t.memorySize),b<0))throw new Error("Invalid memory size");let w=!1;for(;!w;)try{i=new WebAssembly.Memory({initial:b}),w=!0}catch(F){if(b<=1)throw F;console.warn("Could not allocate "+b*1024*64+" bytes. This may cause severe instability. Trying with "+b*1024*64/2+" bytes"),b=Math.floor(b/2)}const A=await WebAssembly.compile(e);let x="",v="";n=await WebAssembly.instantiate(A,{env:{memory:i},runtime:{printDebug:function(F){console.log("printDebug:",F)},exceptionHandler:function(F){let y;throw F===1?y="Signal not found. ":F===2?y="Too many signals set. ":F===3?y="Signal already set. ":F===4?y="Assert Failed. ":F===5?y="Not enough memory. ":F===6?y="Input signal array access exceeds the size. ":y="Unknown error. ",console.error("ERROR: ",F,x),new Error(y+x)},printErrorMessage:function(){x+=c()+`
`},writeBufferMessage:function(){const F=c();F===`
`?(console.log(v),v=""):(v!==""&&(v+=" "),v+=F)},showSharedRWMemory:function(){const F=n.exports.getFieldNumLen32(),y=new Uint32Array(F);for(let B=0;B<F;B++)y[F-1-B]=n.exports.readSharedRWMemory(B);if(o>=2&&(l>=1||s>=7)){v!==""&&(v+=" ");const B=St.fromArray(y,4294967296).toString();v+=B}else console.log(St.fromArray(y,4294967296))},error:function(F,y,B,P,T,C){let _;throw F===7?_=u(y)+" "+a.getFr(P).toString()+" != "+a.getFr(T).toString()+" "+u(C):F===9?_=u(y)+" "+a.getFr(P).toString()+" "+u(T):F===5&&t.sym?_=u(y)+" "+t.sym.labelIdx2Name[T]:_=u(y)+" "+B+" "+P+" "+T+" "+C,console.log("ERROR: ",F,_),new Error(_)},log:function(F){console.log(a.getFr(F).toString())},logGetSignal:function(F,y){t.logGetSignal&&t.logGetSignal(F,a.getFr(y))},logSetSignal:function(F,y){t.logSetSignal&&t.logSetSignal(F,a.getFr(y))},logStartComponent:function(F){t.logStartComponent&&t.logStartComponent(F)},logFinishComponent:function(F){t.logFinishComponent&&t.logFinishComponent(F)}}})}typeof n.exports.getVersion=="function"&&(o=n.exports.getVersion()),typeof n.exports.getMinorVersion=="function"&&(l=n.exports.getMinorVersion()),typeof n.exports.getPatchVersion=="function"&&(s=n.exports.getPatchVersion());const r=t&&(t.sanityCheck||t.logGetSignal||t.logSetSignal||t.logStartComponent||t.logFinishComponent);if(o===2)a=new Ir(n,r);else if(o===1){if(f)throw new Error("Loading code from WebAssembly instance is not supported for circom version 1");a=new Br(i,n,r)}else throw new Error(`Unsupported circom version: ${o}`);return a;function c(){let b="",w=n.exports.getMessageChar();for(;w!==0;)b+=String.fromCharCode(w),w=n.exports.getMessageChar();return b}function u(b){const w=new Uint8Array(i.buffer),A=[];for(let x=0;w[b+x]>0;x++)A.push(w[b+x]);return String.fromCharCode.apply(null,A)}}class Br{constructor(t,n,a){this.memory=t,this.i32=new Uint32Array(t.buffer),this.instance=n,this.n32=(this.instance.exports.getFrLen()>>2)-2;const i=this.instance.exports.getPRawPrime(),o=new Array(this.n32);for(let l=0;l<this.n32;l++)o[this.n32-1-l]=this.i32[(i>>2)+l];this.prime=St.fromArray(o,4294967296),this.Fr=new ce(this.prime),this.mask32=St.fromString("FFFFFFFF",16),this.NVars=this.instance.exports.getNVars(),this.n64=Math.floor((this.Fr.bitLength-1)/64)+1,this.R=this.Fr.e(St.shiftLeft(1,this.n64*64)),this.RInv=this.Fr.inv(this.R),this.sanityCheck=a}circom_version(){return 1}async _doCalculateWitness(t,n){this.instance.exports.init(this.sanityCheck||n?1:0);const a=this.allocInt(),i=this.allocFr();Object.keys(t).forEach(l=>{const s=ws(l),f=parseInt(s.slice(0,8),16),r=parseInt(s.slice(8,16),16);try{this.instance.exports.getSignalOffset32(a,0,f,r)}catch{throw new Error(`Signal ${l} is not an input of the circuit.`)}const c=this.getInt(a),u=ps(t[l]);for(let b=0;b<u.length;b++)this.setFr(i,u[b]),this.instance.exports.setSignal(0,0,c+b,i)})}async calculateWitness(t,n){const a=this,i=a.i32[0],o=[];await a._doCalculateWitness(t,n);for(let l=0;l<a.NVars;l++){const s=a.instance.exports.getPWitness(l);o.push(a.getFr(s))}return a.i32[0]=i,o}async calculateBinWitness(t,n){const a=this,i=a.i32[0];await a._doCalculateWitness(t,n);const o=a.instance.exports.getWitnessBuffer();a.i32[0]=i;const l=a.memory.buffer.slice(o,o+a.NVars*a.n64*8);return new Uint8Array(l)}allocInt(){const t=this.i32[0];return this.i32[0]=t+8,t}allocFr(){const t=this.i32[0];return this.i32[0]=t+this.n32*4+8,t}getInt(t){return this.i32[t>>2]}setInt(t,n){this.i32[t>>2]=n}getFr(t){const n=this,a=t>>2;if(n.i32[a+1]&2147483648){const o=new Array(n.n32);for(let s=0;s<n.n32;s++)o[n.n32-1-s]=n.i32[a+2+s];const l=n.Fr.e(St.fromArray(o,4294967296));return n.i32[a+1]&1073741824?i(l):l}else return n.i32[a]&2147483648?n.Fr.e(n.i32[a]-4294967296):n.Fr.e(n.i32[a]);function i(o){return n.Fr.mul(n.RInv,o)}}setFr(t,n){const a=this;n=a.Fr.e(n);const i=a.Fr.neg(a.Fr.e("80000000",16)),o=a.Fr.e("7FFFFFFF",16);if(a.Fr.geq(n,i)&&a.Fr.leq(n,o)){let s;a.Fr.geq(n,a.Fr.zero)?s=St.toNumber(n):(s=St.toNumber(a.Fr.sub(n,i)),s=s-2147483648,s=4294967296+s),a.i32[t>>2]=s,a.i32[(t>>2)+1]=0;return}a.i32[t>>2]=0,a.i32[(t>>2)+1]=2147483648;const l=St.toArray(n,4294967296);for(let s=0;s<a.n32;s++){const f=l.length-1-s;f>=0?a.i32[(t>>2)+2+s]=l[f]:a.i32[(t>>2)+2+s]=0}}}class Ir{constructor(t,n){this.instance=t,this.version=this.instance.exports.getVersion(),this.n32=this.instance.exports.getFieldNumLen32(),this.instance.exports.getRawPrime();const a=new Uint32Array(this.n32);for(let i=0;i<this.n32;i++)a[this.n32-1-i]=this.instance.exports.readSharedRWMemory(i);this.prime=St.fromArray(a,4294967296),this.witnessSize=this.instance.exports.getWitnessSize(),this.sanityCheck=n}circom_version(){return this.instance.exports.getVersion()}async _doCalculateWitness(t,n){this.instance.exports.init(this.sanityCheck||n?1:0);const a=Object.keys(t);let i=0;if(a.forEach(o=>{const l=ws(o),s=parseInt(l.slice(0,8),16),f=parseInt(l.slice(8,16),16),r=ps(t[o]);if(typeof this.instance.exports.getInputSignalSize=="function"){let c=this.instance.exports.getInputSignalSize(s,f);if(c<0)throw new Error(`Signal ${o} not found
`);if(r.length<c)throw new Error(`Not enough values for input signal ${o}
`);if(r.length>c)throw new Error(`Too many values for input signal ${o}
`)}for(let c=0;c<r.length;c++){const u=xr(Ar(r[c],this.prime),this.n32);for(let b=0;b<this.n32;b++)this.instance.exports.writeSharedRWMemory(b,u[this.n32-1-b]);try{this.instance.exports.setInputSignal(s,f,c),i++}catch(b){throw new Error(b)}}}),i<this.instance.exports.getInputSize())throw new Error(`Not all inputs have been set. Only ${i} out of ${this.instance.exports.getInputSize()}`)}async calculateWitness(t,n){const a=[];await this._doCalculateWitness(t,n);for(let i=0;i<this.witnessSize;i++){this.instance.exports.getWitness(i);const o=new Uint32Array(this.n32);for(let l=0;l<this.n32;l++)o[this.n32-1-l]=this.instance.exports.readSharedRWMemory(l);a.push(St.fromArray(o,4294967296))}return a}async calculateWTNSBin(t,n){const a=new Uint32Array(this.witnessSize*this.n32+this.n32+11),i=new Uint8Array(a.buffer);await this._doCalculateWitness(t,n),i[0]=119,i[1]=116,i[2]=110,i[3]=115,a[1]=2,a[2]=2,a[3]=1;const o=this.n32*4,s=(8+o).toString(16);a[4]=parseInt(s.slice(0,8),16),a[5]=parseInt(s.slice(8,16),16),a[6]=o,this.instance.exports.getRawPrime();let f=7;for(let u=0;u<this.n32;u++)a[f+u]=this.instance.exports.readSharedRWMemory(u);f+=this.n32,a[f]=this.witnessSize,f++,a[f]=2,f++;const c=(o*this.witnessSize).toString(16);a[f]=parseInt(c.slice(0,8),16),a[f+1]=parseInt(c.slice(8,16),16),f+=2;for(let u=0;u<this.witnessSize;u++){this.instance.exports.getWitness(u);for(let b=0;b<this.n32;b++)a[f+b]=this.instance.exports.readSharedRWMemory(b);f+=this.n32}return i}}const{unstringifyBigInts:Pr}=rn;async function ci(e,t,n,a){const i=Pr(e),o=await Nn(t),l=await o.read(o.totalSize);await o.close();const s=await Ls(l,a);if(s.circom_version()===1){const f=await s.calculateBinWitness(i),r=await _n(n,"wtns",2,2);await Fr(r,f,s.prime),await r.close()}else{const f=await ra(n),r=await s.calculateWTNSBin(i);await f.write(r),await f.close()}}const{unstringifyBigInts:Gr}=rn;async function Tr(e,t,n,a,i,o){const l=Gr(e),s={type:"mem"};return await ci(l,t,s,i),await hs(n,s,a,o)}const{unstringifyBigInts:Si}=rn;async function Or(e,t,n,a){const i=Si(e),o=Si(n),l=Si(t),s=await Yn(i.curve),f=s.G1.fromObject(i.IC[0]),r=new Uint8Array(s.G1.F.n8*2*l.length),c=new Uint8Array(s.Fr.n8*l.length);if(!Mr(s,l))return a&&a.error("Public inputs are not valid."),!1;for(let P=0;P<l.length;P++){const T=s.G1.fromObject(i.IC[P+1]);r.set(T,P*s.G1.F.n8*2),St.toRprLE(c,s.Fr.n8*P,l[P],s.Fr.n8)}let u=await s.G1.multiExpAffine(r,c);u=s.G1.add(u,f);const b=s.G1.fromObject(o.pi_a),w=s.G2.fromObject(o.pi_b),A=s.G1.fromObject(o.pi_c);if(!zr(s,{pi_a:b,pi_b:w,pi_c:A}))return a&&a.error("Proof commitments are not valid."),!1;const x=s.G2.fromObject(i.vk_gamma_2),v=s.G2.fromObject(i.vk_delta_2),F=s.G1.fromObject(i.vk_alpha_1),y=s.G2.fromObject(i.vk_beta_2);return await s.pairingEq(s.G1.neg(b),w,u,x,A,v,F,y)?(a&&a.info("OK!"),!0):(a&&a.error("Invalid proof"),!1)}function zr(e,t){const n=e.G1,a=e.G2;return n.isValid(t.pi_a)&&a.isValid(t.pi_b)&&n.isValid(t.pi_c)}function qr(e,t){return St.geq(t,0)&&St.lt(t,e.r)}function Mr(e,t){for(let n=0;n<t.length;n++)if(!qr(e,t[n]))return!1;return!0}const{unstringifyBigInts:io}=rn;function xn(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function Ur(e,t){const n=io(e),a=io(t);let i="";for(let l=0;l<a.length;l++)i!=""&&(i=i+","),i=i+xn(a[l]);let o;return o=`[${xn(n.pi_a[0])}, ${xn(n.pi_a[1])}],[[${xn(n.pi_b[0][1])}, ${xn(n.pi_b[0][0])}],[${xn(n.pi_b[1][1])}, ${xn(n.pi_b[1][0])}]],[${xn(n.pi_c[0])}, ${xn(n.pi_c[1])}],[${i}]`,o}var Ou=Object.freeze({__proto__:null,fullProve:Tr,prove:hs,verify:Or,exportSolidityCallData:Ur});function Ra(e,t){const n=new DataView(t.buffer,t.byteOffset,t.byteLength),a=[];for(let l=0;l<8;l++)a[l]=n.getUint32(l*4);const i=new Kn(a);return e.G2.fromRng(i)}function Ha(e,t,n,a,i){const o=Yt.create({dkLen:64}),l=new Uint8Array([t]);o.update(l),o.update(n);const s=e.G1.toUncompressed(a);o.update(s);const f=e.G1.toUncompressed(i);o.update(f);const r=o.digest();return Ra(e,r)}function vi(e,t,n,a,i){return e.g1_s=t.G1.toAffine(t.G1.fromRng(i)),e.g1_sx=t.G1.toAffine(t.G1.timesFr(e.g1_s,e.prvKey)),e.g2_sp=t.G2.toAffine(Ha(t,n,a,e.g1_s,e.g1_sx)),e.g2_spx=t.G2.toAffine(t.G2.timesFr(e.g2_sp,e.prvKey)),e}function me(e,t,n){const a={tau:{},alpha:{},beta:{}};return a.tau.prvKey=e.Fr.fromRng(n),a.alpha.prvKey=e.Fr.fromRng(n),a.beta.prvKey=e.Fr.fromRng(n),vi(a.tau,e,0,t,n),vi(a.alpha,e,1,t,n),vi(a.beta,e,2,t,n),a}async function Jn(e,t,n,a){a||(a=n),await e.writeULE32(1);const i=e.pos;await e.writeULE64(0),await e.writeULE32(t.F1.n64*8);const o=new Uint8Array(t.F1.n8);St.toRprLE(o,0,t.q,t.F1.n8),await e.write(o),await e.writeULE32(n),await e.writeULE32(a);const l=e.pos-i-8,s=e.pos;await e.writeULE64(l,i),e.pos=s}async function gn(e,t){if(!t[1])throw new Error(e.fileName+": File has no  header");if(t[1].length>1)throw new Error(e.fileName+": File has more than one header");e.pos=t[1][0].p;const n=await e.readULE32(),a=await e.read(n),i=St.fromRprLE(a),o=await hn(i);if(o.F1.n64*8!=n)throw new Error(e.fileName+": Invalid size");const l=await e.readULE32(),s=await e.readULE32();if(e.pos-t[1][0].p!=t[1][0].size)throw new Error("Invalid PTau header size");return{curve:o,power:l,ceremonyPower:s}}async function Rr(e,t,n){const a=await e.read(t.F1.n8*2*6+t.F2.n8*2*3);return gs(a,0,t,n)}function gs(e,t,n,a){const i={tau:{},alpha:{},beta:{}};return i.tau.g1_s=o(),i.tau.g1_sx=o(),i.alpha.g1_s=o(),i.alpha.g1_sx=o(),i.beta.g1_s=o(),i.beta.g1_sx=o(),i.tau.g2_spx=l(),i.alpha.g2_spx=l(),i.beta.g2_spx=l(),i;function o(){let s;return a?s=n.G1.fromRprLEM(e,t):s=n.G1.fromRprUncompressed(e,t),t+=n.G1.F.n8*2,s}function l(){let s;return a?s=n.G2.fromRprLEM(e,t):s=n.G2.fromRprUncompressed(e,t),t+=n.G2.F.n8*2,s}}function da(e,t,n,a,i){o(a.tau.g1_s),o(a.tau.g1_sx),o(a.alpha.g1_s),o(a.alpha.g1_sx),o(a.beta.g1_s),o(a.beta.g1_sx),l(a.tau.g2_spx),l(a.alpha.g2_spx),l(a.beta.g2_spx);async function o(s){i?n.G1.toRprLEM(e,t,s):n.G1.toRprUncompressed(e,t,s),t+=n.F1.n8*2}async function l(s){i?n.G2.toRprLEM(e,t,s):n.G2.toRprUncompressed(e,t,s),t+=n.F2.n8*2}return e}async function kr(e,t,n,a){const i=new Uint8Array(t.F1.n8*2*6+t.F2.n8*2*3);da(i,0,t,n,a),await e.write(i)}async function $r(e,t){const n={};n.tauG1=await f(),n.tauG2=await r(),n.alphaG1=await f(),n.betaG1=await f(),n.betaG2=await r(),n.key=await Rr(e,t,!0),n.partialHash=await e.read(216),n.nextChallenge=await e.read(64),n.type=await e.readULE32();const a=new Uint8Array(t.G1.F.n8*2*6+t.G2.F.n8*2*3);da(a,0,t,n.key,!1);const i=ds(n.partialHash);i.update(a),n.responseHash=i.digest();const o=await e.readULE32(),l=e.pos;let s=0;for(;e.pos-l<o;){const u=await c(1);if(u[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=u[0],u[0]==1){const b=await c(1),w=await c(b[0]);n.name=new TextDecoder().decode(w)}else if(u[0]==2){const b=await c(1);n.numIterationsExp=b[0]}else if(u[0]==3){const b=await c(1);n.beaconHash=await c(b[0])}else throw new Error("Parameter not recognized")}if(e.pos!=l+o)throw new Error("Parameters do not match");return n;async function f(){const u=await e.read(t.G1.F.n8*2);return t.G1.fromRprLEM(u)}async function r(){const u=await e.read(t.G2.F.n8*2);return t.G2.fromRprLEM(u)}async function c(u){const b=await e.read(u);return new Uint8Array(b)}}async function ua(e,t,n){if(!n[7])throw new Error(e.fileName+": File has no  contributions");if(n[7][0].length>1)throw new Error(e.fileName+": File has more than one contributions section");e.pos=n[7][0].p;const a=await e.readULE32(),i=[];for(let o=0;o<a;o++){const l=await $r(e,t);l.id=o+1,i.push(l)}if(e.pos-n[7][0].p!=n[7][0].size)throw new Error("Invalid contribution section size");return i}async function Nr(e,t,n){const a=new Uint8Array(t.F1.n8*2),i=new Uint8Array(t.F2.n8*2);await l(n.tauG1),await s(n.tauG2),await l(n.alphaG1),await l(n.betaG1),await s(n.betaG2),await kr(e,t,n.key,!0),await e.write(n.partialHash),await e.write(n.nextChallenge),await e.writeULE32(n.type||0);const o=[];if(n.name){o.push(1);const f=new TextEncoder("utf-8").encode(n.name.substring(0,64));o.push(f.byteLength);for(let r=0;r<f.byteLength;r++)o.push(f[r])}if(n.type==1){o.push(2),o.push(n.numIterationsExp),o.push(3),o.push(n.beaconHash.byteLength);for(let f=0;f<n.beaconHash.byteLength;f++)o.push(n.beaconHash[f])}if(o.length>0){const f=new Uint8Array(o);await e.writeULE32(f.byteLength),await e.write(f)}else await e.writeULE32(0);async function l(f){t.G1.toRprLEM(a,0,f),await e.write(a)}async function s(f){t.G2.toRprLEM(i,0,f),await e.write(i)}}async function be(e,t,n){await e.writeULE32(7);const a=e.pos;await e.writeULE64(0),await e.writeULE32(n.length);for(let l=0;l<n.length;l++)await Nr(e,t,n[l]);const i=e.pos-a-8,o=e.pos;await e.writeULE64(i,a),e.pos=o}function fa(e,t,n){n&&n.debug("Calculating First Challenge Hash");const a=Yt.create({dkLen:64}),i=new Uint8Array(e.G1.F.n8*2),o=new Uint8Array(e.G2.F.n8*2);e.G1.toRprUncompressed(i,0,e.G1.g),e.G2.toRprUncompressed(o,0,e.G2.g),a.update(Yt.create({dkLen:64}).digest());let l;return l=2**t*2-1,n&&n.debug("Calculate Initial Hash: tauG1"),s(i,l),l=2**t,n&&n.debug("Calculate Initial Hash: tauG2"),s(o,l),n&&n.debug("Calculate Initial Hash: alphaTauG1"),s(i,l),n&&n.debug("Calculate Initial Hash: betaTauG1"),s(i,l),a.update(o),a.digest();function s(f,r){const u=Math.floor(r/341e3),b=r%341e3,w=new Uint8Array(341e3*f.byteLength);for(let A=0;A<341e3;A++)w.set(f,A*f.byteLength);for(let A=0;A<u;A++)a.update(w),n&&n.debug("Initial hash: "+A*341e3);for(let A=0;A<b;A++)a.update(f)}}async function ms(e,t,n,a){const i=await we(n,a);return me(e,t,i)}async function Vr(e,t,n,a){const i=await _n(n,"ptau",1,7);await Jn(i,e,t,0);const o=e.G1.oneAffine,l=e.G2.oneAffine;await Mt(i,2);const s=2**t*2-1;for(let b=0;b<s;b++)await i.write(o),a&&b%1e5==0&&b&&a.log("tauG1: "+b);await Ut(i),await Mt(i,3);const f=2**t;for(let b=0;b<f;b++)await i.write(l),a&&b%1e5==0&&b&&a.log("tauG2: "+b);await Ut(i),await Mt(i,4);const r=2**t;for(let b=0;b<r;b++)await i.write(o),a&&b%1e5==0&&b&&a.log("alphaTauG1: "+b);await Ut(i),await Mt(i,5);const c=2**t;for(let b=0;b<c;b++)await i.write(o),a&&b%1e5==0&&b&&a.log("betaTauG1: "+b);await Ut(i),await Mt(i,6),await i.write(l),await Ut(i),await Mt(i,7),await i.writeULE32(0),await Ut(i),await i.close();const u=fa(e,t,a);return a&&a.debug(an(Yt.create({dkLen:64}).digest(),"Blank Contribution Hash:")),a&&a.info(an(u,"First Contribution Hash:")),u}async function Zr(e,t,n){const{fd:a,sections:i}=await Ht(e,"ptau",1),{curve:o,power:l}=await gn(a,i),s=await ua(a,o,i);let f,r;s.length==0?(f=Yt.create({dkLen:64}).digest(),r=fa(o,l)):(f=s[s.length-1].responseHash,r=s[s.length-1].nextChallenge),n&&n.info(an(f,"Last Response Hash: ")),n&&n.info(an(r,"New Challenge Hash: "));const c=await ra(t),u=Yt.create({dkLen:64});await c.write(f),u.update(f),await w(2,"G1",2**l*2-1,"tauG1"),await w(3,"G2",2**l,"tauG2"),await w(4,"G1",2**l,"alphaTauG1"),await w(5,"G1",2**l,"betaTauG1"),await w(6,"G2",1,"betaG2"),await a.close(),await c.close();const b=u.digest();if(!Rn(r,b))throw n&&n.info(an(b,"Calc Curret Challenge Hash: ")),n&&n.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return r;async function w(A,x,v,F){const y=o[x],B=y.F.n8*2,P=Math.floor((1<<24)/B);await Wt(a,i,A);for(let T=0;T<v;T+=P){n&&n.debug(`Exporting ${F}: ${T}/${v}`);const C=Math.min(v-T,P);let _;_=await a.read(C*B),_=await y.batchLEMtoU(_),await c.write(_),u.update(_)}await Qt(a)}}async function jr(e,t,n,a,i,o){const l=new Uint8Array(64);for(let q=0;q<64;q++)l[q]=255;const{fd:s,sections:f}=await Ht(e,"ptau",1),{curve:r,power:c}=await gn(s,f),u=await ua(s,r,f),b={};a&&(b.name=a);const w=r.F1.n8*2,A=r.F1.n8,x=r.F2.n8*2,v=r.F2.n8,F=await Nn(t);if(F.totalSize!=64+(2**c*2-1)*A+2**c*v+2**c*A+2**c*A+v+w*6+x*3)throw new Error("Size of the contribution is invalid");let y;u.length>0?y=u[u.length-1].nextChallenge:y=fa(r,c,o);const B=await _n(n,"ptau",1,i?7:2);await Jn(B,r,c);const P=await F.read(64);if(Rn(l,y)&&(y=P,u[u.length-1].nextChallenge=y),!Rn(P,y))throw new Error("Wrong contribution. This contribution is not based on the previous hash");const T=Yt.create({dkLen:64});T.update(P);const C=[];let _;_=await Z(F,B,"G1",2,2**c*2-1,[1],"tauG1"),b.tauG1=_[0],_=await Z(F,B,"G2",3,2**c,[1],"tauG2"),b.tauG2=_[0],_=await Z(F,B,"G1",4,2**c,[0],"alphaG1"),b.alphaG1=_[0],_=await Z(F,B,"G1",5,2**c,[0],"betaG1"),b.betaG1=_[0],_=await Z(F,B,"G2",6,1,[0],"betaG2"),b.betaG2=_[0],b.partialHash=pe(T);const g=await F.read(r.F1.n8*2*6+r.F2.n8*2*3);b.key=gs(g,0,r,!1),T.update(new Uint8Array(g));const $=T.digest();if(o&&o.info(an($,"Contribution Response Hash imported: ")),i){const q=Yt.create({dkLen:64});q.update($),await E(q,B,"G1",2,2**c*2-1,"tauG1",o),await E(q,B,"G2",3,2**c,"tauG2",o),await E(q,B,"G1",4,2**c,"alphaTauG1",o),await E(q,B,"G1",5,2**c,"betaTauG1",o),await E(q,B,"G2",6,1,"betaG2",o),b.nextChallenge=q.digest(),o&&o.info(an(b.nextChallenge,"Next Challenge Hash: "))}else b.nextChallenge=l;return u.push(b),await be(B,r,u),await F.close(),await B.close(),await s.close(),b.nextChallenge;async function Z(q,M,Q,D,V,nt,R){return i?await j(q,M,Q,D,V,nt,R):await O(q,M,Q,D,V,nt,R)}async function j(q,M,Q,D,V,nt,R){const at=r[Q],J=at.F.n8,k=at.F.n8*2,K=[];await Mt(M,D);const I=Math.floor((1<<24)/k);C[D]=M.pos;for(let d=0;d<V;d+=I){o&&o.debug(`Importing ${R}: ${d}/${V}`);const S=Math.min(V-d,I),h=await q.read(S*J);T.update(h);const U=await at.batchCtoLEM(h);await M.write(U);for(let G=0;G<nt.length;G++){const m=nt[G];if(m>=d&&m<d+S){const z=at.fromRprLEM(U,(m-d)*k);K.push(z)}}}return await Ut(M),K}async function O(q,M,Q,D,V,nt,R){const at=r[Q],J=at.F.n8,k=[],K=Math.floor((1<<24)/J);for(let I=0;I<V;I+=K){o&&o.debug(`Importing ${R}: ${I}/${V}`);const d=Math.min(V-I,K),S=await q.read(d*J);T.update(S);for(let h=0;h<nt.length;h++){const U=nt[h];if(U>=I&&U<I+d){const G=at.fromRprCompressed(S,(U-I)*J);k.push(G)}}}return k}async function E(q,M,Q,D,V,nt,R){const at=r[Q],J=at.F.n8*2,k=Math.floor((1<<24)/J),K=M.pos;M.pos=C[D];for(let I=0;I<V;I+=k){R&&R.debug(`Hashing ${nt}: ${I}/${V}`);const d=Math.min(V-I,k),S=await M.read(d*J),h=await at.batchLEMtoU(S);q.update(h)}M.pos=K}}const Ln=us;async function eo(e,t,n,a){let i;if(t.type==1){const o=await ms(e,n.nextChallenge,t.beaconHash,t.numIterationsExp);if(!e.G1.eq(t.key.tau.g1_s,o.tau.g1_s))return a&&a.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.tau.g1_sx,o.tau.g1_sx))return a&&a.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.tau.g2_spx,o.tau.g2_spx))return a&&a.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.alpha.g1_s,o.alpha.g1_s))return a&&a.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.alpha.g1_sx,o.alpha.g1_sx))return a&&a.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.alpha.g2_spx,o.alpha.g2_spx))return a&&a.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.beta.g1_s,o.beta.g1_s))return a&&a.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.beta.g1_sx,o.beta.g1_sx))return a&&a.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.beta.g2_spx,o.beta.g2_spx))return a&&a.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1}return t.key.tau.g2_sp=e.G2.toAffine(Ha(e,0,n.nextChallenge,t.key.tau.g1_s,t.key.tau.g1_sx)),t.key.alpha.g2_sp=e.G2.toAffine(Ha(e,1,n.nextChallenge,t.key.alpha.g1_s,t.key.alpha.g1_sx)),t.key.beta.g2_sp=e.G2.toAffine(Ha(e,2,n.nextChallenge,t.key.beta.g1_s,t.key.beta.g1_sx)),i=await Ln(e,t.key.tau.g1_s,t.key.tau.g1_sx,t.key.tau.g2_sp,t.key.tau.g2_spx),i!==!0?(a&&a.error("INVALID key (tau) in challenge #"+t.id),!1):(i=await Ln(e,t.key.alpha.g1_s,t.key.alpha.g1_sx,t.key.alpha.g2_sp,t.key.alpha.g2_spx),i!==!0?(a&&a.error("INVALID key (alpha) in challenge #"+t.id),!1):(i=await Ln(e,t.key.beta.g1_s,t.key.beta.g1_sx,t.key.beta.g2_sp,t.key.beta.g2_spx),i!==!0?(a&&a.error("INVALID key (beta) in challenge #"+t.id),!1):(i=await Ln(e,n.tauG1,t.tauG1,t.key.tau.g2_sp,t.key.tau.g2_spx),i!==!0?(a&&a.error("INVALID tau*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(e,t.key.tau.g1_s,t.key.tau.g1_sx,n.tauG2,t.tauG2),i!==!0?(a&&a.error("INVALID tau*G2. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(e,n.alphaG1,t.alphaG1,t.key.alpha.g2_sp,t.key.alpha.g2_spx),i!==!0?(a&&a.error("INVALID alpha*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(e,n.betaG1,t.betaG1,t.key.beta.g2_sp,t.key.beta.g2_spx),i!==!0?(a&&a.error("INVALID beta*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(e,t.key.beta.g1_s,t.key.beta.g1_sx,n.betaG2,t.betaG2),i!==!0?(a&&a.error("INVALID beta*G2. challenge #"+t.id+"It does not follow the previous contribution"),!1):(a&&a.info("Powers Of tau file OK!"),!0))))))))}async function Hr(e,t){let n;const{fd:a,sections:i}=await Ht(e,"ptau",1),{curve:o,power:l,ceremonyPower:s}=await gn(a,i),f=await ua(a,o,i);t&&t.debug("power: 2**"+l),t&&t.debug("Computing initial contribution hash");const r={tauG1:o.G1.g,tauG2:o.G2.g,alphaG1:o.G1.g,betaG1:o.G1.g,betaG2:o.G2.g,nextChallenge:fa(o,s,t),responseHash:Yt.create({dkLen:64}).digest()};if(f.length==0)return t&&t.error("This file has no contribution! It cannot be used in production"),!1;let c;f.length>1?c=f[f.length-2]:c=r;const u=f[f.length-1];if(t&&t.debug("Validating contribution #"+f[f.length-1].id),!await eo(o,u,c,t))return!1;const w=Yt.create({dkLen:64});w.update(u.responseHash),t&&t.debug("Verifying powers in tau*G1 section");const A=await C(2,"G1","tauG1",2**l*2-1,[0,1],t);if(n=await Ln(o,A.R1,A.R2,o.G2.g,u.tauG2),n!==!0)return t&&t.error("tauG1 section. Powers do not match"),!1;if(!o.G1.eq(o.G1.g,A.singularPoints[0]))return t&&t.error("First element of tau*G1 section must be the generator"),!1;if(!o.G1.eq(u.tauG1,A.singularPoints[1]))return t&&t.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in tau*G2 section");const x=await C(3,"G2","tauG2",2**l,[0,1],t);if(n=await Ln(o,o.G1.g,u.tauG1,x.R1,x.R2),n!==!0)return t&&t.error("tauG2 section. Powers do not match"),!1;if(!o.G2.eq(o.G2.g,x.singularPoints[0]))return t&&t.error("First element of tau*G2 section must be the generator"),!1;if(!o.G2.eq(u.tauG2,x.singularPoints[1]))return t&&t.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in alpha*tau*G1 section");const v=await C(4,"G1","alphatauG1",2**l,[0],t);if(n=await Ln(o,v.R1,v.R2,o.G2.g,u.tauG2),n!==!0)return t&&t.error("alphaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(u.alphaG1,v.singularPoints[0]))return t&&t.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in beta*tau*G1 section");const F=await C(5,"G1","betatauG1",2**l,[0],t);if(n=await Ln(o,F.R1,F.R2,o.G2.g,u.tauG2),n!==!0)return t&&t.error("betaTauG1 section. Powers do not match"),!1;if(!o.G1.eq(u.betaG1,F.singularPoints[0]))return t&&t.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const y=await T(t);if(!o.G2.eq(u.betaG2,y))return t&&t.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const B=w.digest();if(l==s&&!Rn(B,u.nextChallenge))return t&&t.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;t&&t.info(an(B,"Next challenge hash: ")),P(u,c);for(let g=f.length-2;g>=0;g--){const $=f[g],Z=g>0?f[g-1]:r;if(!await eo(o,$,Z,t))return!1;P($,Z)}if(t&&t.info("-----------------------------------------------------"),!i[12]||!i[13]||!i[14]||!i[15])t&&t.warn(`this file does not contain phase2 precalculated values. Please run: 
   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.`);else{let g;if(g=await _("G1",2,12,"tauG1",t),!g||(g=await _("G2",3,13,"tauG2",t),!g)||(g=await _("G1",4,14,"alphaTauG1",t),!g)||(g=await _("G1",5,15,"betaTauG1",t),!g))return!1}return await a.close(),t&&t.info("Powers of Tau Ok!"),!0;function P(g,$){if(!t)return;t.info("-----------------------------------------------------"),t.info(`Contribution #${g.id}: ${g.name||""}`),t.info(an(g.nextChallenge,"Next Challenge: "));const Z=new Uint8Array(o.G1.F.n8*2*6+o.G2.F.n8*2*3);da(Z,0,o,g.key,!1);const j=ds(g.partialHash);j.update(Z);const O=j.digest();t.info(an(O,"Response Hash:")),t.info(an($.nextChallenge,"Response Hash:")),g.type==1&&(t.info(`Beacon generator: ${_s(g.beaconHash)}`),t.info(`Beacon iterations Exp: ${g.numIterationsExp}`))}async function T(g){const $=o.G2,Z=$.F.n8*2,j=new Uint8Array(Z);if(!i[6])throw g.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(i[6].length>1)throw g.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");a.pos=i[6][0].p;const O=await a.read(Z),E=$.fromRprLEM(O);return $.toRprUncompressed(j,0,E),w.update(j),E}async function C(g,$,Z,j,O,E){const M=o[$],Q=M.F.n8*2;await Wt(a,i,g);const D=[];let V=M.zero,nt=M.zero,R=M.zero;for(let at=0;at<j;at+=65536){E&&E.debug(`points relations: ${Z}: ${at}/${j} `);const J=Math.min(j-at,65536),k=await a.read(J*Q),K=await M.batchLEMtoU(k);w.update(K);const I=aa(4*(J-1));if(at>0){const h=M.fromRprLEM(k,0),U=Xa(aa(4),0);V=M.add(V,M.timesScalar(R,U)),nt=M.add(nt,M.timesScalar(h,U))}const d=await M.multiExpAffine(k.slice(0,(J-1)*Q),I),S=await M.multiExpAffine(k.slice(Q),I);V=M.add(V,d),nt=M.add(nt,S),R=M.fromRprLEM(k,(J-1)*Q);for(let h=0;h<O.length;h++){const U=O[h];if(U>=at&&U<at+J){const G=M.fromRprLEM(k,(U-at)*Q);D.push(G)}}}return await Qt(a),{R1:V,R2:nt,singularPoints:D}}async function _(g,$,Z,j,O){O&&O.debug(`Verifying phase2 calculated values ${j}...`);const E=o[g],q=E.F.n8*2,M=new Array(8);for(let D=0;D<8;D++)M[D]=Xa(aa(4),0);for(let D=0;D<=l;D++)if(!await Q(D))return!1;if($==2&&!await Q(l+1))return!1;return!0;async function Q(D){O&&O.debug(`Power ${D}...`);const V=o.Fr.n8,nt=2**D;let R=new Uint32Array(nt),at,J=new Kn(M);O&&O.debug(`Creating random numbers Powers${D}...`);for(let S=0;S<nt;S++)D==l+1&&S==nt-1?R[S]=0:R[S]=J.nextU32();R=new Uint8Array(R.buffer,R.byteOffset,R.byteLength),O&&O.debug(`reading points Powers${D}...`),await Wt(a,i,$),at=new ut(nt*q),D==l+1?(await a.readToBuffer(at,0,(nt-1)*q),at.set(o.G1.zeroAffine,(nt-1)*q)):await a.readToBuffer(at,0,nt*q),await Qt(a,!0);const k=await E.multiExpAffine(at,R,O,j+"_"+D);R=new ut(nt*V),J=new Kn(M);const K=new Uint8Array(4),I=new DataView(K.buffer);O&&O.debug(`Creating random numbers Powers${D}...`);for(let S=0;S<nt;S++)(S!=nt-1||D!=l+1)&&(I.setUint32(0,J.nextU32(),!0),R.set(K,S*V));O&&O.debug(`batchToMontgomery ${D}...`),R=await o.Fr.batchToMontgomery(R),O&&O.debug(`fft ${D}...`),R=await o.Fr.fft(R),O&&O.debug(`batchFromMontgomery ${D}...`),R=await o.Fr.batchFromMontgomery(R),O&&O.debug(`reading points Lagrange${D}...`),await Wt(a,i,Z),a.pos+=q*(2**D-1),await a.readToBuffer(at,0,nt*q),await Qt(a,!0);const d=await E.multiExpAffine(at,R,O,j+"_"+D+"_transformed");return E.eq(k,d)?!0:(O&&O.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function ni(e,t,n,a,i,o,l,s,f,r){const u=i[o],b=u.F.n8*2,w=t[a][0].size/b;await Wt(e,t,a),await Mt(n,a);let A=l;for(let x=0;x<w;x+=65536){r&&r.debug(`Applying key: ${f}: ${x}/${w}`);const v=Math.min(w-x,65536);let F;F=await e.read(v*b),F=await u.batchApplyKey(F,A,s),await n.write(F),A=i.Fr.mul(A,i.Fr.exp(s,v))}await Ut(n),await Qt(e)}async function Hn(e,t,n,a,i,o,l,s,f,r,c){const u=a[i],b=u.F.n8*2,w=Math.floor((1<<20)/b);let A=l;for(let x=0;x<o;x+=w){c&&c.debug(`Applying key ${r}: ${x}/${o}`);const v=Math.min(o-x,w),F=await e.read(v*b),y=await u.batchUtoLEM(F),B=await u.batchApplyKey(y,A,s);let P;f=="COMPRESSED"?P=await u.batchLEMtoC(B):P=await u.batchLEMtoU(B),n&&n.update(P),await t.write(P),A=a.Fr.mul(A,a.Fr.exp(s,v))}}async function Wr(e,t,n,a,i){const o=await Nn(t),l=e.F1.n64*8*2,s=e.F2.n64*8*2,f=(o.totalSize+l-64-s)/(4*l+s);let r=f,c=0;for(;r>1;)r=r/2,c+=1;if(2**c!=f)throw new Error("Invalid file size");i&&i.debug("Power to tau size: "+c);const u=await si(a),b=await ra(n),w=Yt.create({dkLen:64});for(let P=0;P<o.totalSize;P+=o.pageSize){i&&i.debug(`Hashing challenge ${P}/${o.totalSize}`);const T=Math.min(o.totalSize-P,o.pageSize),C=await o.read(T);w.update(C)}const A=await o.read(64,0);i&&i.info(an(A,"Claimed Previous Response Hash: "));const x=w.digest();i&&i.info(an(x,"Current Challenge Hash: "));const v=me(e,x,u);i&&["tau","alpha","beta"].forEach(P=>{i.debug(P+".g1_s: "+e.G1.toString(v[P].g1_s,16)),i.debug(P+".g1_sx: "+e.G1.toString(v[P].g1_sx,16)),i.debug(P+".g2_sp: "+e.G2.toString(v[P].g2_sp,16)),i.debug(P+".g2_spx: "+e.G2.toString(v[P].g2_spx,16)),i.debug("")});const F=Yt.create({dkLen:64});await b.write(x),F.update(x),await Hn(o,b,F,e,"G1",2**c*2-1,e.Fr.one,v.tau.prvKey,"COMPRESSED","tauG1",i),await Hn(o,b,F,e,"G2",2**c,e.Fr.one,v.tau.prvKey,"COMPRESSED","tauG2",i),await Hn(o,b,F,e,"G1",2**c,v.alpha.prvKey,v.tau.prvKey,"COMPRESSED","alphaTauG1",i),await Hn(o,b,F,e,"G1",2**c,v.beta.prvKey,v.tau.prvKey,"COMPRESSED","betaTauG1",i),await Hn(o,b,F,e,"G2",1,v.beta.prvKey,v.tau.prvKey,"COMPRESSED","betaTauG2",i);const y=new Uint8Array(e.F1.n8*2*6+e.F2.n8*2*3);da(y,0,e,v,!1),await b.write(y),F.update(y);const B=F.digest();i&&i.info(an(B,"Contribution Response Hash: ")),await b.close(),await o.close()}async function Qr(e,t,n,a,i,o){const l=fs(a);if(l.byteLength==0||l.byteLength*2!=a.length)return o&&o.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(l.length>=256)return o&&o.error("Maximum length of beacon hash is 255 bytes"),!1;if(i=parseInt(i),i<10||i>63)return o&&o.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:f}=await Ht(e,"ptau",1),{curve:r,power:c,ceremonyPower:u}=await gn(s,f);if(c!=u)return o&&o.error("This file has been reduced. You cannot contribute into a reduced file."),!1;f[12]&&o&&o.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const b=await ua(s,r,f),w={name:n,type:1,numIterationsExp:i,beaconHash:l};let A;b.length>0?A=b[b.length-1].nextChallenge:A=fa(r,c,o),w.key=await ms(r,A,l,i);const x=Yt.create({dkLen:64});x.update(A);const v=await _n(t,"ptau",1,7);await Jn(v,r,c);const F=[];let y;y=await C(2,"G1",2**c*2-1,r.Fr.e(1),w.key.tau.prvKey,"tauG1",o),w.tauG1=y[1],y=await C(3,"G2",2**c,r.Fr.e(1),w.key.tau.prvKey,"tauG2",o),w.tauG2=y[1],y=await C(4,"G1",2**c,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1",o),w.alphaG1=y[0],y=await C(5,"G1",2**c,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1",o),w.betaG1=y[0],y=await C(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2",o),w.betaG2=y[0],w.partialHash=pe(x);const B=new Uint8Array(r.F1.n8*2*6+r.F2.n8*2*3);da(B,0,r,w.key,!1),x.update(new Uint8Array(B));const P=x.digest();o&&o.info(an(P,"Contribution Response Hash imported: "));const T=Yt.create({dkLen:64});return T.update(P),await _(v,"G1",2,2**c*2-1,"tauG1",o),await _(v,"G2",3,2**c,"tauG2",o),await _(v,"G1",4,2**c,"alphaTauG1",o),await _(v,"G1",5,2**c,"betaTauG1",o),await _(v,"G2",6,1,"betaG2",o),w.nextChallenge=T.digest(),o&&o.info(an(w.nextChallenge,"Next Challenge Hash: ")),b.push(w),await be(v,r,b),await s.close(),await v.close(),P;async function C(g,$,Z,j,O,E,q){const M=[];s.pos=f[g][0].p,await Mt(v,g),F[g]=v.pos;const Q=r[$],D=Q.F.n8*2,V=Math.floor((1<<20)/D);let nt=j;for(let R=0;R<Z;R+=V){q&&q.debug(`applying key${E}: ${R}/${Z}`);const at=Math.min(Z-R,V),J=await s.read(at*D),k=await Q.batchApplyKey(J,nt,O),K=v.write(k),I=await Q.batchLEMtoC(k);if(x.update(I),await K,R==0)for(let d=0;d<Math.min(2,Z);d++)M.push(Q.fromRprLEM(k,d*D));nt=r.Fr.mul(nt,r.Fr.exp(O,at))}return await Ut(v),M}async function _(g,$,Z,j,O,E){const q=r[$],M=q.F.n8*2,Q=Math.floor((1<<24)/M),D=g.pos;g.pos=F[Z];for(let V=0;V<j;V+=Q){E&&E.debug(`Hashing ${O}: ${V}/${j}`);const nt=Math.min(j-V,Q),R=await g.read(nt*M),at=await q.batchLEMtoU(R);T.update(at)}g.pos=D}}async function Dr(e,t,n,a,i){const{fd:o,sections:l}=await Ht(e,"ptau",1),{curve:s,power:f,ceremonyPower:r}=await gn(o,l);if(f!=r)throw i&&i.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");l[12]&&i&&i.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const c=await ua(o,s,l),u={name:n,type:0};let b;const w=await si(a);c.length>0?b=c[c.length-1].nextChallenge:b=fa(s,f,i),u.key=me(s,b,w);const A=Yt.create({dkLen:64});A.update(b);const x=await _n(t,"ptau",1,7);await Jn(x,s,f);const v=[];let F;F=await T(2,"G1",2**f*2-1,s.Fr.e(1),u.key.tau.prvKey,"tauG1"),u.tauG1=F[1],F=await T(3,"G2",2**f,s.Fr.e(1),u.key.tau.prvKey,"tauG2"),u.tauG2=F[1],F=await T(4,"G1",2**f,u.key.alpha.prvKey,u.key.tau.prvKey,"alphaTauG1"),u.alphaG1=F[0],F=await T(5,"G1",2**f,u.key.beta.prvKey,u.key.tau.prvKey,"betaTauG1"),u.betaG1=F[0],F=await T(6,"G2",1,u.key.beta.prvKey,u.key.tau.prvKey,"betaTauG2"),u.betaG2=F[0],u.partialHash=pe(A);const y=new Uint8Array(s.F1.n8*2*6+s.F2.n8*2*3);da(y,0,s,u.key,!1),A.update(new Uint8Array(y));const B=A.digest();i&&i.info(an(B,"Contribution Response Hash imported: "));const P=Yt.create({dkLen:64});return P.update(B),await C(x,"G1",2,2**f*2-1,"tauG1"),await C(x,"G2",3,2**f,"tauG2"),await C(x,"G1",4,2**f,"alphaTauG1"),await C(x,"G1",5,2**f,"betaTauG1"),await C(x,"G2",6,1,"betaG2"),u.nextChallenge=P.digest(),i&&i.info(an(u.nextChallenge,"Next Challenge Hash: ")),c.push(u),await be(x,s,c),await o.close(),await x.close(),B;async function T(_,g,$,Z,j,O){const E=[];o.pos=l[_][0].p,await Mt(x,_),v[_]=x.pos;const q=s[g],M=q.F.n8*2,Q=Math.floor((1<<20)/M);let D=Z;for(let V=0;V<$;V+=Q){i&&i.debug(`processing: ${O}: ${V}/${$}`);const nt=Math.min($-V,Q),R=await o.read(nt*M),at=await q.batchApplyKey(R,D,j),J=x.write(at),k=await q.batchLEMtoC(at);if(A.update(k),await J,V==0)for(let K=0;K<Math.min(2,$);K++)E.push(q.fromRprLEM(at,K*M));D=s.Fr.mul(D,s.Fr.exp(j,nt))}return await Ut(x),E}async function C(_,g,$,Z,j){const O=s[g],E=O.F.n8*2,q=Math.floor((1<<24)/E),M=_.pos;_.pos=v[$];for(let Q=0;Q<Z;Q+=q){i&&Q&&i.debug(`Hashing ${j}: `+Q);const D=Math.min(Z-Q,q),V=await _.read(D*E),nt=await O.batchLEMtoU(V);P.update(nt)}_.pos=M}}async function Kr(e,t,n){const{fd:a,sections:i}=await Ht(e,"ptau",1),{curve:o,power:l}=await gn(a,i),s=await _n(t,"ptau",1,11);await Jn(s,o,l),await Nt(a,i,s,2),await Nt(a,i,s,3),await Nt(a,i,s,4),await Nt(a,i,s,5),await Nt(a,i,s,6),await Nt(a,i,s,7),await f(2,12,"G1","tauG1"),await f(3,13,"G2","tauG2"),await f(4,14,"G1","alphaTauG1"),await f(5,15,"G1","betaTauG1"),await a.close(),await s.close();return;async function f(r,c,u,b){n&&n.debug("Starting section: "+b),await Mt(s,c);for(let A=0;A<=l;A++)await w(A);r==2&&await w(l+1),await Ut(s);async function w(A){const x=2**A,v=o[u],F=v.F.n8*2;let y;y=new ut(x*F),await Wt(a,i,r),r==2&&A==l+1?(await a.readToBuffer(y,0,(x-1)*F),y.set(o.G1.zeroAffine,(x-1)*F)):await a.readToBuffer(y,0,x*F),await Qt(a,!0),y=await v.lagrangeEvaluations(y,"affine","affine",n,b),await s.write(y)}}}async function Xr(e,t,n){const{fd:a,sections:i}=await Ht(e,"ptau",1),{curve:o,power:l,ceremonyPower:s}=await gn(a,i),f=o.G1.F.n8*2,r=o.G2.F.n8*2;for(let u=1;u<l;u++)await c(u);return await a.close(),!0;async function c(u){let b=u.toString();for(;b.length<2;)b="0"+b;n&&n.debug("Writing Power: "+b);const w=await _n(t+b+".ptau","ptau",1,11);await Jn(w,o,u,s),await Nt(a,i,w,2,(2**u*2-1)*f),await Nt(a,i,w,3,2**u*r),await Nt(a,i,w,4,2**u*f),await Nt(a,i,w,5,2**u*f),await Nt(a,i,w,6,r),await Nt(a,i,w,7),await Nt(a,i,w,12,(2**(u+1)*2-1)*f),await Nt(a,i,w,13,(2**u*2-1)*r),await Nt(a,i,w,14,(2**u*2-1)*f),await Nt(a,i,w,15,(2**u*2-1)*f),await w.close()}}async function Yr(e,t,n){const{fd:a,sections:i}=await Ht(e,"ptau",1),{curve:o,power:l}=await gn(a,i),s=await _n(t,"ptau",1,11);await Jn(s,o,l),await Nt(a,i,s,2),await Nt(a,i,s,3),await Nt(a,i,s,4),await Nt(a,i,s,5),await Nt(a,i,s,6),await Nt(a,i,s,7),await f(2,12,"G1","tauG1"),await Nt(a,i,s,13),await Nt(a,i,s,14),await Nt(a,i,s,15),await a.close(),await s.close();return;async function f(r,c,u,b){n&&n.debug("Starting section: "+b),await Mt(s,c);const w=i[c][0].size,A=a.pageSize;await Wt(a,i,c);for(let v=0;v<w;v+=A){const F=Math.min(w-v,A),y=await a.read(F);await s.write(y)}await Qt(a),await x(l+1),await Ut(s);async function x(v){const F=2**v,y=o[u],B=y.F.n8*2;let P;P=new ut(F*B),await Wt(a,i,r),v==l+1?(await a.readToBuffer(P,0,(F-1)*B),P.set(o.G1.zeroAffine,(F-1)*B)):await a.readToBuffer(P,0,F*B),await Qt(a,!0),P=await y.lagrangeEvaluations(P,"affine","affine",n,b),await s.write(P)}}}async function Jr(e,t){const{fd:n,sections:a}=await Ht(e,"ptau",1),{curve:i,power:o}=await gn(n,a),l={};return l.q=i.q,l.power=o,l.contributions=await ua(n,i,a),l.tauG1=await s(2,"G1",2**o*2-1,"tauG1"),l.tauG2=await s(3,"G2",2**o,"tauG2"),l.alphaTauG1=await s(4,"G1",2**o,"alphaTauG1"),l.betaTauG1=await s(5,"G1",2**o,"betaTauG1"),l.betaG2=await s(6,"G2",1,"betaG2"),l.lTauG1=await f(12,"G1","lTauG1"),l.lTauG2=await f(13,"G2","lTauG2"),l.lAlphaTauG1=await f(14,"G1","lAlphaTauG2"),l.lBetaTauG1=await f(15,"G1","lBetaTauG2"),await n.close(),Ya(i.Fr,l);async function s(r,c,u,b){const w=i[c],A=w.F.n8*2,x=[];await Wt(n,a,r);for(let v=0;v<u;v++){t&&v&&v%1e4==0&&console.log(`${b}: `+v);const F=await n.read(A);x.push(w.fromRprLEM(F,0))}return await Qt(n),x}async function f(r,c,u){const b=i[c],w=b.F.n8*2,A=[];await Wt(n,a,r);for(let x=0;x<=o;x++){t&&console.log(`${u}: Power: ${x}`),A[x]=[];const v=2**x;for(let F=0;F<v;F++){t&&F&&F%1e4==0&&console.log(`${u}: ${F}/${v}`);const y=await n.read(w);A[x].push(b.fromRprLEM(y,0))}}return await Qt(n,!0),A}}var zu=Object.freeze({__proto__:null,newAccumulator:Vr,exportChallenge:Zr,importResponse:jr,verify:Hr,challengeContribute:Wr,beacon:Qr,contribute:Dr,preparePhase2:Kr,truncate:Xr,convert:Yr,exportJson:Jr});function td(e,t,n){for(let i=0;i<e.constraints.length;i++)a(e.constraints[i]);function a(i){const o=s=>{let f="";return Object.keys(s).forEach(c=>{let u=t.varIdx2Name[c];u=="one"&&(u="1");let b=e.curve.Fr.toString(s[c]);b=="1"&&(b=""),b=="-1"&&(b="-"),f!=""&&b[0]!="-"&&(b="+"+b),f!=""&&(b=" "+b),f=f+b+u}),f},l=`[ ${o(i[0])} ] * [ ${o(i[1])} ] - [ ${o(i[2])} ] = 0`;n&&n.info(l)}}const Fn=262144,nd={get:function(e,t){return isNaN(t)?e[t]:e.getElement(t)},set:function(e,t,n){return isNaN(t)?(e[t]=n,!0):e.setElement(t,n)}};class ad{constructor(t){this.length=t||0,this.arr=new Array(Fn);for(let n=0;n<t;n+=Fn)this.arr[n/Fn]=new Array(Math.min(Fn,t-n));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,n){const a=new Array(n-t);for(let i=t;i<n;i++)a[i-t]=this.getElement(i);return a}getElement(t){t=parseInt(t);const n=Math.floor(t/Fn),a=t%Fn;return this.arr[n]?this.arr[n][a]:void 0}setElement(t,n){t=parseInt(t);const a=Math.floor(t/Fn);this.arr[a]||(this.arr[a]=new Array(Fn));const i=t%Fn;return this.arr[a][i]=n,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new bs;for(let n=0;n<this.arr.length;n++)if(this.arr[n])for(let a=0;a<this.arr[n].length;a++)typeof this.arr[n][a]<"u"&&t.push(n*Fn+a);return t}}class bs{constructor(t){const n=new ad(t);return new Proxy(n,nd)}}var ye=bs;const Ji=4,te=5;async function ys(e,t,n){let a;typeof n=="object"?a=n:typeof n>"u"?a={singleThread:!1}:a={singleThread:n};const i={};if(await Wt(e,t,1),i.n8=await e.readULE32(),i.prime=await En(e,i.n8),a.F){if(a.F.p!=i.prime)throw new Error("Different Prime");i.F=a.F}else if(a.getFieldFromPrime)i.F=await a.getFieldFromPrime(i.prime,a.singleThread);else if(a.getCurveFromPrime)i.curve=await a.getCurveFromPrime(i.prime,a.singleThread),i.F=i.curve.Fr;else try{i.curve=await Cl(i.prime,a.singleThread),i.F=i.curve.Fr}catch{i.F=new ce(i.prime)}return i.nVars=await e.readULE32(),i.nOutputs=await e.readULE32(),i.nPubInputs=await e.readULE32(),i.nPrvInputs=await e.readULE32(),i.nLabels=await e.readULE64(),i.nConstraints=await e.readULE32(),i.useCustomGates=typeof t[Ji]<"u"&&t[Ji]!==null&&typeof t[te]<"u"&&t[te]!==null,await Qt(e),i}async function id(e,t,n,a,i){let o;typeof a=="object"?o=a:typeof a>"u"?o={}:o={logger:a,loggerCtx:i};const l=await Zt(e,t,2);let s=0,f;n.nConstraints>1<<20?f=new ye:f=[];for(let u=0;u<n.nConstraints;u++){o.logger&&u%1e5==0&&o.logger.info(`${o.loggerCtx}: Loading constraints: ${u}/${n.nConstraints}`);const b=r();f.push(b)}return f;function r(){const u=[];return u[0]=c(),u[1]=c(),u[2]=c(),u}function c(){const u={},b=l.slice(s,s+4);s+=4;const A=new DataView(b.buffer).getUint32(0,!0),x=l.slice(s,s+(4+n.n8)*A);s+=(4+n.n8)*A;const v=new DataView(x.buffer);for(let F=0;F<A;F++){const y=v.getUint32(F*(4+n.n8),!0),B=n.F.fromRprLE(x,F*(4+n.n8)+4);u[y]=B}return u}}async function ed(e,t,n,a,i){let o;typeof a=="object"?o=a:typeof a>"u"?o={}:o={logger:a,loggerCtx:i};const l=await Zt(e,t,3);let s=0,f;n.nVars>1<<20?f=new ye:f=[];for(let c=0;c<n.nVars;c++){o.logger&&c%1e4==0&&o.logger.info(`${o.loggerCtx}: Loading map: ${c}/${n.nVars}`);const u=r();f.push(u)}return f;function r(){const c=l.slice(s,s+8);s+=8;const u=new DataView(c.buffer),b=u.getUint32(0,!0);return u.getUint32(4,!0)*4294967296+b}}async function li(e,t,n){if(typeof n!="object")throw new Error("readR1csFd: options must be an object");n.loadConstraints="loadConstraints"in n?n.loadConstraints:!0,n.loadMap="loadMap"in n?n.loadMap:!1,n.loadCustomGates="loadCustomGates"in n?n.loadCustomGates:!0;const a=await ys(e,t,n);return n.loadConstraints&&(a.constraints=await id(e,t,a,n)),n.loadMap&&(a.map=await ed(e,t,a,n)),n.loadCustomGates&&(a.useCustomGates?(a.customGates=await od(e,t,a),a.customGatesUses=await sd(e,t,n)):(a.customGates=[],a.customGatesUses=[])),a}async function Cs(e,t,n,a,i,o){let l;typeof t=="object"?l=t:typeof t>"u"?l={loadConstraints:!0,loadMap:!1,loadCustomGates:!0}:l={loadConstraints:t,loadMap:n,singleThread:a,logger:i,loggerCtx:o};const{fd:s,sections:f}=await Ht(e,"r1cs",1),r=await li(s,f,l);return await s.close(),r}async function od(e,t,n){await Wt(e,t,Ji);let a=await e.readULE32(),i=[];for(let o=0;o<a;o++){let l={};l.templateName=await e.readString();let s=await e.readULE32();l.parameters=Array(s);let f=await e.read(n.n8*s);for(let r=0;r<s;r++)l.parameters[r]=n.F.fromRprLE(f,r*n.n8,n.n8);i.push(l)}return await Qt(e),i}async function sd(e,t,n){const a=await Zt(e,t,te),i=new Uint32Array(a.buffer,a.byteOffset,a.byteLength/4),o=i[0];let l=1,s;o>1<<20?s=new ye:s=[];for(let f=0;f<o;f++){n.logger&&f%1e5==0&&n.logger.info(`${n.loggerCtx}: Loading custom gate uses: ${f}/${o}`);let r={};r.id=i[l++];let c=i[l++];r.signals=[];for(let u=0;u<c;u++){const b=i[l++],w=i[l++];r.signals.push(w*4294967296+b)}s.push(r)}return s}const cd=St.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),ld=St.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function rd(e,t){const n=await Cs(e);return St.eq(n.prime,ld)?t&&t.info("Curve: bn-128"):St.eq(n.prime,cd)?t&&t.info("Curve: bls12-381"):t&&t.info(`Unknown Curve. Prime: ${St.toString(n.prime)}`),t&&t.info(`# of Wires: ${n.nVars}`),t&&t.info(`# of Constraints: ${n.nConstraints}`),t&&t.info(`# of Private Inputs: ${n.nPrvInputs}`),t&&t.info(`# of Public Inputs: ${n.nPubInputs}`),t&&t.info(`# of Labels: ${n.nLabels}`),t&&t.info(`# of Outputs: ${n.nOutputs}`),n}async function dd(e,t){const n=await Cs(e,!0,!0,!0,t),a=n.curve.Fr;return delete n.curve,delete n.F,Ya(a,n)}var qu=Object.freeze({__proto__:null,print:td,info:rd,exportJson:dd});async function Za(e){const t={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},n=await Nn(e),a=await n.read(n.totalSize),o=new TextDecoder("utf-8").decode(a).split(`
`);for(let s=0;s<o.length;s++){const f=o[s].split(",");f.length==4&&(t.varIdx2Name[f[1]]?t.varIdx2Name[f[1]]+="|"+f[3]:t.varIdx2Name[f[1]]=f[3],t.labelIdx2Name[f[0]]=f[3],t.componentIdx2Name[f[2]]||(t.componentIdx2Name[f[2]]=l(f[3])))}return await n.close(),t;function l(s){const f=s.split(".");return f.pop(),f.join(".")}}const{unstringifyBigInts:ud}=rn;async function fd(e,t,n,a,i,o){const l=ud(e),s=await Nn(t),f=await s.read(s.totalSize);await s.close();const r={...i,sanityCheck:!0};let c=await Za(a);i.set&&(c||(c=await Za(a)),r.logSetSignal=function(A,x){o&&o.info("SET "+c.labelIdx2Name[A]+" <-- "+x.toString())}),i.get&&(c||(c=await Za(a)),r.logGetSignal=function(A,x){o&&o.info("GET "+c.labelIdx2Name[A]+" --> "+x.toString())}),i.trigger&&(c||(c=await Za(a)),r.logStartComponent=function(A){o&&o.info("START: "+c.componentIdx2Name[A])},r.logFinishComponent=function(A){o&&o.info("FINISH: "+c.componentIdx2Name[A])}),r.sym=c;const u=await Ls(f,r),b=await u.calculateWitness(l,!0),w=await _n(n,"wtns",2,2);await Cr(w,b,u.prime),await w.close()}async function _d(e){return await Sr(e)}async function hd(e,t,n){n&&n.info("WITNESS CHECKING STARTED"),n&&n.info("> Reading r1cs file");const{fd:a,sections:i}=await Ht(e,"r1cs",1),o=await li(a,i,{loadConstraints:!1,loadCustomGates:!1});n&&n.info("> Reading witness file");const{fd:l,sections:s}=await Ht(t,"wtns",2),f=await Ua(l,s);if(!St.eq(o.prime,f.q))throw new Error("Curve of the witness does not match the curve of the proving key");const r=await Zt(l,s,2);await l.close();const u=(await ts(o.prime)).Fr,b=u.n8,w=await Zt(a,i,2);n&&(n.info("----------------------------"),n.info("  WITNESS CHECK"),n.info(`  Curve:          ${o.curve.name}`),n.info(`  Vars (wires):   ${o.nVars}`),n.info(`  Outputs:        ${o.nOutputs}`),n.info(`  Public Inputs:  ${o.nPubInputs}`),n.info(`  Private Inputs: ${o.nPrvInputs}`),n.info(`  Labels:         ${o.nLabels}`),n.info(`  Constraints:    ${o.nConstraints}`),n.info(`  Custom Gates:   ${o.useCustomGates}`),n.info("----------------------------")),n&&n.info("> Checking witness correctness");let A=0,x=!0;for(let B=0;B<o.nConstraints;B++){n&&B!==0&&B%5e5===0&&n.info(` processing r1cs constraints ${B}/${o.nConstraints}`);const P=F(),T=F(),C=F(),_=v(P),g=v(T),$=v(C);if(!u.eq(u.sub(u.mul(_,g),$),u.zero)){n.warn(" aborting checking process at constraint "+B),x=!1;break}}return a.close(),n&&(x?(n.info("WITNESS IS CORRECT"),n.info("WITNESS CHECKING FINISHED SUCCESSFULLY")):(n.warn("WITNESS IS NOT CORRECT"),n.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY"))),x;function v(B){let P=u.zero;return Object.keys(B).forEach(C=>{const _=y(C),g=B[C];P=u.add(P,u.mul(_,g))}),P}function F(){const B={},P=w.slice(A,A+4);A+=4;const C=new DataView(P.buffer).getUint32(0,!0),_=w.slice(A,A+(4+o.n8)*C);A+=(4+o.n8)*C;const g=new DataView(_.buffer);for(let $=0;$<C;$++){const Z=g.getUint32($*(4+o.n8),!0),j=o.F.fromRprLE(_,$*(4+o.n8)+4);B[Z]=j}return B}function y(B){return u.fromRprLE(r.slice(B*b,B*b+b))}}var Mu=Object.freeze({__proto__:null,calculate:ci,debug:fd,exportJson:_d,check:hd});const Sn=262144,pd={get:function(e,t){return isNaN(t)?e[t]:e.getElement(t)},set:function(e,t,n){return isNaN(t)?(e[t]=n,!0):e.setElement(t,n)}};class wd{constructor(t){this.length=t||0,this.arr=new Array(Sn);for(let n=0;n<t;n+=Sn)this.arr[n/Sn]=new Array(Math.min(Sn,t-n));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,n){const a=new Array(n-t);for(let i=t;i<n;i++)a[i-t]=this.getElement(i);return a}getElement(t){t=parseInt(t);const n=Math.floor(t/Sn),a=t%Sn;return this.arr[n]?this.arr[n][a]:void 0}setElement(t,n){t=parseInt(t);const a=Math.floor(t/Sn);this.arr[a]||(this.arr[a]=new Array(Sn));const i=t%Sn;return this.arr[a][i]=n,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new Fs;for(let n=0;n<this.arr.length;n++)if(this.arr[n])for(let a=0;a<this.arr[n].length;a++)typeof this.arr[n][a]<"u"&&t.push(n*Sn+a);return t}}class Fs{constructor(t){const n=new wd(t);return new Proxy(n,pd)}}var wn=Fs;async function Ss(e,t,n,a){const f=Yt.create({dkLen:64}),{fd:r,sections:c}=await Ht(t,"ptau",1),{curve:u,power:b}=await gn(r,c),{fd:w,sections:A}=await Ht(e,"r1cs",1),x=await ys(w,A,!1),v=await _n(n,"zkey",1,10,1<<22,1<<24),F=u.G1.F.n8*2,y=u.G2.F.n8*2;if(x.prime!=u.r)return a&&a.error("r1cs curve does not match powers of tau ceremony curve"),-1;const B=Vn(x.nConstraints+x.nPubInputs+x.nOutputs+1-1)+1;if(B>b)return a&&a.error(`circuit too big for this power of tau ceremony. ${x.nConstraints}*2 > 2**${b}`),-1;if(!c[12])return a&&a.error("Powers of tau is not prepared."),-1;const P=x.nOutputs+x.nPubInputs,T=2**B;await Mt(v,1),await v.writeULE32(1),await Ut(v),await Mt(v,2);const C=u.q,_=(Math.floor((St.bitLength(C)-1)/64)+1)*8,g=u.r,$=(Math.floor((St.bitLength(g)-1)/64)+1)*8,Z=St.mod(St.shl(1,$*8),g),j=u.Fr.e(St.mod(St.mul(Z,Z),g));await v.writeULE32(_),await yn(v,C,_),await v.writeULE32($),await yn(v,g,$),await v.writeULE32(x.nVars),await v.writeULE32(P),await v.writeULE32(T);let O;O=await r.read(F,c[4][0].p),await v.write(O),O=await u.G1.batchLEMtoU(O),f.update(O);let E;E=await r.read(F,c[5][0].p),await v.write(E),E=await u.G1.batchLEMtoU(E),f.update(E);let q;q=await r.read(y,c[6][0].p),await v.write(q),q=await u.G2.batchLEMtoU(q),f.update(q);const M=new Uint8Array(F);u.G1.toRprLEM(M,0,u.G1.g);const Q=new Uint8Array(y);u.G2.toRprLEM(Q,0,u.G2.g);const D=new Uint8Array(F);u.G1.toRprUncompressed(D,0,u.G1.g);const V=new Uint8Array(y);u.G2.toRprUncompressed(V,0,u.G2.g),await v.write(Q),await v.write(M),await v.write(Q),f.update(V),f.update(D),f.update(V),await Ut(v),a&&a.info("Reading r1cs");let nt=await Zt(w,A,2);const R=new wn(x.nVars),at=new wn(x.nVars),J=new wn(x.nVars),k=new wn(x.nVars-P-1),K=new Array(P+1);a&&a.info("Reading tauG1");let I=await Zt(r,c,12,(T-1)*F,T*F);a&&a.info("Reading tauG2");let d=await Zt(r,c,13,(T-1)*y,T*y);a&&a.info("Reading alphatauG1");let S=await Zt(r,c,14,(T-1)*F,T*F);a&&a.info("Reading betatauG1");let h=await Zt(r,c,15,(T-1)*F,T*F);await m(),await z(3,"G1",K,"IC"),await G(),await it(),await z(8,"G1",k,"C"),await z(5,"G1",R,"A"),await z(6,"G1",at,"B1"),await z(7,"G2",J,"B2");const U=f.digest();return await Mt(v,10),await v.write(U),await v.writeULE32(0),await Ut(v),a&&a.info(an(U,"Circuit hash: ")),await v.close(),await w.close(),await r.close(),U;async function G(){await Mt(v,9);const wt=new ut(T*F);if(B<u.Fr.s){let ft=await Zt(r,c,12,(T*2-1)*F,T*2*F);for(let st=0;st<T;st++){a&&st%1e4==0&&a.debug(`splitting buffer: ${st}/${T}`);const ct=ft.slice((st*2+1)*F,(st*2+1)*F+F);wt.set(ct,st*F)}}else if(B==u.Fr.s){const ft=c[12][0].p+(2**(B+1)-1)*F;await r.readToBuffer(wt,0,T*F,ft+T*F)}else throw a&&a.error("Circuit too big"),new Error("Circuit too big for this curve");await v.write(wt),await Ut(v)}async function m(){const wt=new Uint8Array(12+u.Fr.n8),ft=new DataView(wt.buffer),st=new Uint8Array(u.Fr.n8);u.Fr.toRprLE(st,0,u.Fr.e(1));let ct=0;function gt(){const bt=nt.slice(ct,ct+4);return ct+=4,new DataView(bt.buffer).getUint32(0,!0)}const yt=new wn;for(let bt=0;bt<x.nConstraints;bt++){a&&bt%1e4==0&&a.debug(`processing constraints: ${bt}/${x.nConstraints}`);const kt=gt();for(let ot=0;ot<kt;ot++){const p=gt(),L=ct;ct+=u.Fr.n8;const H=0,tt=F*bt,N=3,et=F*bt;typeof R[p]>"u"&&(R[p]=[]),R[p].push([H,tt,L]),p<=P?(typeof K[p]>"u"&&(K[p]=[]),K[p].push([N,et,L])):(typeof k[p-P-1]>"u"&&(k[p-P-1]=[]),k[p-P-1].push([N,et,L])),yt.push([0,bt,p,L])}const Jt=gt();for(let ot=0;ot<Jt;ot++){const p=gt(),L=ct;ct+=u.Fr.n8;const H=0,tt=F*bt,N=1,et=y*bt,Y=2,rt=F*bt;typeof at[p]>"u"&&(at[p]=[]),at[p].push([H,tt,L]),typeof J[p]>"u"&&(J[p]=[]),J[p].push([N,et,L]),p<=P?(typeof K[p]>"u"&&(K[p]=[]),K[p].push([Y,rt,L])):(typeof k[p-P-1]>"u"&&(k[p-P-1]=[]),k[p-P-1].push([Y,rt,L])),yt.push([1,bt,p,L])}const Dt=gt();for(let ot=0;ot<Dt;ot++){const p=gt(),L=ct;ct+=u.Fr.n8;const H=0,tt=F*bt;p<=P?(typeof K[p]>"u"&&(K[p]=[]),K[p].push([H,tt,L])):(typeof k[p-P-1]>"u"&&(k[p-P-1]=[]),k[p-P-1].push([H,tt,L]))}}for(let bt=0;bt<=P;bt++){const Jt=F*(x.nConstraints+bt),Dt=3,ot=F*(x.nConstraints+bt);typeof R[bt]>"u"&&(R[bt]=[]),R[bt].push([0,Jt,-1]),typeof K[bt]>"u"&&(K[bt]=[]),K[bt].push([Dt,ot,-1]),yt.push([0,x.nConstraints+bt,bt,-1])}await Mt(v,4);const xt=new ut(yt.length*(12+u.Fr.n8)+4),Rt=new Uint8Array(4);new DataView(Rt.buffer).setUint32(0,yt.length,!0),xt.set(Rt);let jt=4;for(let bt=0;bt<yt.length;bt++)a&&bt%1e5==0&&a.debug(`writing coeffs: ${bt}/${yt.length}`),Pt(yt[bt]);await v.write(xt),await Ut(v);function Pt(bt){ft.setUint32(0,bt[0],!0),ft.setUint32(4,bt[1],!0),ft.setUint32(8,bt[2],!0);let kt;bt[3]>=0?kt=u.Fr.fromRprLE(nt.slice(bt[3],bt[3]+u.Fr.n8),0):kt=u.Fr.fromRprLE(st,0);const Jt=u.Fr.mul(kt,j);u.Fr.toRprLE(wt,12,Jt),xt.set(wt,jt),jt+=wt.length}}async function z(wt,ft,st,ct){const yt=u[ft];_t(st.length),await Mt(v,wt);let xt=[],Rt=0;for(;Rt<st.length;){let Vt=0;for(;Rt<st.length&&Vt<u.tm.concurrency;){a&&a.debug(`Writing points start ${ct}: ${Rt}/${st.length}`);let Pt=1,bt=st[Rt]?st[Rt].length:0;for(;Rt+Pt<st.length&&bt+(st[Rt+Pt]?st[Rt+Pt].length:0)<32768&&Pt<32768;)bt+=st[Rt+Pt]?st[Rt+Pt].length:0,Pt++;const kt=st.slice(Rt,Rt+Pt),Jt=Rt;xt.push(W(ft,kt,a,ct).then(Dt=>(a&&a.debug(`Writing points end ${ct}: ${Jt}/${st.length}`),Dt))),Rt+=Pt,Vt++}const jt=await Promise.all(xt);for(let Pt=0;Pt<jt.length;Pt++){await v.write(jt[Pt][0]);const bt=await yt.batchLEMtoU(jt[Pt][0]);f.update(bt)}xt=[]}await Ut(v)}async function W(wt,ft,st,ct){const gt=u[wt],yt=gt.F.n8*2,xt=gt.F.n8*3,Rt=gt.F.n8*2;let Vt,jt,Pt,bt;if(wt=="G1")Vt="g1m_timesScalarAffine",jt="g1m_multiexpAffine",Pt="g1m_batchToAffine",bt="g1m_zero";else if(wt=="G2")Vt="g2m_timesScalarAffine",jt="g2m_multiexpAffine",Pt="g2m_batchToAffine",bt="g2m_zero";else throw new Error("Invalid group");let kt=0;for(let N=0;N<ft.length;N++)kt+=ft[N]?ft[N].length:0;let Jt,Dt;kt>32768?(Jt=new ut(kt*yt),Dt=new ut(kt*u.Fr.n8)):(Jt=new Uint8Array(kt*yt),Dt=new Uint8Array(kt*u.Fr.n8));let ot=0,p=0;const L=[I,d,S,h],H=new Uint8Array(u.Fr.n8);u.Fr.toRprLE(H,0,u.Fr.e(1));let tt=0;for(let N=0;N<ft.length;N++)if(ft[N])for(let et=0;et<ft[N].length;et++)st&&et&&et%1e4==0&&st.debug(`Configuring big array ${ct}: ${et}/${ft[N].length}`),Jt.set(L[ft[N][et][0]].slice(ft[N][et][1],ft[N][et][1]+yt),tt*yt),ft[N][et][2]>=0?Dt.set(nt.slice(ft[N][et][2],ft[N][et][2]+u.Fr.n8),tt*u.Fr.n8):Dt.set(H,tt*u.Fr.n8),tt++;if(ft.length>1){const N=[];N.push({cmd:"ALLOCSET",var:0,buff:Jt}),N.push({cmd:"ALLOCSET",var:1,buff:Dt}),N.push({cmd:"ALLOC",var:2,len:ft.length*xt}),ot=0,p=0;let et=0;for(let rt=0;rt<ft.length;rt++){if(!ft[rt]){N.push({cmd:"CALL",fnName:bt,params:[{var:2,offset:et}]}),et+=xt;continue}ft[rt].length==1?N.push({cmd:"CALL",fnName:Vt,params:[{var:0,offset:ot},{var:1,offset:p},{val:u.Fr.n8},{var:2,offset:et}]}):N.push({cmd:"CALL",fnName:jt,params:[{var:0,offset:ot},{var:1,offset:p},{val:u.Fr.n8},{val:ft[rt].length},{var:2,offset:et}]}),ot+=yt*ft[rt].length,p+=u.Fr.n8*ft[rt].length,et+=xt}return N.push({cmd:"CALL",fnName:Pt,params:[{var:2},{val:ft.length},{var:2}]}),N.push({cmd:"GET",out:0,var:2,len:ft.length*Rt}),await u.tm.queueAction(N)}else{let N=await gt.multiExpAffine(Jt,Dt,st,ct);return N=[gt.toAffine(N)],N}}async function it(){_t(T-1);for(let ft=0;ft<T-1;ft+=16384){a&&a.debug(`HashingHPoints: ${ft}/${T}`);const st=Math.min(T-1,16384);await X(ft,st)}}async function X(wt,ft){const st=await r.read(ft*F,c[2][0].p+(wt+T)*F),ct=await r.read(ft*F,c[2][0].p+wt*F),gt=u.tm.concurrency,yt=Math.floor(ft/gt),xt=[];for(let Vt=0;Vt<gt;Vt++){let jt;if(Vt<gt-1?jt=yt:jt=ft-Vt*yt,jt==0)continue;const Pt=st.slice(Vt*yt*F,(Vt*yt+jt)*F),bt=ct.slice(Vt*yt*F,(Vt*yt+jt)*F);xt.push(lt(Pt,bt))}const Rt=await Promise.all(xt);for(let Vt=0;Vt<Rt.length;Vt++)f.update(Rt[Vt][0])}async function lt(wt,ft){const st=wt.byteLength/F,ct=u.G1.F.n8*3,gt=[];gt.push({cmd:"ALLOCSET",var:0,buff:wt}),gt.push({cmd:"ALLOCSET",var:1,buff:ft}),gt.push({cmd:"ALLOC",var:2,len:st*ct});for(let xt=0;xt<st;xt++)gt.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:xt*F},{var:1,offset:xt*F},{var:2,offset:xt*ct}]});return gt.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:st},{var:2}]}),gt.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:st},{var:2}]}),gt.push({cmd:"GET",out:0,var:2,len:st*F}),await u.tm.queueAction(gt)}function _t(wt){const ft=new Uint8Array(4);new DataView(ft.buffer,ft.byteOffset,ft.byteLength).setUint32(0,wt,!1),f.update(ft)}}async function Ld(e,t,n){const{fd:a,sections:i}=await Ht(e,"zkey",2),o=await Cn(a,i);if(o.protocol!="groth16")throw new Error("zkey file is not groth16");const l=await hn(o.q),s=l.G1.F.n8*2,f=l.G2.F.n8*2,r=await ca(a,l,i),c=await ra(t);await y(o.vk_alpha_1),await y(o.vk_beta_1),await B(o.vk_beta_2),await B(o.vk_gamma_2),await y(o.vk_delta_1),await B(o.vk_delta_2);let u;u=await Zt(a,i,3),u=await l.G1.batchLEMtoU(u),await P("G1",u);const b=await Zt(a,i,9);let w;w=await l.G1.fft(b,"affine","jacobian",n),w=await l.G1.batchApplyKey(w,l.Fr.neg(l.Fr.e(2)),l.Fr.w[o.power+1],"jacobian","affine",n),w=w.slice(0,w.byteLength-s),w=await l.G1.batchLEMtoU(w),await P("G1",w);let A;A=await Zt(a,i,8),A=await l.G1.batchLEMtoU(A),await P("G1",A);let x;x=await Zt(a,i,5),x=await l.G1.batchLEMtoU(x),await P("G1",x);let v;v=await Zt(a,i,6),v=await l.G1.batchLEMtoU(v),await P("G1",v);let F;F=await Zt(a,i,7),F=await l.G2.batchLEMtoU(F),await P("G2",F),await c.write(r.csHash),await T(r.contributions.length);for(let C=0;C<r.contributions.length;C++){const _=r.contributions[C];await y(_.deltaAfter),await y(_.delta.g1_s),await y(_.delta.g1_sx),await B(_.delta.g2_spx),await c.write(_.transcript)}await a.close(),await c.close();async function y(C){const _=new Uint8Array(s);l.G1.toRprUncompressed(_,0,C),await c.write(_)}async function B(C){const _=new Uint8Array(f);l.G2.toRprUncompressed(_,0,C),await c.write(_)}async function P(C,_){let g;C=="G1"?g=s:g=f;const $=new Uint8Array(4);new DataView($.buffer,$.byteOffset,$.byteLength).setUint32(0,_.byteLength/g,!1),await c.write($),await c.write(_)}async function T(C){const _=new Uint8Array(4);new DataView(_.buffer,_.byteOffset,_.byteLength).setUint32(0,C,!1),await c.write(_)}}async function gd(e,t,n,a,i){const{fd:o,sections:l}=await Ht(e,"zkey",2),s=await Cn(o,l,!1);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const f=await hn(s.q),r=f.G1.F.n8*2,c=f.G2.F.n8*2,u=await ca(o,f,l),b={},w=await Nn(t);w.pos=r*3+c*3+8+r*s.nVars+4+r*(s.domainSize-1)+4+r*s.nVars+4+r*s.nVars+4+c*s.nVars,b.csHash=await w.read(64);const A=await w.readUBE32();b.contributions=[];for(let M=0;M<A;M++){const Q={delta:{}};Q.deltaAfter=await O(w),Q.delta.g1_s=await O(w),Q.delta.g1_sx=await O(w),Q.delta.g2_spx=await E(w),Q.transcript=await w.read(64),M<u.contributions.length&&(Q.type=u.contributions[M].type,Q.type==1&&(Q.beaconHash=u.contributions[M].beaconHash,Q.numIterationsExp=u.contributions[M].numIterationsExp),u.contributions[M].name&&(Q.name=u.contributions[M].name)),b.contributions.push(Q)}if(!Rn(b.csHash,u.csHash))return i&&i.error("Hash of the original circuit does not match with the MPC one"),!1;if(u.contributions.length>b.contributions.length)return i&&i.error("The impoerted file does not include new contributions"),!1;for(let M=0;M<u.contributions.length;M++)if(!q(u.contributions[M],b.contributions[M]))return i&&i.error(`Previous contribution ${M} does not match`),!1;if(a)for(let M=u.contributions.length;M<b.contributions.length;M++)b.contributions[M].name=a;const x=await _n(n,"zkey",1,10);if(w.pos=0,w.pos+=r,w.pos+=r,w.pos+=c,w.pos+=c,s.vk_delta_1=await O(w),s.vk_delta_2=await E(w),await Le(x,s),await w.readUBE32()!=s.nPublic+1)return i&&i.error("Invalid number of points in IC"),await x.discard(),!1;if(w.pos+=r*(s.nPublic+1),await Nt(o,l,x,3),await Nt(o,l,x,4),await w.readUBE32()!=s.domainSize-1)return i&&i.error("Invalid number of points in H"),await x.discard(),!1;let y;const B=await w.read(r*(s.domainSize-1)),P=await f.G1.batchUtoLEM(B);y=new Uint8Array(s.domainSize*r),y.set(P),f.G1.toRprLEM(y,r*(s.domainSize-1),f.G1.zeroAffine);const T=f.Fr.neg(f.Fr.inv(f.Fr.e(2))),C=f.Fr.inv(f.Fr.w[s.power+1]);if(y=await f.G1.batchApplyKey(y,T,C,"affine","jacobian",i),y=await f.G1.ifft(y,"jacobian","affine",i),await Mt(x,9),await x.write(y),await Ut(x),await w.readUBE32()!=s.nVars-s.nPublic-1)return i&&i.error("Invalid number of points in L"),await x.discard(),!1;let g;if(g=await w.read(r*(s.nVars-s.nPublic-1)),g=await f.G1.batchUtoLEM(g),await Mt(x,8),await x.write(g),await Ut(x),await w.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in A"),await x.discard(),!1;if(w.pos+=r*s.nVars,await Nt(o,l,x,5),await w.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in B1"),await x.discard(),!1;if(w.pos+=r*s.nVars,await Nt(o,l,x,6),await w.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in B2"),await x.discard(),!1;return w.pos+=c*s.nVars,await Nt(o,l,x,7),await ge(x,f,b),await w.close(),await x.close(),await o.close(),!0;async function O(M){const Q=await M.read(f.G1.F.n8*2);return f.G1.fromRprUncompressed(Q,0)}async function E(M){const Q=await M.read(f.G2.F.n8*2);return f.G2.fromRprUncompressed(Q,0)}function q(M,Q){return!(!f.G1.eq(M.deltaAfter,Q.deltaAfter)||!f.G1.eq(M.delta.g1_s,Q.delta.g1_s)||!f.G1.eq(M.delta.g1_sx,Q.delta.g1_sx)||!f.G2.eq(M.delta.g2_spx,Q.delta.g2_spx)||!Rn(M.transcript,Q.transcript))}}const ba=us;async function vs(e,t,n,a){let i;const{fd:o,sections:l}=await Ht(n,"zkey",2),s=await Cn(o,l,!1);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const f=await hn(s.q),r=f.G1.F.n8*2,c=await ca(o,f,l),u=Yt.create({dkLen:64});u.update(c.csHash);let b=f.G1.g;for(let C=0;C<c.contributions.length;C++){const _=c.contributions[C],g=lr(u);if(bn(g,f,_.delta.g1_s),bn(g,f,_.delta.g1_sx),!Rn(g.digest(),_.transcript))return console.log(`INVALID(${C}): Inconsistent transcript `),!1;const $=Ra(f,_.transcript);if(i=await ba(f,_.delta.g1_s,_.delta.g1_sx,$,_.delta.g2_spx),i!==!0)return console.log(`INVALID(${C}): public key G1 and G2 do not have the same ration `),!1;if(i=await ba(f,b,_.deltaAfter,$,_.delta.g2_spx),i!==!0)return console.log(`INVALID(${C}): deltaAfter does not fillow the public key `),!1;if(_.type==1){const j=await we(_.beaconHash,_.numIterationsExp),O=f.Fr.fromRng(j),E=f.G1.toAffine(f.G1.fromRng(j)),q=f.G1.toAffine(f.G1.timesFr(E,O));if(f.G1.eq(E,_.delta.g1_s)!==!0)return console.log(`INVALID(${C}): Key of the beacon does not match. g1_s `),!1;if(f.G1.eq(q,_.delta.g1_sx)!==!0)return console.log(`INVALID(${C}): Key of the beacon does not match. g1_sx `),!1}kn(u,f,_);const Z=Yt.create({dkLen:64});kn(Z,f,_),_.contributionHash=Z.digest(),b=_.deltaAfter}const{fd:w,sections:A}=await Ht(e,"zkey",2),x=await Cn(w,A,!1);if(x.protocol!="groth16")throw new Error("zkeyinit file is not groth16");if(!St.eq(x.q,s.q)||!St.eq(x.r,s.r)||x.n8q!=s.n8q||x.n8r!=s.n8r)return a&&a.error("INVALID:  Different curves"),!1;if(x.nVars!=s.nVars||x.nPublic!=s.nPublic||x.domainSize!=s.domainSize)return a&&a.error("INVALID:  Different circuit parameters"),!1;if(!f.G1.eq(s.vk_alpha_1,x.vk_alpha_1))return a&&a.error("INVALID:  Invalid alpha1"),!1;if(!f.G1.eq(s.vk_beta_1,x.vk_beta_1))return a&&a.error("INVALID:  Invalid beta1"),!1;if(!f.G2.eq(s.vk_beta_2,x.vk_beta_2))return a&&a.error("INVALID:  Invalid beta2"),!1;if(!f.G2.eq(s.vk_gamma_2,x.vk_gamma_2))return a&&a.error("INVALID:  Invalid gamma2"),!1;if(!f.G1.eq(s.vk_delta_1,b))return a&&a.error("INVALID:  Invalid delta1"),!1;if(i=await ba(f,f.G1.g,b,f.G2.g,s.vk_delta_2),i!==!0)return a&&a.error("INVALID:  Invalid delta2"),!1;const v=await ca(w,f,A);if(!Rn(c.csHash,v.csHash))return a&&a.error("INVALID:  Circuit does not match"),!1;if(l[8][0].size!=r*(s.nVars-s.nPublic-1))return a&&a.error("INVALID:  Invalid L section size"),!1;if(l[9][0].size!=r*s.domainSize)return a&&a.error("INVALID:  Invalid H section size"),!1;let F;if(F=await ma(o,l,w,A,3),!F)return a&&a.error("INVALID:  IC section is not identical"),!1;if(F=await ma(o,l,w,A,4),!F)return a&&a.error("Coeffs section is not identical"),!1;if(F=await ma(o,l,w,A,5),!F)return a&&a.error("A section is not identical"),!1;if(F=await ma(o,l,w,A,6),!F)return a&&a.error("B1 section is not identical"),!1;if(F=await ma(o,l,w,A,7),!F)return a&&a.error("B2 section is not identical"),!1;if(i=await y("G1",w,A,o,l,8,s.vk_delta_2,x.vk_delta_2,"L section"),i!==!0)return a&&a.error("L section does not match"),!1;if(i=await B(),i!==!0)return a&&a.error("H section does not match"),!1;a&&a.info(an(c.csHash,"Circuit Hash: ")),await o.close(),await w.close();for(let C=c.contributions.length-1;C>=0;C--){const _=c.contributions[C];a&&a.info("-------------------------"),a&&a.info(an(_.contributionHash,`contribution #${C+1} ${_.name?_.name:""}:`)),_.type==1&&(a&&a.info(`Beacon generator: ${_s(_.beaconHash)}`),a&&a.info(`Beacon iterations Exp: ${_.numIterationsExp}`))}return a&&a.info("-------------------------"),a&&a.info("ZKey Ok!"),!0;async function y(C,_,g,$,Z,j,O,E,q){const Q=f[C],D=Q.F.n8*2;await Wt(_,g,j),await Wt($,Z,j);let V=Q.zero,nt=Q.zero;const R=g[j][0].size/D;for(let at=0;at<R;at+=1048576){a&&a.debug(`Same ratio check ${q}:  ${at}/${R}`);const J=Math.min(R-at,1048576),k=await _.read(J*D),K=await $.read(J*D),I=aa(4*J),d=await Q.multiExpAffine(k,I),S=await Q.multiExpAffine(K,I);V=Q.add(V,d),nt=Q.add(nt,S)}return await Qt(_),await Qt($),R==0?!0:(i=await ba(f,V,nt,O,E),i===!0)}async function B(){const _=f.G1,g=f.Fr,$=_.F.n8*2,{fd:Z,sections:j}=await Ht(t,"ptau",1);let O=new ut(s.domainSize*s.n8r);const E=new Array(8);for(let nt=0;nt<8;nt++)E[nt]=Xa(aa(4),0);const q=new Kn(E);for(let nt=0;nt<s.domainSize-1;nt++){const R=g.fromRng(q);g.toRprLE(O,nt*s.n8r,R)}g.toRprLE(O,(s.domainSize-1)*s.n8r,g.zero);let M=_.zero;for(let nt=0;nt<s.domainSize;nt+=1048576){a&&a.debug(`H Verification(tau):  ${nt}/${s.domainSize}`);const R=Math.min(s.domainSize-nt,1048576),at=await Z.read($*R,j[2][0].p+s.domainSize*$+nt*$),J=await Z.read($*R,j[2][0].p+nt*$),k=await P(at,J),K=O.slice(nt*s.n8r,(nt+R)*s.n8r),I=await _.multiExpAffine(k,K);M=_.add(M,I)}O=await g.batchToMontgomery(O);let Q;if(s.power<g.s)Q=g.neg(g.e(2));else{const nt=2**g.s,R=g.exp(g.shift,nt);Q=g.sub(R,g.one)}const D=s.power<g.s?g.w[s.power+1]:g.shift;O=await g.batchApplyKey(O,Q,D),O=await g.fft(O),O=await g.batchFromMontgomery(O),await Wt(o,l,9);let V=_.zero;for(let nt=0;nt<s.domainSize;nt+=1048576){a&&a.debug(`H Verification(lagrange):  ${nt}/${s.domainSize}`);const R=Math.min(s.domainSize-nt,1048576),at=await o.read($*R),J=O.slice(nt*s.n8r,(nt+R)*s.n8r),k=await _.multiExpAffine(at,J);V=_.add(V,k)}return await Qt(o),i=await ba(f,M,V,s.vk_delta_2,x.vk_delta_2),i===!0}async function P(C,_){const g=f.G1.F.n8*2,$=C.byteLength/g,Z=f.tm.concurrency,j=Math.floor($/Z),O=[];for(let Q=0;Q<Z;Q++){let D;if(Q<Z-1?D=j:D=$-Q*j,D==0)continue;const V=C.slice(Q*j*r,(Q*j+D)*r),nt=_.slice(Q*j*r,(Q*j+D)*r);O.push(T(V,nt))}const E=await Promise.all(O),q=new Uint8Array($*g);let M=0;for(let Q=0;Q<E.length;Q++)q.set(E[Q][0],M),M+=E[Q][0].byteLength;return q}async function T(C,_){const g=f.G1.F.n8*2,$=f.G1.F.n8*3,Z=C.byteLength/g,j=[];j.push({cmd:"ALLOCSET",var:0,buff:C}),j.push({cmd:"ALLOCSET",var:1,buff:_}),j.push({cmd:"ALLOC",var:2,len:Z*$});for(let E=0;E<Z;E++)j.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:E*g},{var:1,offset:E*g},{var:2,offset:E*$}]});return j.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:Z},{var:2}]}),j.push({cmd:"GET",out:0,var:2,len:Z*g}),await f.tm.queueAction(j)}}async function md(e,t,n,a){const i={type:"bigMem"};return await Ss(e,t,i,a),await vs(i,t,n,a)}async function bd(e,t,n,a,i){const{fd:o,sections:l}=await Ht(e,"zkey",2),s=await Cn(o,l);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const f=await hn(s.q),r=await ca(o,f,l),c=await _n(t,"zkey",1,10),u=await si(a),b=Yt.create({dkLen:64});b.update(r.csHash);for(let F=0;F<r.contributions.length;F++)kn(b,f,r.contributions[F]);const w={};w.delta={},w.delta.prvKey=f.Fr.fromRng(u),w.delta.g1_s=f.G1.toAffine(f.G1.fromRng(u)),w.delta.g1_sx=f.G1.toAffine(f.G1.timesFr(w.delta.g1_s,w.delta.prvKey)),bn(b,f,w.delta.g1_s),bn(b,f,w.delta.g1_sx),w.transcript=b.digest(),w.delta.g2_sp=Ra(f,w.transcript),w.delta.g2_spx=f.G2.toAffine(f.G2.timesFr(w.delta.g2_sp,w.delta.prvKey)),s.vk_delta_1=f.G1.timesFr(s.vk_delta_1,w.delta.prvKey),s.vk_delta_2=f.G2.timesFr(s.vk_delta_2,w.delta.prvKey),w.deltaAfter=s.vk_delta_1,w.type=0,n&&(w.name=n),r.contributions.push(w),await Le(c,s),await Nt(o,l,c,3),await Nt(o,l,c,4),await Nt(o,l,c,5),await Nt(o,l,c,6),await Nt(o,l,c,7);const A=f.Fr.inv(w.delta.prvKey);await ni(o,l,c,8,f,"G1",A,f.Fr.e(1),"L Section",i),await ni(o,l,c,9,f,"G1",A,f.Fr.e(1),"H Section",i),await ge(c,f,r),await o.close(),await c.close();const x=Yt.create({dkLen:64});kn(x,f,w);const v=x.digest();return i&&i.info(an(r.csHash,"Circuit Hash: ")),i&&i.info(an(v,"Contribution Hash: ")),v}async function yd(e,t,n,a,i,o){const l=fs(a);if(l.byteLength==0||l.byteLength*2!=a.length)return o&&o.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(l.length>=256)return o&&o.error("Maximum length of beacon hash is 255 bytes"),!1;if(i=parseInt(i),i<10||i>63)return o&&o.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:f}=await Ht(e,"zkey",2),r=await Cn(s,f);if(r.protocol!="groth16")throw new Error("zkey file is not groth16");const c=await hn(r.q),u=await ca(s,c,f),b=await _n(t,"zkey",1,10),w=await we(l,i),A=Yt.create({dkLen:64});A.update(u.csHash);for(let B=0;B<u.contributions.length;B++)kn(A,c,u.contributions[B]);const x={};x.delta={},x.delta.prvKey=c.Fr.fromRng(w),x.delta.g1_s=c.G1.toAffine(c.G1.fromRng(w)),x.delta.g1_sx=c.G1.toAffine(c.G1.timesFr(x.delta.g1_s,x.delta.prvKey)),bn(A,c,x.delta.g1_s),bn(A,c,x.delta.g1_sx),x.transcript=A.digest(),x.delta.g2_sp=Ra(c,x.transcript),x.delta.g2_spx=c.G2.toAffine(c.G2.timesFr(x.delta.g2_sp,x.delta.prvKey)),r.vk_delta_1=c.G1.timesFr(r.vk_delta_1,x.delta.prvKey),r.vk_delta_2=c.G2.timesFr(r.vk_delta_2,x.delta.prvKey),x.deltaAfter=r.vk_delta_1,x.type=1,x.numIterationsExp=i,x.beaconHash=l,n&&(x.name=n),u.contributions.push(x),await Le(b,r),await Nt(s,f,b,3),await Nt(s,f,b,4),await Nt(s,f,b,5),await Nt(s,f,b,6),await Nt(s,f,b,7);const v=c.Fr.inv(x.delta.prvKey);await ni(s,f,b,8,c,"G1",v,c.Fr.e(1),"L Section",o),await ni(s,f,b,9,c,"G1",v,c.Fr.e(1),"H Section",o),await ge(b,c,u),await s.close(),await b.close();const F=Yt.create({dkLen:64});kn(F,c,x);const y=F.digest();return o&&o.info(an(y,"Contribution Hash: ")),y}async function Cd(e){const t=await gr(e,!0);return delete t.curve,delete t.F,rn.stringifyBigInts(t)}async function Fd(e,t,n,a,i){const o=await si(a),l=e.Fr.fromRng(o),s=e.Fr.inv(l),f=e.G1.F.n8*2,r=e.G2.F.n8*2,c=await Nn(t),u=await ra(n);await O(f),await O(f),await O(r),await O(r);const b=await E(),w=e.G1.timesFr(b,l);await M(w);const A=await q(),x=e.G2.timesFr(A,l);await Q(x);const v=await c.readUBE32();await u.writeUBE32(v),await O(v*f);const F=await c.readUBE32();await u.writeUBE32(F),await Hn(c,u,null,e,"G1",F,s,e.Fr.e(1),"UNCOMPRESSED","H",i);const y=await c.readUBE32();await u.writeUBE32(y),await Hn(c,u,null,e,"G1",y,s,e.Fr.e(1),"UNCOMPRESSED","L",i);const B=await c.readUBE32();await u.writeUBE32(B),await O(B*f);const P=await c.readUBE32();await u.writeUBE32(P),await O(P*f);const T=await c.readUBE32();await u.writeUBE32(T),await O(T*r);const C=Yt.create({dkLen:64}),_={};_.csHash=await c.read(64),C.update(_.csHash);const g=await c.readUBE32();_.contributions=[];for(let D=0;D<g;D++){const V={delta:{}};V.deltaAfter=await E(),V.delta.g1_s=await E(),V.delta.g1_sx=await E(),V.delta.g2_spx=await q(),V.transcript=await c.read(64),_.contributions.push(V),kn(C,e,V)}const $={};$.delta={},$.delta.prvKey=l,$.delta.g1_s=e.G1.toAffine(e.G1.fromRng(o)),$.delta.g1_sx=e.G1.toAffine(e.G1.timesFr($.delta.g1_s,l)),bn(C,e,$.delta.g1_s),bn(C,e,$.delta.g1_sx),$.transcript=C.digest(),$.delta.g2_sp=Ra(e,$.transcript),$.delta.g2_spx=e.G2.toAffine(e.G2.timesFr($.delta.g2_sp,l)),$.deltaAfter=w,$.type=0,_.contributions.push($),await u.write(_.csHash),await u.writeUBE32(_.contributions.length);for(let D=0;D<_.contributions.length;D++){const V=_.contributions[D];await M(V.deltaAfter),await M(V.delta.g1_s),await M(V.delta.g1_sx),await Q(V.delta.g2_spx),await u.write(V.transcript)}const Z=Yt.create({dkLen:64});kn(Z,e,$);const j=Z.digest();return i&&i.info(an(j,"Contribution Hash: ")),await u.close(),await c.close(),j;async function O(D){const V=c.pageSize*2;for(let nt=0;nt<D;nt+=V){const R=Math.min(D-nt,V),at=await c.read(R);await u.write(at)}}async function E(){const D=await c.read(e.G1.F.n8*2);return e.G1.fromRprUncompressed(D,0)}async function q(){const D=await c.read(e.G2.F.n8*2);return e.G2.fromRprUncompressed(D,0)}async function M(D){const V=new Uint8Array(f);e.G1.toRprUncompressed(V,0,D),await u.write(V)}async function Q(D){const V=new Uint8Array(r);e.G2.toRprUncompressed(V,0,D),await u.write(V)}}const{stringifyBigInts:Ce}=rn;async function Es(e,t){t&&t.info("EXPORT VERIFICATION KEY STARTED");const{fd:n,sections:a}=await Ht(e,"zkey",2),i=await Cn(n,a);t&&t.info("> Detected protocol: "+i.protocol);let o;if(i.protocol==="groth16")o=await Sd(i,n,a);else if(i.protocol==="plonk")o=await vd(i);else if(i.protocolId&&i.protocolId===Ma)o=await Ed(i);else throw new Error("zkey file protocol unrecognized");return await n.close(),t&&t.info("EXPORT VERIFICATION KEY FINISHED"),o}async function Sd(e,t,n){const a=await hn(e.q),i=a.G1.F.n8*2,o=await a.pairing(e.vk_alpha_1,e.vk_beta_2);let l={protocol:e.protocol,curve:a.name,nPublic:e.nPublic,vk_alpha_1:a.G1.toObject(e.vk_alpha_1),vk_beta_2:a.G2.toObject(e.vk_beta_2),vk_gamma_2:a.G2.toObject(e.vk_gamma_2),vk_delta_2:a.G2.toObject(e.vk_delta_2),vk_alphabeta_12:a.Gt.toObject(o)};await Wt(t,n,3),l.IC=[];for(let s=0;s<=e.nPublic;s++){const f=await t.read(i),r=a.G1.toObject(f);l.IC.push(r)}return await Qt(t),l=Ce(l),l}async function vd(e){const t=await hn(e.q);let n={protocol:e.protocol,curve:t.name,nPublic:e.nPublic,power:e.power,k1:t.Fr.toObject(e.k1),k2:t.Fr.toObject(e.k2),Qm:t.G1.toObject(e.Qm),Ql:t.G1.toObject(e.Ql),Qr:t.G1.toObject(e.Qr),Qo:t.G1.toObject(e.Qo),Qc:t.G1.toObject(e.Qc),S1:t.G1.toObject(e.S1),S2:t.G1.toObject(e.S2),S3:t.G1.toObject(e.S3),X_2:t.G2.toObject(e.X_2),w:t.Fr.toObject(t.Fr.w[e.power])};return n=Ce(n),n}async function Ed(e,t){const n=await hn(e.q);let a={protocol:e.protocol,curve:n.name,nPublic:e.nPublic,power:e.power,k1:n.Fr.toObject(e.k1),k2:n.Fr.toObject(e.k2),w:n.Fr.toObject(n.Fr.w[e.power]),w3:n.Fr.toObject(e.w3),w4:n.Fr.toObject(e.w4),w8:n.Fr.toObject(e.w8),wr:n.Fr.toObject(e.wr),X_2:n.G2.toObject(e.X_2),C0:n.G1.toObject(e.C0)};return Ce(a)}var As={};const{unstringifyBigInts:Ad,stringifyBigInts:xd}=rn;async function xs(e,t,n){n&&n.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");const a=await Yn(e.curve);let i=r(e.w3);e.w3_2=c(a.Fr.square(i));let o=r(e.w4);e.w4_2=c(a.Fr.square(o)),e.w4_3=c(a.Fr.mul(a.Fr.square(o),o));let l=r(e.w8),s=a.Fr.one;for(let u=1;u<8;u++)s=a.Fr.mul(s,l),e["w8_"+u]=c(s);let f=t[e.protocol];return n&&n.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),As.render(f,e);function r(u){const b=Ad(u);return a.Fr.fromObject(b)}function c(u){const b=a.Fr.toObject(u);return xd(b)}}async function Bd(e,t,n){const a=await Es(e,n);if(a.protocol==="fflonk")return xs(a,t,n);let i=t[a.protocol];return As.render(i,a)}var Uu=Object.freeze({__proto__:null,newZKey:Ss,exportBellman:Ld,importBellman:gd,verifyFromR1cs:md,verifyFromInit:vs,contribute:bd,beacon:yd,exportJson:Cd,bellmanContribute:Fd,exportVerificationKey:Es,exportSolidityVerifier:Bd});async function Id(e,t,n,a){globalThis.gc&&globalThis.gc();const{fd:i,sections:o}=await Ht(t,"ptau",1),{curve:l,power:s}=await gn(i,o),{fd:f,sections:r}=await Ht(e,"r1cs",1),c=await li(f,r,{loadConstraints:!0,loadCustomGates:!0}),u=l.G1.F.n8*2,b=l.G1,w=l.G2.F.n8*2,A=l.Fr,x=l.Fr.n8;a&&a.info("Reading r1cs"),await Zt(f,r,2);const v=new wn,F=new wn;let y=c.nVars;const B=c.nOutputs+c.nPubInputs;await E(l.Fr,c,a),globalThis.gc&&globalThis.gc();const P=await _n(n,"zkey",1,14,1<<22,1<<24);if(c.prime!=l.r)return a&&a.error("r1cs curve does not match powers of tau ceremony curve"),-1;let T=Vn(v.length-1)+1;T<3&&(T=3);const C=2**T;if(a&&a.info("Plonk constraints: "+v.length),T>s)return a&&a.error(`circuit too big for this power of tau ceremony. ${v.length} > 2**${s}`),-1;if(!o[12])return a&&a.error("Powers of tau is not prepared."),-1;const _=new ut(C*u),g=o[12][0].p+(2**T-1)*u;await i.readToBuffer(_,0,C*u,g);const[$,Z]=at(),j={};await D(3,"Additions"),globalThis.gc&&globalThis.gc(),await q(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await q(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await q(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await M(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await M(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await M(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await M(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await M(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await V(12,"sigma"),globalThis.gc&&globalThis.gc(),await nt(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await Mt(P,14);const O=new ut((C+6)*u);await i.readToBuffer(O,0,(C+6)*u,o[2][0].p),await P.write(O),await Ut(P),globalThis.gc&&globalThis.gc(),await R(),await P.close(),await f.close(),await i.close(),a&&a.info("Setup Finished");return;async function E(J,k,K){function I(z){const W=Object.keys(z);for(let it=0;it<W.length;it++)z[W[it]]==0n&&delete z[W[it]]}function d(z,W,it){const X={};for(let lt in z)typeof X[lt]>"u"?X[lt]=J.mul(W,z[lt]):X[lt]=J.add(X[lt],J.mul(W,z[lt]));for(let lt in it){const _t=J.neg(it[lt]);typeof X[lt]>"u"?X[lt]=_t:X[lt]=J.add(X[lt],_t)}return I(X),X}function S(z,W){const it={k:J.zero,s:[],coefs:[]},X=[];for(let lt in z)lt==0?it.k=J.add(it.k,z[lt]):z[lt]!=0n&&X.push([Number(lt),z[lt]]);for(;X.length>W;){const lt=X.shift(),_t=X.shift(),wt=lt[0],ft=_t[0],st=y++,ct=J.zero,gt=J.neg(lt[1]),yt=J.neg(_t[1]),xt=J.one,Rt=J.zero;v.push([wt,ft,st,ct,gt,yt,xt,Rt]),F.push([wt,ft,lt[1],_t[1]]),X.push([st,J.one])}for(let lt=0;lt<X.length;lt++)it.s[lt]=X[lt][0],it.coefs[lt]=X[lt][1];for(;it.coefs.length<W;)it.s.push(0),it.coefs.push(J.zero);return it}function h(z){const W=S(z,3),it=W.s[0],X=W.s[1],lt=W.s[2],_t=J.zero,wt=W.coefs[0],ft=W.coefs[1],st=W.coefs[2],ct=W.k;v.push([it,X,lt,_t,wt,ft,st,ct])}function U(z,W,it){const X=S(z,1),lt=S(W,1),_t=S(it,1),wt=X.s[0],ft=lt.s[0],st=_t.s[0],ct=J.mul(X.coefs[0],lt.coefs[0]),gt=J.mul(X.coefs[0],lt.k),yt=J.mul(X.k,lt.coefs[0]),xt=J.neg(_t.coefs[0]),Rt=J.sub(J.mul(X.k,lt.k),_t.k);v.push([wt,ft,st,ct,gt,yt,xt,Rt])}function G(z){let W=J.zero,it=0;const X=Object.keys(z);for(let lt=0;lt<X.length;lt++)z[X[lt]]==0n?delete z[X[lt]]:X[lt]==0?W=J.add(W,z[X[lt]]):it++;return it>0?it.toString():W!=J.zero?"k":"0"}function m(z,W,it){const X=G(z),lt=G(W);if(X==="0"||lt==="0")I(it),h(it);else if(X==="k"){const _t=d(W,z[0],it);h(_t)}else if(lt==="k"){const _t=d(z,W[0],it);h(_t)}else U(z,W,it)}for(let z=1;z<=B;z++){const W=z,it=0,X=0,lt=J.zero,_t=J.one,wt=J.zero,ft=J.zero,st=J.zero;v.push([W,it,X,lt,_t,wt,ft,st])}for(let z=0;z<k.constraints.length;z++)K&&z%1e4===0&&K.debug(`processing constraints: ${z}/${k.nConstraints}`),m(...k.constraints[z])}async function q(J,k,K){await Mt(P,J);for(let I=0;I<v.length;I++)await P.writeULE32(v[I][k]),a&&I%1e6==0&&a.debug(`writing ${K}: ${I}/${v.length}`);await Ut(P)}async function M(J,k,K){let I=new ut(C*x);for(let d=0;d<v.length;d++)I.set(v[d][k],d*x),a&&d%1e6==0&&a.debug(`writing ${K}: ${d}/${v.length}`);await Mt(P,J),await Q(I),await Ut(P),I=await A.batchFromMontgomery(I),j[K]=await l.G1.multiExpAffine(_,I,a,"multiexp "+K)}async function Q(J){const k=await A.ifft(J),K=new ut(C*x*4);K.set(k,0);const I=await A.fft(K);await P.write(k),await P.write(I)}async function D(J,k){await Mt(P,J);const K=new Uint8Array(8+2*x),I=new DataView(K.buffer);for(let d=0;d<F.length;d++){const S=F[d];let h=0;I.setUint32(h,S[0],!0),h+=4,I.setUint32(h,S[1],!0),h+=4,K.set(S[2],h),h+=x,K.set(S[3],h),h+=x,await P.write(K),a&&d%1e6==0&&a.debug(`writing ${k}: ${d}/${F.length}`)}await Ut(P)}async function V(J,k){const K=new ut(x*C*3),I=new wn(y),d=new wn(y);let S=A.one;for(let z=0;z<C;z++)z<v.length?(m(v[z][0],z),m(v[z][1],C+z),m(v[z][2],C*2+z)):(m(0,z),m(0,C+z),m(0,C*2+z)),S=A.mul(S,A.w[T]),a&&z%1e6==0&&a.debug(`writing ${k} phase1: ${z}/${v.length}`);for(let z=0;z<y;z++)typeof d[z]<"u"?K.set(I[z],d[z]*x):console.log("Variable not used"),a&&z%1e6==0&&a.debug(`writing ${k} phase2: ${z}/${y}`);globalThis.gc&&globalThis.gc(),await Mt(P,J);let h=K.slice(0,C*x);await Q(h),globalThis.gc&&globalThis.gc();let U=K.slice(C*x,C*x*2);await Q(U),globalThis.gc&&globalThis.gc();let G=K.slice(C*x*2,C*x*3);await Q(G),globalThis.gc&&globalThis.gc(),await Ut(P),h=await A.batchFromMontgomery(h),U=await A.batchFromMontgomery(U),G=await A.batchFromMontgomery(G),j.S1=await l.G1.multiExpAffine(_,h,a,"multiexp S1"),globalThis.gc&&globalThis.gc(),j.S2=await l.G1.multiExpAffine(_,U,a,"multiexp S2"),globalThis.gc&&globalThis.gc(),j.S3=await l.G1.multiExpAffine(_,G,a,"multiexp S3"),globalThis.gc&&globalThis.gc();function m(z,W){typeof I[z]>"u"?d[z]=W:K.set(I[z],W*x);let it;W<C?it=S:W<2*C?it=A.mul(S,$):it=A.mul(S,Z),I[z]=it}}async function nt(J,k){await Mt(P,J);const K=Math.max(B,1);for(let I=0;I<K;I++){let d=new ut(C*x);d.set(A.one,I*x),await Q(d),a&&a.debug(`writing ${k} ${I}/${K}`)}await Ut(P)}async function R(){await Mt(P,1),await P.writeULE32(2),await Ut(P),await Mt(P,2);const J=l.q,k=(Math.floor((St.bitLength(J)-1)/64)+1)*8,K=l.r,I=(Math.floor((St.bitLength(K)-1)/64)+1)*8;await P.writeULE32(k),await yn(P,J,k),await P.writeULE32(I),await yn(P,K,I),await P.writeULE32(y),await P.writeULE32(B),await P.writeULE32(C),await P.writeULE32(F.length),await P.writeULE32(v.length),await P.write($),await P.write(Z),await P.write(b.toAffine(j.Qm)),await P.write(b.toAffine(j.Ql)),await P.write(b.toAffine(j.Qr)),await P.write(b.toAffine(j.Qo)),await P.write(b.toAffine(j.Qc)),await P.write(b.toAffine(j.S1)),await P.write(b.toAffine(j.S2)),await P.write(b.toAffine(j.S3));let d;d=await i.read(w,o[3][0].p+w),await P.write(d),await Ut(P)}function at(){let J=A.two;for(;K(J,[],T);)A.add(J,A.one);let k=A.add(J,A.one);for(;K(k,[J],T);)A.add(k,A.one);return[J,k];function K(I,d,S){const h=2**S;let U=A.one;for(let G=0;G<h;G++){if(A.eq(I,U))return!0;for(let m=0;m<d.length;m++)if(A.eq(I,A.mul(d[m],U)))return!0;U=A.mul(U,A.w[S])}return!1}}}class Fe{constructor(t,n){this.curve=t,this.logger=n,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(t,n){t in this.polynomials&&this.logger.warn(`proof: polynomial.${t} already exist in proof`),this.polynomials[t]=n}getPolynomial(t){return t in this.polynomials||this.logger.warn(`proof: polynomial ${t} does not exist in proof`),this.polynomials[t]}addEvaluation(t,n){t in this.evaluations&&this.logger.warn(`proof: evaluations.${t} already exist in proof`),this.evaluations[t]=n}getEvaluation(t){return t in this.evaluations||this.logger.warn(`proof: evaluation ${t} does not exist in proof`),this.evaluations[t]}toObjectProof(t=!0){let n=t?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{const i=this.curve.G1.toObject(this.polynomials[a]);t?n.polynomials[a]=i:n[a]=i}),Object.keys(this.evaluations).forEach(a=>{const i=this.curve.Fr.toObject(this.evaluations[a]);t?n.evaluations[a]=i:n[a]=i}),n}fromObjectProof(t){this.resetProof(),Object.keys(t.polynomials).forEach(n=>{this.polynomials[n]=this.curve.G1.fromObject(t.polynomials[n])}),Object.keys(t.evaluations).forEach(n=>{this.evaluations[n]=this.curve.Fr.fromObject(t.evaluations[n])})}}const Bs=[],Is=[],Ps=[],Pd=BigInt(0),ya=BigInt(1),Gd=BigInt(2),Td=BigInt(7),Od=BigInt(256),zd=BigInt(113);for(let e=0,t=ya,n=1,a=0;e<24;e++){[n,a]=[a,(2*n+3*a)%5],Bs.push(2*(5*a+n)),Is.push((e+1)*(e+2)/2%64);let i=Pd;for(let o=0;o<7;o++)t=(t<<ya^(t>>Td)*zd)%Od,t&Gd&&(i^=ya<<(ya<<BigInt(o))-ya);Ps.push(i)}const[qd,Md]=os(Ps,!0),oo=(e,t,n)=>n>32?ls(e,t,n):ss(e,t,n),so=(e,t,n)=>n>32?rs(e,t,n):cs(e,t,n);function Ud(e,t=24){const n=new Uint32Array(10);for(let a=24-t;a<24;a++){for(let l=0;l<10;l++)n[l]=e[l]^e[l+10]^e[l+20]^e[l+30]^e[l+40];for(let l=0;l<10;l+=2){const s=(l+8)%10,f=(l+2)%10,r=n[f],c=n[f+1],u=oo(r,c,1)^n[s],b=so(r,c,1)^n[s+1];for(let w=0;w<50;w+=10)e[l+w]^=u,e[l+w+1]^=b}let i=e[2],o=e[3];for(let l=0;l<24;l++){const s=Is[l],f=oo(i,o,s),r=so(i,o,s),c=Bs[l];i=e[c],o=e[c+1],e[c]=f,e[c+1]=r}for(let l=0;l<50;l+=10){for(let s=0;s<10;s++)n[s]=e[l+s];for(let s=0;s<10;s++)e[l+s]^=~n[(s+2)%10]&n[(s+4)%10]}e[0]^=qd[a],e[1]^=Md[a]}n.fill(0)}class Se extends is{constructor(t,n,a,i=!1,o=24){if(super(),this.blockLen=t,this.suffix=n,this.outputLen=a,this.enableXOF=i,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Fa(a),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Xn(this.state)}keccak(){Pn||Un(this.state32),Ud(this.state32,this.rounds),Pn||Un(this.state32),this.posOut=0,this.pos=0}update(t){Ka(this);const{blockLen:n,state:a}=this;t=Qn(t);const i=t.length;for(let o=0;o<i;){const l=Math.min(n-this.pos,i-o);for(let s=0;s<l;s++)a[this.pos++]^=t[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:a,blockLen:i}=this;t[a]^=n,(n&128)!==0&&a===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){Ka(this,!1),he(t),this.finish();const n=this.state,{blockLen:a}=this;for(let i=0,o=t.length;i<o;){this.posOut>=a&&this.keccak();const l=Math.min(a-this.posOut,o-i);t.set(n.subarray(this.posOut,this.posOut+l),i),this.posOut+=l,i+=l}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Fa(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(ns(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:n,suffix:a,outputLen:i,rounds:o,enableXOF:l}=this;return t||(t=new Se(n,a,i,l,o)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=a,t.outputLen=i,t.enableXOF=l,t.destroyed=this.destroyed,t}}const Rd=(e,t,n)=>kl(()=>new Se(t,e,n)),kd=Rd(1,136,256/8),Ei=0,$d=1;class Wn{constructor(t){this.G1=t.G1,this.Fr=t.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(t){this.data.push({type:Ei,data:t})}addScalar(t){this.data.push({type:$d,data:t})}getChallenge(){if(this.data.length===0)throw new Error("Keccak256Transcript: No data to generate a transcript");let t=0,n=0;this.data.forEach(l=>Ei===l.type?t++:n++);let a=new Uint8Array(n*this.Fr.n8+t*this.G1.F.n8*2),i=0;for(let l=0;l<this.data.length;l++)Ei===this.data[l].type?(this.G1.toRprUncompressed(a,i,this.data[l].data),i+=this.G1.F.n8*2):(this.Fr.toRprBE(a,i,this.data[l].data),i+=this.Fr.n8);const o=St.fromRprBE(kd(a));return this.Fr.e(o)}}class Ai{static getZ1(t){return[t.zero,t.add(t.e(-1),t.w[2]),t.e(-2),t.sub(t.e(-1),t.w[2])]}static getZ2(t){return[t.zero,t.add(t.zero,t.mul(t.e(-2),t.w[2])),t.e(4),t.sub(t.zero,t.mul(t.e(-2),t.w[2]))]}static getZ3(t){return[t.zero,t.add(t.e(2),t.mul(t.e(2),t.w[2])),t.e(-8),t.sub(t.e(2),t.mul(t.e(2),t.w[2]))]}static mul2(t,n,a,i,o,l){const s=this.getZ1(l);let f,r;const c=l.mul(t,n),u=l.mul(t,i),b=l.mul(a,n),w=l.mul(a,i);f=c;let A=l.add(u,b),x=w;return r=A,o&&(r=l.add(r,l.mul(s[o],x))),[f,r]}static mul3(t,n,a,i,o,l,s,f){const r=this.getZ1(f),c=this.getZ2(f);let u,b;const w=f.mul(t,n),A=f.mul(t,o),x=f.mul(i,n),v=f.mul(i,o);u=f.mul(w,a);let F=f.mul(x,a);F=f.add(F,f.mul(A,a)),F=f.add(F,f.mul(w,l));let y=f.mul(v,a);if(y=f.add(y,f.mul(A,l)),y=f.add(y,f.mul(x,l)),b=F,s){const B=f.mul(v,l);b=f.add(b,f.mul(r[s],y)),b=f.add(b,f.mul(c[s],B))}return[u,b]}static mul4(t,n,a,i,o,l,s,f,r,c){const u=this.getZ1(c),b=this.getZ2(c),w=this.getZ3(c);let A,x;const v=c.mul(t,n),F=c.mul(t,l),y=c.mul(o,n),B=c.mul(o,l),P=c.mul(a,i),T=c.mul(a,f),C=c.mul(s,i),_=c.mul(s,f);A=c.mul(v,P);let g=c.mul(y,P);g=c.add(g,c.mul(F,P)),g=c.add(g,c.mul(v,C)),g=c.add(g,c.mul(v,T));let $=c.mul(B,P);$=c.add($,c.mul(y,C)),$=c.add($,c.mul(y,T)),$=c.add($,c.mul(F,C)),$=c.add($,c.mul(F,T)),$=c.add($,c.mul(v,_));let Z=c.mul(F,_);Z=c.add(Z,c.mul(y,_)),Z=c.add(Z,c.mul(B,T)),Z=c.add(Z,c.mul(B,C));let j=c.mul(B,_);return x=g,r&&(x=c.add(x,c.mul(u[r],$)),x=c.add(x,c.mul(b[r],Z)),x=c.add(x,c.mul(w[r],j))),[A,x]}}const co=3,Nd=4,Vd=5,Zd=6,xi=7,Bi=8,Ii=9,Pi=10,Gi=11,Zn=12,jd=13,lo=14;class Ft{constructor(t,n,a){this.coef=t,this.curve=n,this.Fr=n.Fr,this.G1=n.G1,this.logger=a}static async fromEvaluations(t,n,a){let i=await n.Fr.ifft(t);return new Ft(i,n,a)}static fromCoefficientsArray(t,n,a){const i=n.Fr;let o=t.length>32768?new ut(t.length*i.n8):new Uint8Array(t.length*i.n8);for(let l=0;l<t.length;l++)o.set(t[l],l*i.n8);return new Ft(o,n,a)}static fromPolynomial(t,n,a){let i=t.length(),o=n.Fr,l=i>32768?new ut(i*o.n8):new Uint8Array(i*o.n8);return l.set(t.coef.slice(),0),new Ft(l,n,a)}isEqual(t){const n=this.degree();if(n!==t.degree())return!1;for(let a=0;a<n+1;a++)if(!this.Fr.eq(this.getCoef(a),t.getCoef(a)))return!1;return!0}blindCoefficients(t){t=t||[];const n=this.length()+t.length>32768?new ut((this.length()+t.length)*this.Fr.n8):new Uint8Array((this.length()+t.length)*this.Fr.n8);n.set(this.coef,0);for(let a=0;a<t.length;a++)n.set(this.Fr.add(n.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),t[a]),(this.length()+a)*this.Fr.n8),n.set(this.Fr.sub(n.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),t[a]),a*this.Fr.n8);this.coef=n}getCoef(t){const n=t*this.Fr.n8;return n+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(n,n+this.Fr.n8)}setCoef(t,n){if(t>this.length()-1)throw new Error("Coef index is not available");this.coef.set(n,t*this.Fr.n8)}static async to4T(t,n,a,i){a=a||[];let o=await i.ifft(t);const l=n*4>32768?new ut(n*4*i.n8):new Uint8Array(n*4*i.n8);l.set(o,0);const s=await i.fft(l);if(a.length===0)return[o,s];const f=n+a.length>32768?new ut((n+a.length)*i.n8):new Uint8Array((n+a.length)*i.n8);f.set(o,0);for(let r=0;r<a.length;r++)f.set(i.add(f.slice((n+r)*i.n8,(n+r+1)*i.n8),a[r]),(n+r)*i.n8),f.set(i.sub(f.slice(r*i.n8,(r+1)*i.n8),a[r]),r*i.n8);return[f,s]}length(){let t=this.coef.byteLength/this.Fr.n8;if(t!==Math.floor(this.coef.byteLength/this.Fr.n8))throw new Error("Polynomial coefficients buffer has incorrect size");return t===0&&this.logger&&this.logger.warn("Polynomial has length zero"),t}degree(){for(let t=this.length()-1;t>0;t--){const n=t*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(n,n+this.Fr.n8)))return t}return 0}evaluate(t){let n=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8;const o=this.coef.slice(i-this.Fr.n8,i);n=this.Fr.add(o,this.Fr.mul(n,t))}return n}fastEvaluate(t){const n=this.Fr;let a=3,i=this.degree()+1,o=parseInt(i/a),l=i-o*a,s=[],f=[];f[0]=n.one;for(let r=0;r<a;r++){s[r]=n.zero;let c=r===a-1?o+l:o;for(let u=c;u>0;u--)s[r]=n.add(this.getCoef(r*o+u-1),n.mul(s[r],t)),r===0&&(f[0]=n.mul(f[0],t))}for(let r=1;r<a;r++)s[0]=n.add(s[0],n.mul(f[r-1],s[r])),f[r]=n.mul(f[r-1],f[0]);return s[0]}add(t,n){let a=!1;t.length()>this.length()&&(a=!0);const i=this.length(),o=t.length();for(let l=0;l<Math.max(i,o);l++){const s=l*this.Fr.n8,f=l<i?this.coef.slice(s,s+this.Fr.n8):this.Fr.zero;let r=l<o?t.coef.slice(s,s+this.Fr.n8):this.Fr.zero;n!==void 0&&(r=this.Fr.mul(r,n)),a?t.coef.set(this.Fr.add(f,r),s):this.coef.set(this.Fr.add(f,r),s)}a&&(delete this.coef,this.coef=t.coef)}sub(t,n){let a=!1;t.length()>this.length()&&(a=!0);const i=this.length(),o=t.length();for(let l=0;l<Math.max(i,o);l++){const s=l*this.Fr.n8,f=l<i?this.coef.slice(s,s+this.Fr.n8):this.Fr.zero;let r=l<o?t.coef.slice(s,s+this.Fr.n8):this.Fr.zero;n!==void 0&&(r=this.Fr.mul(r,n)),a?t.coef.set(this.Fr.sub(f,r),s):this.coef.set(this.Fr.sub(f,r),s)}a&&(delete this.coef,this.coef=t.coef)}mulScalar(t){for(let n=0;n<this.length();n++){const a=n*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),t),a)}}addScalar(t){const n=this.length()===0?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(n,t),0)}subScalar(t){const n=this.length()===0?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(n,t),0)}byXSubValue(t){const n=this.Fr,i=!n.eq(n.zero,this.getCoef(this.length()-1))?this.length()+1:this.length(),o=i>32768?new ut(i*n.n8):new Uint8Array(i*n.n8);let l=new Ft(o,this.curve,this.logger);l.coef.set(this.coef.slice(0,(i-1)*n.n8),32),this.mulScalar(n.neg(t)),l.add(this),this.coef=l.coef}byXNSubValue(t,n){const a=this.Fr,o=!(this.length()-t-1>=this.degree())?this.length()+t:this.length(),l=o>32768?new ut(o*a.n8):new Uint8Array(o*a.n8);let s=new Ft(l,this.curve,this.logger);s.coef.set(this.coef.slice(0,(this.degree()+1)*32),t*32),this.mulScalar(n),s.add(this),this.coef=s.coef}divBy(t){const n=this.Fr,a=this.degree(),i=t.degree();let o=new Ft(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ut(this.length()*n.n8):new Uint8Array(this.length()*n.n8);for(let l=a-i;l>=0;l--){this.setCoef(l,n.div(o.getCoef(l+i),t.getCoef(i)));for(let s=0;s<=i;s++)o.setCoef(l+s,n.sub(o.getCoef(l+s),n.mul(this.getCoef(l),t.getCoef(s))))}return o}divByMonic(t,n){const a=this.Fr;let i=this.degree(),o=this.length()>32768?new ut(this.length()*a.n8):new Uint8Array(this.length()*a.n8),l=new Ft(o,this.curve,this.logger),s=[];for(let r=0;r<t;r++)l.setCoef(i-r-t,this.getCoef(i-r)),s[r]=this.getCoef(i-r);let f=t;for(let r=0;r<f;r++)for(let c=i-2*t-r;c>=0&&!(c<0);c=c-f){let u=r;s[u]=a.add(this.getCoef(c+t),a.mul(s[u],n)),l.setCoef(c,s[u])}this.coef=l.coef}divByVanishing(t,n){if(this.degree()<t)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");const a=this.Fr;let i=new Ft(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ut(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let o=this.length()-1;o>=t;o--){let l=i.getCoef(o);a.eq(a.zero,l)||(i.setCoef(o,a.zero),i.setCoef(o-t,a.add(i.getCoef(o-t),a.mul(n,l))),this.setCoef(o-t,a.add(this.getCoef(o-t),l)))}return i}divByVanishing2(t,n){if(this.degree()<t)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");const a=this.Fr;let i=new Ft(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ut(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let o=3,l=this.length()-t,s=Math.floor(l/o),f=l-(o-1)*s;console.log(l),console.log(s+"  "+f);for(let r=0;r<o;r++){console.log("> Thread "+r);for(let c=r===0?f:s;c>0;c--){let u=c-1;r!==0&&(u+=(r-1)*s+f);let b=u+t,w=i.getCoef(b);a.eq(a.zero,w)||(i.setCoef(b,a.zero),i.setCoef(u,a.add(i.getCoef(u),a.mul(n,w))),this.setCoef(u,a.add(this.getCoef(u),w)),console.log(u+" <-- "+b))}}return this.print(),i}fastDivByVanishing(t){const n=this.Fr;for(let a=0;a<t.length;a++){let i=t[a][0],o=t[a][1];if(this.degree()<i)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let l=5,s=this.length()-i,f=Math.floor(s/l/i),r=f*i,c=s-l*r,u=new Ft(this.length()>32768?new ut(this.length()*n.n8):new Uint8Array(this.length()*n.n8),this.curve,this.logger),b=this.coef;this.coef=u.coef,u.coef=b;for(let y=0;y<l;y++){let B=(y+1)*r+c;for(let P=0;P<i;P++)this.setCoef(B+P-i,u.getCoef(B+P));for(let P=0;P<r-i;P++){let T=B-P-1,C=n.add(u.getCoef(T),n.mul(o,this.getCoef(T)));this.setCoef(T-i,C)}}let w=c,A=c;for(let y=0;y<i&&A;y++)this.setCoef(w-y-1,u.getCoef(w+i-y-1)),A--;for(let y=0;y<A;y++){let B=w-y-1,P=n.add(u.getCoef(B),n.mul(o,this.getCoef(B)));this.setCoef(B-i,P)}let x=[],v=n.one;for(let y=0;y<f;y++)v=n.mul(v,o);let F=n.one;for(let y=l;y>0;y--){let B=y-1,P=B*r+c;x[B]=[];for(let T=0;T<i;T++)x[B][T]=this.getCoef(P+T),y!==l&&(x[B][T]=n.add(x[B][T],n.mul(v,x[B+1][T])));F=n.mul(F,v)}for(let y=0;y<l;y++){let B=y*r+c,P=o,T=i-1,C=y===0?c:r;for(let _=0;_<C;_++){let g=B-_-1,$=n.add(this.getCoef(g),n.mul(P,x[y][T]));this.setCoef(g,$),T===0?(T=i-1,P=n.mul(P,o)):T--}}}}divByXSubValue(t){const n=this.length()>32768?new ut(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);n.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),n.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;n.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(t,n.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(t),n.slice(0,this.Fr.n8))))throw new Error("Polynomial does not divide");this.coef=n}divZh(t,n=4){for(let i=0;i<t;i++){const o=i*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(o,o+this.Fr.n8)),o)}const a=this.coef.byteLength/this.Fr.n8;for(let i=t;i<a;i++){const o=i*this.Fr.n8,l=this.Fr.sub(this.coef.slice((i-t)*this.Fr.n8,(i-t)*this.Fr.n8+this.Fr.n8),this.coef.slice(o,o+this.Fr.n8));if(this.coef.set(l,o),i>t*(n-1)-n&&!this.Fr.isZero(l))throw new Error("Polynomial is not divisible")}return this}divByZerofier(t,n){let a=this.Fr;const i=a.inv(n),o=a.neg(i);let l=a.eq(a.one,o),s=a.eq(a.negone,o);if(!l)for(let f=0;f<t;f++){const r=f*this.Fr.n8;let c;s?c=a.neg(this.coef.slice(r,r+this.Fr.n8)):c=a.mul(o,this.coef.slice(r,r+this.Fr.n8)),this.coef.set(c,r)}l=a.eq(a.one,i),s=a.eq(a.negone,i);for(let f=t;f<this.length();f++){const r=f*this.Fr.n8,c=(f-t)*this.Fr.n8;let u=this.Fr.sub(this.coef.slice(c,c+this.Fr.n8),this.coef.slice(r,r+this.Fr.n8));if(l||(s?u=a.neg(u):u=a.mul(i,u)),this.coef.set(u,r),f>this.length()-t-1&&!this.Fr.isZero(u))throw new Error("Polynomial is not divisible")}return this}byX(){const t=this.length()+1>32768?new ut(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);t.set(this.Fr.zero,0),t.set(this.coef,this.Fr.n8),this.coef=t}static async expX(t,n,a=!1){const i=t.Fr;if(n<1)throw new Error("Compute a new polynomial to a zero or negative number is not allowed");if(n===1)return await Ft.fromEvaluations(t.coef,curve,t.logger);const o=a?t.degree():t.length()-1,l=o*n+1>32768?new ut((o*n+1)*i.n8):new Uint8Array((o*n+1)*i.n8);l.set(t.getCoef(0),0);for(let s=1;s<=o;s++){const f=s*i.n8,r=t.getCoef(s);l.set(r,f*n)}return new Ft(l,t.curve,t.logger)}split(t,n,a){if(t<1)throw new Error(`Polynomials can't be split in ${t} parts`);if(t===1)return[this];if(a.length!==0&&a.length<t-1)throw new Error(`Blinding factors length must be ${t-1}`);const i=(n+1)*this.Fr.n8;let o=[];const l=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(l<t)for(let s=l;s<t;s++)o[s]=new Ft(new Uint8Array(this.Fr.n8),this.curve,this.logger);t=Math.min(t,l);for(let s=0;s<t;s++){const f=t-1===s,r=f?this.coef.byteLength-(t-1)*i:i+this.Fr.n8;let c=r/this.Fr.n8>32768?new ut(r):new Uint8Array(r);o[s]=new Ft(c,this.curve,this.logger);const u=s*i,b=f?this.coef.byteLength:(s+1)*i;if(o[s].coef.set(this.coef.slice(u,b),0),f||o[s].coef.set(a[s],i),s!==0){const w=this.Fr.sub(o[s].coef.slice(0,this.Fr.n8),a[s-1]);o[s].coef.set(w,0)}f&&o[s].truncate()}return o}truncate(){const t=this.degree();if(t+1<this.coef.byteLength/this.Fr.n8){const n=t+1>32768?new ut((t+1)*this.Fr.n8):new Uint8Array((t+1)*this.Fr.n8);n.set(this.coef.slice(0,(t+1)*this.Fr.n8),0),this.coef=n}}static lagrangePolynomialInterpolation(t,n,a){const i=a.Fr;let o=l(0);for(let s=1;s<t.length;s++)o.add(l(s));return o;function l(s){let f;for(let u=0;u<t.length;u++)if(u!==s)if(f===void 0){let b=t.length>32768?new ut(t.length*i.n8):new Uint8Array(t.length*i.n8);f=new Ft(b,a),f.setCoef(0,i.neg(t[u])),f.setCoef(1,i.one)}else f.byXSubValue(t[u]);let r=f.evaluate(t[s]);r=i.inv(r);const c=i.mul(n[s],r);return f.mulScalar(c),f}}static zerofierPolynomial(t,n){const a=n.Fr;let i=t.length+1>32768?new ut((t.length+1)*a.n8):new Uint8Array((t.length+1)*a.n8),o=new Ft(i,n);o.setCoef(0,a.neg(t[0])),o.setCoef(1,a.one);for(let l=1;l<t.length;l++)o.byXSubValue(t[l]);return o}print(){const t=this.Fr;let n="";for(let a=this.degree();a>=0;a--){const i=this.getCoef(a);t.eq(t.zero,i)||(t.isNegative(i)?n+=" - ":a!==this.degree()&&(n+=" + "),n+=t.toString(i),a>0&&(n+=a>1?"x^"+a:"x"))}console.log(n)}async multiExponentiation(t,n){const a=this.coef.byteLength/this.Fr.n8,i=t.slice(0,a*this.G1.F.n8*2),o=await this.Fr.batchFromMontgomery(this.coef);let l=await this.G1.multiExpAffine(i,o,this.logger,n);return l=this.G1.toAffine(l),l}}class Kt{constructor(t,n,a){this.eval=t,this.curve=n,this.Fr=n.Fr,this.logger=a}static async fromPolynomial(t,n,a,i){const o=new ut(t.length()*n*a.Fr.n8);o.set(t.coef,0);const l=await a.Fr.fft(o);return new Kt(l,a,i)}getEvaluation(t){const n=t*this.Fr.n8;if(n+this.Fr.n8>this.eval.byteLength)throw new Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(n,n+this.Fr.n8)}length(){let t=this.eval.byteLength/this.Fr.n8;if(t!==Math.floor(this.eval.byteLength/this.Fr.n8))throw new Error("Polynomial evaluations buffer has incorrect size");return t===0&&this.logger.warn("Polynomial has length zero"),t}}const{stringifyBigInts:ro}=rn;async function Gs(e,t,n,a){const{fd:i,sections:o}=await Ht(t,"wtns",2);n&&n.debug("> Reading witness file");const l=await Ua(i,o);n&&n.debug("> Reading zkey file");const{fd:s,sections:f}=await Ht(e,"zkey",2),r=await Cn(s,f,void 0,a);if(r.protocol!="plonk")throw new Error("zkey file is not plonk");if(!St.eq(r.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!=r.nVars-r.nAdditions)throw new Error(`Invalid witness length. Circuit: ${r.nVars}, witness: ${l.nWitness}, ${r.nAdditions}`);const c=r.curve,u=c.Fr,b=c.Fr.n8,w=r.domainSize*b;n&&(n.debug("----------------------------"),n.debug("  PLONK PROVE SETTINGS"),n.debug(`  Curve:         ${c.name}`),n.debug(`  Circuit power: ${r.power}`),n.debug(`  Domain size:   ${r.domainSize}`),n.debug(`  Vars:          ${r.nVars}`),n.debug(`  Public vars:   ${r.nPublic}`),n.debug(`  Constraints:   ${r.nConstraints}`),n.debug(`  Additions:     ${r.nAdditions}`),n.debug("----------------------------")),n&&n.debug("> Reading witness file data");const A=await Zt(i,o,2);A.set(u.zero,0);const x=new ut(b*r.nAdditions);let v={},F={},y={},B={},P=new Fe(c,n);const T=new Wn(c);n&&n.debug(`> Reading Section ${co}. Additions`),await $(),n&&n.debug(`> Reading Section ${Zn}. Sigma1, Sigma2 & Sigma 3`),n&&n.debug(" Reading Sigma polynomials "),F.Sigma1=new Ft(new ut(w),c,n),F.Sigma2=new Ft(new ut(w),c,n),F.Sigma3=new Ft(new ut(w),c,n),await s.readToBuffer(F.Sigma1.coef,0,w,f[Zn][0].p),await s.readToBuffer(F.Sigma2.coef,0,w,f[Zn][0].p+5*w),await s.readToBuffer(F.Sigma3.coef,0,w,f[Zn][0].p+10*w),n&&n.debug(" Reading Sigma evaluations"),y.Sigma1=new Kt(new ut(w*4),c,n),y.Sigma2=new Kt(new ut(w*4),c,n),y.Sigma3=new Kt(new ut(w*4),c,n),await s.readToBuffer(y.Sigma1.eval,0,w*4,f[Zn][0].p+w),await s.readToBuffer(y.Sigma2.eval,0,w*4,f[Zn][0].p+6*w),await s.readToBuffer(y.Sigma3.eval,0,w*4,f[Zn][0].p+11*w),n&&n.debug(`> Reading Section ${lo}. Powers of Tau`);const C=await Zt(s,f,lo);let _=[];for(let k=1;k<=r.nPublic;k++){const K=A.slice(k*u.n8,k*u.n8+u.n8);_.push(St.fromRprLE(K))}n&&n.debug(""),n&&n.debug("> ROUND 1"),await O(),n&&n.debug("> ROUND 2"),await q(),n&&n.debug("> ROUND 3"),await Q(),n&&n.debug("> ROUND 4"),await V(),n&&n.debug("> ROUND 5"),await nt(),await s.close(),await i.close();let g=P.toObjectProof(!1);return g.protocol="plonk",g.curve=c.name,n&&n.debug("PLONK PROVER FINISHED"),{proof:ro(g),publicSignals:ro(_)};async function $(){n&&n.debug(" Computing additions");const k=await Zt(s,f,co),K=8+b*2;for(let I=0;I<r.nAdditions;I++){n&&I!==0&&I%1e5===0&&n.debug(`    addition ${I}/${r.nAdditions}`);let d=I*K;const S=Z(k,d);d+=4;const h=Z(k,d);d+=4;const U=k.slice(d,d+b);d+=b;const G=k.slice(d,d+b),m=j(S),z=j(h),W=u.add(u.mul(U,m),u.mul(G,z));x.set(W,b*I)}}function Z(k,K){const I=k.slice(K,K+4);return new DataView(I.buffer,I.byteOffset,I.byteLength).getUint32(0,!0)}function j(k){return k<r.nVars-r.nAdditions?A.slice(k*b,k*b+b):k<r.nVars?x.slice((k-(r.nVars-r.nAdditions))*b,(k-(r.nVars-r.nAdditions))*b+b):c.Fr.zero}async function O(){B.b=[];for(let d=1;d<=11;d++)B.b[d]=c.Fr.random();n&&n.debug("> Computing A, B, C wire polynomials"),await E(),n&&n.debug("> Computing A, B, C MSM");let k=await F.A.multiExponentiation(C,"A"),K=await F.B.multiExponentiation(C,"B"),I=await F.C.multiExponentiation(C,"C");return P.addPolynomial("A",k),P.addPolynomial("B",K),P.addPolynomial("C",I),0}async function E(){n&&n.debug(" Reading data from zkey file"),v.A=new ut(w),v.B=new ut(w),v.C=new ut(w);const k=await Zt(s,f,Nd),K=await Zt(s,f,Vd),I=await Zt(s,f,Zd);for(let d=0;d<r.nConstraints;d++){const S=d*b,h=d*4,U=Z(k,h);v.A.set(j(U),S);const G=Z(K,h);v.B.set(j(G),S);const m=Z(I,h);v.C.set(j(m),S)}if(v.A=await u.batchToMontgomery(v.A),v.B=await u.batchToMontgomery(v.B),v.C=await u.batchToMontgomery(v.C),n&&n.debug(" Computing A ifft"),F.A=await Ft.fromEvaluations(v.A,c,n),n&&n.debug(" Computing B ifft"),F.B=await Ft.fromEvaluations(v.B,c,n),n&&n.debug(" Computing C ifft"),F.C=await Ft.fromEvaluations(v.C,c,n),n&&n.debug(" Computing A fft"),y.A=await Kt.fromPolynomial(F.A,4,c,n),n&&n.debug(" Computing B fft"),y.B=await Kt.fromPolynomial(F.B,4,c,n),n&&n.debug(" Computing C fft"),y.C=await Kt.fromPolynomial(F.C,4,c,n),F.A.blindCoefficients([B.b[2],B.b[1]]),F.B.blindCoefficients([B.b[4],B.b[3]]),F.C.blindCoefficients([B.b[6],B.b[5]]),F.A.degree()>=r.domainSize+2)throw new Error("A Polynomial is not well calculated");if(F.B.degree()>=r.domainSize+2)throw new Error("B Polynomial is not well calculated");if(F.C.degree()>=r.domainSize+2)throw new Error("C Polynomial is not well calculated")}async function q(){n&&n.debug("> Computing challenges beta and gamma"),T.reset(),T.addPolCommitment(r.Qm),T.addPolCommitment(r.Ql),T.addPolCommitment(r.Qr),T.addPolCommitment(r.Qo),T.addPolCommitment(r.Qc),T.addPolCommitment(r.S1),T.addPolCommitment(r.S2),T.addPolCommitment(r.S3);for(let K=0;K<r.nPublic;K++)T.addScalar(v.A.slice(K*b,K*b+b));T.addPolCommitment(P.getPolynomial("A")),T.addPolCommitment(P.getPolynomial("B")),T.addPolCommitment(P.getPolynomial("C")),B.beta=T.getChallenge(),n&&n.debug(" challenges.beta: "+u.toString(B.beta,16)),T.reset(),T.addScalar(B.beta),B.gamma=T.getChallenge(),n&&n.debug(" challenges.gamma: "+u.toString(B.gamma,16)),n&&n.debug("> Computing Z polynomial"),await M(),n&&n.debug("> Computing Z MSM");let k=await F.Z.multiExponentiation(C,"Z");P.addPolynomial("Z",k)}async function M(){n&&n.debug(" Computing Z evaluations");let k=new ut(w),K=new ut(w);k.set(u.one,0),K.set(u.one,0);let I=u.one;for(let d=0;d<r.domainSize;d++){const S=d*b,h=v.A.slice(S,S+b),U=v.B.slice(S,S+b),G=v.C.slice(S,S+b),m=u.mul(B.beta,I);let z=u.add(h,m);z=u.add(z,B.gamma);let W=u.add(U,u.mul(r.k1,m));W=u.add(W,B.gamma);let it=u.add(G,u.mul(r.k2,m));it=u.add(it,B.gamma);let X=u.mul(z,u.mul(W,it)),lt=u.add(h,u.mul(y.Sigma1.getEvaluation(d*4),B.beta));lt=u.add(lt,B.gamma);let _t=u.add(U,u.mul(y.Sigma2.getEvaluation(d*4),B.beta));_t=u.add(_t,B.gamma);let wt=u.add(G,u.mul(y.Sigma3.getEvaluation(d*4),B.beta));wt=u.add(wt,B.gamma);let ft=u.mul(lt,u.mul(_t,wt));X=u.mul(k.slice(S,S+b),X),k.set(X,(d+1)%r.domainSize*b),ft=u.mul(K.slice(S,S+b),ft),K.set(ft,(d+1)%r.domainSize*b),I=u.mul(I,u.w[r.power])}K=await u.batchInverse(K);for(let d=0;d<r.domainSize;d++){const S=d*b,h=u.mul(k.slice(S,S+b),K.slice(S,S+b));k.set(h,S)}if(v.Z=k,!u.eq(k.slice(0,b),u.one))throw new Error("Copy constraints does not match");if(n&&n.debug(" Computing Z ifft"),F.Z=await Ft.fromEvaluations(v.Z,c,n),n&&n.debug(" Computing Z fft"),y.Z=await Kt.fromPolynomial(F.Z,4,c,n),F.Z.blindCoefficients([B.b[9],B.b[8],B.b[7]]),F.Z.degree()>=r.domainSize+3)throw new Error("Z Polynomial is not well calculated");delete v.Z}async function Q(){n&&n.debug("> Computing challenge alpha"),T.reset(),T.addScalar(B.beta),T.addScalar(B.gamma),T.addPolCommitment(P.getPolynomial("Z")),B.alpha=T.getChallenge(),B.alpha2=u.square(B.alpha),n&&n.debug(" challenges.alpha: "+u.toString(B.alpha,16)),n&&n.debug("> Computing T polynomial"),await D(),n&&n.debug("> Computing T MSM");let k=await F.T1.multiExponentiation(C,"T1"),K=await F.T2.multiExponentiation(C,"T2"),I=await F.T3.multiExponentiation(C,"T3");P.addPolynomial("T1",k),P.addPolynomial("T2",K),P.addPolynomial("T3",I)}async function D(){n&&n.debug(` Reading sections ${Bi}, ${Ii}, ${xi}, ${Pi}, ${Gi}. Q selectors`),y.QL=new Kt(new ut(w*4),c,n),y.QR=new Kt(new ut(w*4),c,n),y.QM=new Kt(new ut(w*4),c,n),y.QO=new Kt(new ut(w*4),c,n),y.QC=new Kt(new ut(w*4),c,n),await s.readToBuffer(y.QL.eval,0,w*4,f[Bi][0].p+w),await s.readToBuffer(y.QR.eval,0,w*4,f[Ii][0].p+w),await s.readToBuffer(y.QM.eval,0,w*4,f[xi][0].p+w),await s.readToBuffer(y.QO.eval,0,w*4,f[Pi][0].p+w),await s.readToBuffer(y.QC.eval,0,w*4,f[Gi][0].p+w),y.Lagrange=new Kt(new ut(w*4*r.nPublic),c,n);for(let d=0;d<r.nPublic;d++)await s.readToBuffer(y.Lagrange.eval,d*w*4,w*4,f[jd][0].p+d*5*w+w);v.T=new ut(w*4),v.Tz=new ut(w*4),n&&n.debug(" Computing T evaluations");let k=u.one;for(let d=0;d<r.domainSize*4;d++){n&&d!==0&&d%1e5===0&&n.debug(`      T evaluation ${d}/${r.domainSize*4}`);const S=y.A.getEvaluation(d),h=y.B.getEvaluation(d),U=y.C.getEvaluation(d),G=y.Z.getEvaluation(d),m=y.Z.getEvaluation((r.domainSize*4+4+d)%(r.domainSize*4)),z=y.QM.getEvaluation(d),W=y.QL.getEvaluation(d),it=y.QR.getEvaluation(d),X=y.QO.getEvaluation(d),lt=y.QC.getEvaluation(d),_t=y.Sigma1.getEvaluation(d),wt=y.Sigma2.getEvaluation(d),ft=y.Sigma3.getEvaluation(d),st=u.add(B.b[2],u.mul(B.b[1],k)),ct=u.add(B.b[4],u.mul(B.b[3],k)),gt=u.add(B.b[6],u.mul(B.b[5],k)),yt=u.square(k),xt=u.add(u.add(u.mul(B.b[7],yt),u.mul(B.b[8],k)),B.b[9]),Rt=u.mul(k,u.w[r.power]),Vt=u.square(Rt),jt=u.add(u.add(u.mul(B.b[7],Vt),u.mul(B.b[8],Rt)),B.b[9]);let Pt=u.zero;for(let mt=0;mt<r.nPublic;mt++){const Bt=mt*4*r.domainSize+d,It=y.Lagrange.getEvaluation(Bt),$t=v.A.slice(mt*b,(mt+1)*b);Pt=u.sub(Pt,u.mul(It,$t))}let[bt,kt]=Ai.mul2(S,h,st,ct,d%4,u);bt=u.mul(bt,z),kt=u.mul(kt,z),bt=u.add(bt,u.mul(S,W)),kt=u.add(kt,u.mul(st,W)),bt=u.add(bt,u.mul(h,it)),kt=u.add(kt,u.mul(ct,it)),bt=u.add(bt,u.mul(U,X)),kt=u.add(kt,u.mul(gt,X)),bt=u.add(bt,Pt),bt=u.add(bt,lt);const Jt=u.mul(B.beta,k);let Dt=S;Dt=u.add(Dt,Jt),Dt=u.add(Dt,B.gamma);let ot=h;ot=u.add(ot,u.mul(Jt,r.k1)),ot=u.add(ot,B.gamma);let p=U;p=u.add(p,u.mul(Jt,r.k2)),p=u.add(p,B.gamma);let L=G,[H,tt]=Ai.mul4(Dt,ot,p,L,st,ct,gt,xt,d%4,u);H=u.mul(H,B.alpha),tt=u.mul(tt,B.alpha);let N=S;N=u.add(N,u.mul(B.beta,_t)),N=u.add(N,B.gamma);let et=h;et=u.add(et,u.mul(B.beta,wt)),et=u.add(et,B.gamma);let Y=U;Y=u.add(Y,u.mul(B.beta,ft)),Y=u.add(Y,B.gamma);let rt=m,[ht,pt]=Ai.mul4(N,et,Y,rt,st,ct,gt,jt,d%4,u);ht=u.mul(ht,B.alpha),pt=u.mul(pt,B.alpha);let dt=u.sub(G,u.one);dt=u.mul(dt,y.Lagrange.getEvaluation(d)),dt=u.mul(dt,B.alpha2);let Lt=u.mul(xt,y.Lagrange.getEvaluation(d));Lt=u.mul(Lt,B.alpha2);let Et=u.add(u.sub(u.add(bt,H),ht),dt),vt=u.add(u.sub(u.add(kt,tt),pt),Lt);v.T.set(Et,d*b),v.Tz.set(vt,d*b),k=u.mul(k,u.w[r.power+2])}if(n&&n.debug(" Computing T ifft"),F.T=await Ft.fromEvaluations(v.T,c,n),n&&n.debug(" Computing T / ZH"),F.T.divZh(r.domainSize,4),n&&n.debug(" Computing Tz ifft"),F.Tz=await Ft.fromEvaluations(v.Tz,c,n),F.T.add(F.Tz),F.T.degree()>=r.domainSize*3+6)throw new Error("T Polynomial is not well calculated");n&&n.debug(" Computing T1, T2, T3 polynomials"),F.T1=new Ft(new ut((r.domainSize+1)*b),c,n),F.T2=new Ft(new ut((r.domainSize+1)*b),c,n),F.T3=new Ft(new ut((r.domainSize+6)*b),c,n),F.T1.coef.set(F.T.coef.slice(0,w),0),F.T2.coef.set(F.T.coef.slice(w,w*2),0),F.T3.coef.set(F.T.coef.slice(w*2,w*3+6*b),0),F.T1.setCoef(r.domainSize,B.b[10]);const K=u.sub(F.T2.getCoef(0),B.b[10]);F.T2.setCoef(0,K),F.T2.setCoef(r.domainSize,B.b[11]);const I=u.sub(F.T3.getCoef(0),B.b[11]);F.T3.setCoef(0,I)}async function V(){n&&n.debug("> Computing challenge xi"),T.reset(),T.addScalar(B.alpha),T.addPolCommitment(P.getPolynomial("T1")),T.addPolCommitment(P.getPolynomial("T2")),T.addPolCommitment(P.getPolynomial("T3")),B.xi=T.getChallenge(),B.xiw=u.mul(B.xi,u.w[r.power]),n&&n.debug(" challenges.xi: "+u.toString(B.xi,16)),P.addEvaluation("eval_a",F.A.evaluate(B.xi)),P.addEvaluation("eval_b",F.B.evaluate(B.xi)),P.addEvaluation("eval_c",F.C.evaluate(B.xi)),P.addEvaluation("eval_s1",F.Sigma1.evaluate(B.xi)),P.addEvaluation("eval_s2",F.Sigma2.evaluate(B.xi)),P.addEvaluation("eval_zw",F.Z.evaluate(B.xiw))}async function nt(){n&&n.debug("> Computing challenge v"),T.reset(),T.addScalar(B.xi),T.addScalar(P.getEvaluation("eval_a")),T.addScalar(P.getEvaluation("eval_b")),T.addScalar(P.getEvaluation("eval_c")),T.addScalar(P.getEvaluation("eval_s1")),T.addScalar(P.getEvaluation("eval_s2")),T.addScalar(P.getEvaluation("eval_zw")),B.v=[],B.v[1]=T.getChallenge(),n&&n.debug(" challenges.v: "+u.toString(B.v[1],16));for(let I=2;I<6;I++)B.v[I]=u.mul(B.v[I-1],B.v[1]);n&&n.debug("> Computing linearisation polynomial R(X)"),await R(),n&&n.debug("> Computing opening proof polynomial Wxi(X) polynomial"),at(),n&&n.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),J(),n&&n.debug("> Computing Wxi, Wxiw MSM");let k=await F.Wxi.multiExponentiation(C,"Wxi"),K=await F.Wxiw.multiExponentiation(C,"Wxiw");P.addPolynomial("Wxi",k),P.addPolynomial("Wxiw",K)}async function R(){const k=c.Fr;F.QL=new Ft(new ut(w),c,n),F.QR=new Ft(new ut(w),c,n),F.QM=new Ft(new ut(w),c,n),F.QO=new Ft(new ut(w),c,n),F.QC=new Ft(new ut(w),c,n),await s.readToBuffer(F.QL.coef,0,w,f[Bi][0].p),await s.readToBuffer(F.QR.coef,0,w,f[Ii][0].p),await s.readToBuffer(F.QM.coef,0,w,f[xi][0].p),await s.readToBuffer(F.QO.coef,0,w,f[Pi][0].p),await s.readToBuffer(F.QC.coef,0,w,f[Gi][0].p),B.xin=B.xi;for(let ct=0;ct<r.power;ct++)B.xin=k.square(B.xin);B.zh=k.sub(B.xin,k.one);const K=[],I=k.e(r.domainSize);let d=k.one;for(let ct=1;ct<=Math.max(1,r.nPublic);ct++)K[ct]=k.div(k.mul(d,B.zh),k.mul(I,k.sub(B.xi,d))),d=k.mul(d,k.w[r.power]);const S=k.div(k.sub(B.xin,k.one),k.mul(I,k.sub(B.xi,k.one)));if(n){n.debug("Lagrange Evaluations: ");for(let ct=1;ct<K.length;ct++)n.debug(`L${ct}(xi)=`+k.toString(K[ct],16))}let h=k.zero;for(let ct=0;ct<_.length;ct++){const gt=k.e(_[ct]);h=k.sub(h,k.mul(gt,K[ct+1]))}n&&n.debug("PI: "+k.toString(h,16));const U=k.mul(P.evaluations.eval_a,P.evaluations.eval_b);let G=P.evaluations.eval_a;const m=k.mul(B.beta,B.xi);G=k.add(G,m),G=k.add(G,B.gamma);let z=P.evaluations.eval_b;z=k.add(z,k.mul(m,r.k1)),z=k.add(z,B.gamma);let W=P.evaluations.eval_c;W=k.add(W,k.mul(m,r.k2)),W=k.add(W,B.gamma);const it=k.mul(k.mul(k.mul(G,z),W),B.alpha);let X=P.evaluations.eval_a;X=k.add(X,k.mul(B.beta,P.evaluations.eval_s1)),X=k.add(X,B.gamma);let lt=P.evaluations.eval_b;lt=k.add(lt,k.mul(B.beta,P.evaluations.eval_s2)),lt=k.add(lt,B.gamma);let _t=k.mul(X,lt);_t=k.mul(_t,P.evaluations.eval_zw),_t=k.mul(_t,B.alpha);const wt=k.mul(S,B.alpha2);F.R=new Ft(new ut((r.domainSize+6)*b),c,n),F.R.add(F.QM,U),F.R.add(F.QL,P.evaluations.eval_a),F.R.add(F.QR,P.evaluations.eval_b),F.R.add(F.QO,P.evaluations.eval_c),F.R.add(F.QC),F.R.add(F.Z,it),F.R.sub(F.Sigma3,k.mul(_t,B.beta)),F.R.add(F.Z,wt);let ft=Ft.fromPolynomial(F.T3,c,n);ft.mulScalar(k.square(B.xin)),ft.add(F.T2,B.xin),ft.add(F.T1),ft.mulScalar(B.zh),F.R.sub(ft);let st=k.sub(h,k.mul(_t,k.add(P.evaluations.eval_c,B.gamma)));st=k.sub(st,wt),n&&n.debug("r0: "+k.toString(st,16)),F.R.addScalar(st)}function at(){F.Wxi=new Ft(new ut(w+6*b),c,n),F.Wxi.add(F.R),F.Wxi.add(F.A,B.v[1]),F.Wxi.add(F.B,B.v[2]),F.Wxi.add(F.C,B.v[3]),F.Wxi.add(F.Sigma1,B.v[4]),F.Wxi.add(F.Sigma2,B.v[5]),F.Wxi.subScalar(u.mul(B.v[1],P.evaluations.eval_a)),F.Wxi.subScalar(u.mul(B.v[2],P.evaluations.eval_b)),F.Wxi.subScalar(u.mul(B.v[3],P.evaluations.eval_c)),F.Wxi.subScalar(u.mul(B.v[4],P.evaluations.eval_s1)),F.Wxi.subScalar(u.mul(B.v[5],P.evaluations.eval_s2)),F.Wxi.divByZerofier(1,B.xi)}async function J(){F.Wxiw=Ft.fromPolynomial(F.Z,c,n),F.Wxiw.subScalar(P.evaluations.eval_zw),F.Wxiw.divByZerofier(1,B.xiw)}}const{unstringifyBigInts:Hd}=rn;async function Wd(e,t,n,a,i,o){const l=Hd(e),s={type:"mem"};return await ci(l,t,s,i),await Gs(n,s,a,o)}const{unstringifyBigInts:Ti}=rn;async function Qd(e,t,n,a){let i=Ti(e);n=Ti(n);let o=Ti(t);const l=await Yn(i.curve),s=l.Fr,f=l.G1;a&&a.info("PLONK VERIFIER STARTED");let r=Dd(l,n);if(i=Kd(l,i),!Xd(l,r))return a.error("Proof commitments are not valid."),!1;if(o.length!=i.nPublic)return a&&a.error("Invalid number of public inputs"),!1;if(!Yd(l,r))return a&&a.error("Proof evaluations are not valid"),!1;if(!Jd(l,o))return a&&a.error("Public inputs are not valid."),!1;const c=tu(l,r,o,i);if(a){a.debug("beta: "+s.toString(c.beta,16)),a.debug("gamma: "+s.toString(c.gamma,16)),a.debug("alpha: "+s.toString(c.alpha,16)),a.debug("xi: "+s.toString(c.xi,16));for(let y=1;y<6;y++)a&&a.debug("v: "+s.toString(c.v[y],16));a.debug("u: "+s.toString(c.u,16))}const u=nu(l,c,i);if(a)for(let y=1;y<u.length;y++)a.debug(`L${y}(xi)=`+s.toString(u[y],16));if(o.length!=i.nPublic)return a.error("Number of public signals does not match with vk"),!1;const b=au(l,o,u);a&&a.debug("PI(xi): "+s.toString(b,16));const w=iu(l,r,c,b,u[1]);a&&a.debug("r0: "+s.toString(w,16));const A=eu(l,r,c,i,u[1]);a&&a.debug("D: "+f.toString(f.toAffine(A),16));const x=ou(l,r,c,i,A);a&&a.debug("F: "+f.toString(f.toAffine(x),16));const v=su(l,r,c,w);a&&a.debug("E: "+f.toString(f.toAffine(v),16));const F=await cu(l,r,c,i,v,x);return a&&(F?a.info("OK!"):a.warn("Invalid Proof")),F}function Dd(e,t){const n=e.G1,a=e.Fr,i={};return i.A=n.fromObject(t.A),i.B=n.fromObject(t.B),i.C=n.fromObject(t.C),i.Z=n.fromObject(t.Z),i.T1=n.fromObject(t.T1),i.T2=n.fromObject(t.T2),i.T3=n.fromObject(t.T3),i.eval_a=a.fromObject(t.eval_a),i.eval_b=a.fromObject(t.eval_b),i.eval_c=a.fromObject(t.eval_c),i.eval_zw=a.fromObject(t.eval_zw),i.eval_s1=a.fromObject(t.eval_s1),i.eval_s2=a.fromObject(t.eval_s2),i.Wxi=n.fromObject(t.Wxi),i.Wxiw=n.fromObject(t.Wxiw),i}function Kd(e,t){const n=e.G1,a=e.G2,i=e.Fr,o=t;return o.Qm=n.fromObject(t.Qm),o.Ql=n.fromObject(t.Ql),o.Qr=n.fromObject(t.Qr),o.Qo=n.fromObject(t.Qo),o.Qc=n.fromObject(t.Qc),o.S1=n.fromObject(t.S1),o.S2=n.fromObject(t.S2),o.S3=n.fromObject(t.S3),o.k1=i.fromObject(t.k1),o.k2=i.fromObject(t.k2),o.X_2=a.fromObject(t.X_2),o}function Xd(e,t){const n=e.G1;return!(!n.isValid(t.A)||!n.isValid(t.B)||!n.isValid(t.C)||!n.isValid(t.Z)||!n.isValid(t.T1)||!n.isValid(t.T2)||!n.isValid(t.T3)||!n.isValid(t.Wxi)||!n.isValid(t.Wxiw))}function Ts(e,t){return St.geq(t,0)&&St.lt(t,e.r)}function ta(e,t){return Ts(e,St.fromRprLE(t))}function Yd(e,t){return ta(e,t.eval_a)&&ta(e,t.eval_b)&&ta(e,t.eval_c)&&ta(e,t.eval_s1)&&ta(e,t.eval_s2)&&ta(e,t.eval_zw)}function Jd(e,t){for(let n=0;n<t.length;n++)if(!Ts(e,t[n]))return!1;return!0}function tu(e,t,n,a){const i=e.Fr,o={},l=new Wn(e);l.addPolCommitment(a.Qm),l.addPolCommitment(a.Ql),l.addPolCommitment(a.Qr),l.addPolCommitment(a.Qo),l.addPolCommitment(a.Qc),l.addPolCommitment(a.S1),l.addPolCommitment(a.S2),l.addPolCommitment(a.S3);for(let s=0;s<n.length;s++)l.addScalar(i.e(n[s]));l.addPolCommitment(t.A),l.addPolCommitment(t.B),l.addPolCommitment(t.C),o.beta=l.getChallenge(),l.reset(),l.addScalar(o.beta),o.gamma=l.getChallenge(),l.reset(),l.addScalar(o.beta),l.addScalar(o.gamma),l.addPolCommitment(t.Z),o.alpha=l.getChallenge(),l.reset(),l.addScalar(o.alpha),l.addPolCommitment(t.T1),l.addPolCommitment(t.T2),l.addPolCommitment(t.T3),o.xi=l.getChallenge(),l.reset(),l.addScalar(o.xi),l.addScalar(t.eval_a),l.addScalar(t.eval_b),l.addScalar(t.eval_c),l.addScalar(t.eval_s1),l.addScalar(t.eval_s2),l.addScalar(t.eval_zw),o.v=[],o.v[1]=l.getChallenge();for(let s=2;s<6;s++)o.v[s]=i.mul(o.v[s-1],o.v[1]);return l.reset(),l.addPolCommitment(t.Wxi),l.addPolCommitment(t.Wxiw),o.u=l.getChallenge(),o}function nu(e,t,n){const a=e.Fr;let i=t.xi,o=1;for(let r=0;r<n.power;r++)i=a.square(i),o*=2;t.xin=i,t.zh=a.sub(i,a.one);const l=[],s=a.e(o);let f=a.one;for(let r=1;r<=Math.max(1,n.nPublic);r++)l[r]=a.div(a.mul(f,t.zh),a.mul(s,a.sub(t.xi,f))),f=a.mul(f,a.w[n.power]);return l}function au(e,t,n){const a=e.Fr;let i=a.zero;for(let o=0;o<t.length;o++){const l=a.e(t[o]);i=a.sub(i,a.mul(l,n[o+1]))}return i}function iu(e,t,n,a,i){const o=e.Fr,l=a,s=o.mul(i,o.square(n.alpha));let f=o.add(t.eval_a,o.mul(n.beta,t.eval_s1));f=o.add(f,n.gamma);let r=o.add(t.eval_b,o.mul(n.beta,t.eval_s2));r=o.add(r,n.gamma);let c=o.add(t.eval_c,n.gamma),u=o.mul(o.mul(f,r),c);return u=o.mul(u,t.eval_zw),u=o.mul(u,n.alpha),o.sub(o.sub(l,s),u)}function eu(e,t,n,a,i){const o=e.G1,l=e.Fr;let s=o.timesFr(a.Qm,l.mul(t.eval_a,t.eval_b));s=o.add(s,o.timesFr(a.Ql,t.eval_a)),s=o.add(s,o.timesFr(a.Qr,t.eval_b)),s=o.add(s,o.timesFr(a.Qo,t.eval_c)),s=o.add(s,a.Qc);const f=l.mul(n.beta,n.xi),r=l.add(l.add(t.eval_a,f),n.gamma),c=l.add(l.add(t.eval_b,l.mul(f,a.k1)),n.gamma),u=l.add(l.add(t.eval_c,l.mul(f,a.k2)),n.gamma),b=l.mul(l.mul(l.mul(r,c),u),n.alpha),w=l.mul(i,l.square(n.alpha)),A=o.timesFr(t.Z,l.add(l.add(b,w),n.u)),x=l.add(l.add(t.eval_a,l.mul(n.beta,t.eval_s1)),n.gamma),v=l.add(l.add(t.eval_b,l.mul(n.beta,t.eval_s2)),n.gamma),F=l.mul(l.mul(n.alpha,n.beta),t.eval_zw),y=o.timesFr(a.S3,l.mul(l.mul(x,v),F)),B=t.T1,P=o.timesFr(t.T2,n.xin),T=o.timesFr(t.T3,l.square(n.xin));let C=o.add(B,o.add(P,T));return C=o.timesFr(C,n.zh),o.sub(o.sub(o.add(s,A),y),C)}function ou(e,t,n,a,i){const o=e.G1;let l=o.add(i,o.timesFr(t.A,n.v[1]));return l=o.add(l,o.timesFr(t.B,n.v[2])),l=o.add(l,o.timesFr(t.C,n.v[3])),l=o.add(l,o.timesFr(a.S1,n.v[4])),l=o.add(l,o.timesFr(a.S2,n.v[5])),l}function su(e,t,n,a){const i=e.G1,o=e.Fr;let l=o.add(o.neg(a),o.mul(n.v[1],t.eval_a));return l=o.add(l,o.mul(n.v[2],t.eval_b)),l=o.add(l,o.mul(n.v[3],t.eval_c)),l=o.add(l,o.mul(n.v[4],t.eval_s1)),l=o.add(l,o.mul(n.v[5],t.eval_s2)),l=o.add(l,o.mul(n.u,t.eval_zw)),i.timesFr(i.one,l)}async function cu(e,t,n,a,i,o){const l=e.G1,s=e.Fr;let f=t.Wxi;f=l.add(f,l.timesFr(t.Wxiw,n.u));let r=l.timesFr(t.Wxi,n.xi);const c=s.mul(s.mul(n.u,n.xi),s.w[a.power]);return r=l.add(r,l.timesFr(t.Wxiw,c)),r=l.add(r,o),r=l.sub(r,i),await e.pairingEq(l.neg(f),a.X_2,r,e.G2.one)}const{unstringifyBigInts:uo}=rn;function tn(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function lu(e,t){const n=uo(e),a=uo(t);await Yn(n.curve);let i="";for(let o=0;o<a.length;o++)i!=""&&(i=i+","),i=i+tn(a[o]);return`[${tn(n.A[0])}, ${tn(n.A[1])},${tn(n.B[0])},${tn(n.B[1])},${tn(n.C[0])},${tn(n.C[1])},${tn(n.Z[0])},${tn(n.Z[1])},${tn(n.T1[0])},${tn(n.T1[1])},${tn(n.T2[0])},${tn(n.T2[1])},${tn(n.T3[0])},${tn(n.T3[1])},${tn(n.Wxi[0])},${tn(n.Wxi[1])},${tn(n.Wxiw[0])},${tn(n.Wxiw[1])},${tn(n.eval_a)},${tn(n.eval_b)},${tn(n.eval_c)},${tn(n.eval_s1)},${tn(n.eval_s2)},${tn(n.eval_zw)}][${i}]`}var Ru=Object.freeze({__proto__:null,setup:Id,fullProve:Wd,prove:Gs,verify:Qd,exportSolidityCallData:lu});function fo(e,t){return[e,0,0,t.one,t.zero,t.zero,t.zero,t.zero]}function ru(e,t,n,a,i,o,l,s){return[e,t,n,a,i,o,l,s]}function du(e,t,n,a,i,o,l,s,f){return[e,t,n,a,i,o,l,s]}const Oi=0,zi=1,uu=2;class fu{constructor(t,n,a,i,o){this.Fr=t,this.logger=o,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(t,n,a,i){this.normalizeLinearCombination(n),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);const o=this.getLinearCombinationType(n),l=this.getLinearCombinationType(a);if(o===Oi||l===Oi)return this.processR1csAdditionConstraint(t,i);if(o===zi){const s=this.joinLinearCombinations(a,i,n[0]);return this.processR1csAdditionConstraint(t,s)}else if(l===zi){const s=this.joinLinearCombinations(n,i,a[0]);return this.processR1csAdditionConstraint(t,s)}else return this.processR1csMultiplicationConstraint(t,n,a,i)}getLinearCombinationType(t){let n=this.Fr.zero,a=0;const i=Object.keys(t);for(let o=0;o<i.length;o++)t[i[o]]==0n?delete t[i[o]]:i[o]==0?n=this.Fr.add(n,t[i[o]]):a++;return a>0?uu:this.Fr.isZero(n)?Oi:zi}normalizeLinearCombination(t){const n=Object.keys(t);for(let a=0;a<n.length;a++)this.Fr.isZero(t[n[a]])&&delete t[n[a]];return t}joinLinearCombinations(t,n,a){const i={};for(let o in t)typeof i[o]>"u"?i[o]=this.Fr.mul(a,t[o]):i[o]=this.Fr.add(i[o],this.Fr.mul(a,t[o]));for(let o in n){const l=this.Fr.neg(n[o]);typeof i[o]>"u"?i[o]=l:i[o]=this.Fr.add(i[o],l)}return this.normalizeLinearCombination(i)}reduceCoefs(t,n,a,i,o){const l={k:this.Fr.zero,signals:[],coefs:[]},s=[];for(let f in i)f==0?l.k=this.Fr.add(l.k,i[f]):i[f]!=0n&&s.push([Number(f),i[f]]);for(;s.length>o;){const f=s.shift(),r=s.shift(),c=t.nVars++,u=this.fnGetAdditionConstraint(f[0],r[0],c,this.Fr.neg(f[1]),this.Fr.neg(r[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);n.push(u),a.push([f[0],r[0],f[1],r[1]]),s.push([c,this.Fr.one])}for(let f=0;f<s.length;f++)l.signals[f]=s[f][0],l.coefs[f]=s[f][1];for(;l.coefs.length<o;)l.signals.push(0),l.coefs.push(this.Fr.zero);return l}processR1csAdditionConstraint(t,n){const a=[],i=[],o=this.reduceCoefs(t,a,i,n,3),l=this.fnGetAdditionConstraint(o.signals[0],o.signals[1],o.signals[2],o.coefs[0],o.coefs[1],this.Fr.zero,o.coefs[2],o.k);return a.push(l),[a,i]}processR1csMultiplicationConstraint(t,n,a,i){const o=[],l=[],s=this.reduceCoefs(t,o,l,n,1),f=this.reduceCoefs(t,o,l,a,1),r=this.reduceCoefs(t,o,l,i,1),c=this.fnGetMultiplicationConstraint(s.signals[0],f.signals[0],r.signals[0],this.Fr.mul(s.coefs[0],f.k),this.Fr.mul(s.k,f.coefs[0]),this.Fr.mul(s.coefs[0],f.coefs[0]),this.Fr.neg(r.coefs[0]),this.Fr.sub(this.Fr.mul(s.k,f.k),r.k));return o.push(c),[o,l]}}class ne{constructor(t,n,a){this.n=t,this.polynomials=Array(t).fill(void 0),this.curve=n,this.Fr=n.Fr,this.G1=n.G1,this.logger=a}addPolynomial(t,n){if(t>this.n-1)throw new Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[t]=n}degree(){let t=this.polynomials.map((n,a)=>n===void 0?0:n.degree()*this.n+a);return Math.max(...t)}getPolynomial(){let t=this.polynomials.map(l=>l===void 0?0:l.degree());const n=this.degree(),a=2**(Vn(n-1)+1),i=this.Fr.n8;let o=new Ft(new ut(a*i),this.curve,this.logger);for(let l=0;l<n;l++){const s=l*i,f=s*this.n;for(let r=0;r<this.n;r++)this.polynomials[r]!==void 0&&l<=t[r]&&o.coef.set(this.polynomials[r].coef.slice(s,s+i),f+r*i)}return o}async multiExponentiation(t,n){let a=this.getPolynomial();const i=a.coef.byteLength/this.Fr.n8,o=t.slice(0,i*this.G1.F.n8*2),l=await this.Fr.batchFromMontgomery(a.coef);let s=await this.G1.multiExpAffine(o,l,this.logger,n);return s=this.G1.toAffine(s),s}}async function _u(e,t,n,a){a&&a.info("FFLONK SETUP STARTED"),globalThis.gc&&globalThis.gc(),a&&a.info("> Reading PTau file");const{fd:i,sections:o}=await Ht(t,"ptau",1);if(!o[12])throw new Error("Powers of Tau is not well prepared. Section 12 missing.");a&&a.info("> Getting curve from PTau settings");const{curve:l}=await gn(i,o);a&&a.info("> Reading r1cs file");const{fd:s,sections:f}=await Ht(e,"r1cs",1),r=await li(s,f,{loadConstraints:!1,loadCustomGates:!0});if(r.prime!==l.r)throw new Error("r1cs curve does not match powers of tau ceremony curve");const c=l.Fr,u=l.Fr.n8,b=l.G1.F.n8*2,w=l.G2.F.n8*2;let A={},x={},v,F={nVars:r.nVars,nPublic:r.nOutputs+r.nPubInputs};const y=new wn;let B=new wn;if(a&&a.info("> Processing FFlonk constraints"),await Z(l.Fr,r,a),globalThis.gc&&globalThis.gc(),F.cirPower=Math.max(_r,Vn(y.length+2-1)+1),F.domainSize=2**F.cirPower,o[2][0].size<(F.domainSize*9+18)*b)throw new Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");if(o[3][0].size<w)throw new Error("Powers of Tau is not well prepared. Section 3 too small.");a&&(a.info("----------------------------"),a.info("  FFLONK SETUP SETTINGS"),a.info(`  Curve:         ${l.name}`),a.info(`  Circuit power: ${F.cirPower}`),a.info(`  Domain size:   ${F.domainSize}`),a.info(`  Vars:          ${F.nVars}`),a.info(`  Public vars:   ${F.nPublic}`),a.info(`  Constraints:   ${y.length}`),a.info(`  Additions:     ${B.length}`),a.info("----------------------------")),a&&a.info("> computing k1 and k2");const[P,T]=J();a&&a.info("> computing w3");const C=k();a&&a.info("> computing w4");const _=K();a&&a.info("> computing w8");const g=I();a&&a.info("> computing wr");const $=d(F.cirPower,l.Fr);return await j(),await s.close(),await i.close(),a&&a.info("FFLONK SETUP FINISHED"),0;async function Z(S,h,U){for(let X=0;X<F.nPublic;X++)y.push(fo(X+1,S));const G=new fu(S,fo,ru,du,U),m=await Zt(s,f,2);let z=0;for(let X=0;X<h.nConstraints;X++){U&&X!==0&&X%5e5===0&&U.info(`    processing r1cs constraints ${X}/${h.nConstraints}`);const[lt,_t]=G.processR1csConstraint(F,...W());y.push(...lt),B.push(..._t)}function W(){const X=[];return X[0]=it(),X[1]=it(),X[2]=it(),X}function it(){const X={},lt=m.slice(z,z+4);z+=4;const wt=new DataView(lt.buffer).getUint32(0,!0),ft=m.slice(z,z+(4+h.n8)*wt);z+=(4+h.n8)*wt;const st=new DataView(ft.buffer);for(let ct=0;ct<wt;ct++){const gt=st.getUint32(ct*(4+h.n8),!0),yt=h.F.fromRprLE(ft,ct*(4+h.n8)+4);X[gt]=yt}return X}return 0}async function j(){a&&a.info("> Writing the zkey file");const S=await _n(n,"zkey",1,hr,1<<22,1<<24);a&&a.info(` Writing Section ${no}. Zkey Header`),await O(S),a&&a.info(` Writing Section ${Ja}. Additions`),await E(S),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Qi}. A Map`),await q(S,Qi,0,"A map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Di}. B Map`),await q(S,Di,1,"B map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Ki}. C Map`),await q(S,Ki,2,"C map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Sa}. QL`),await M(S,Sa,3,"QL"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${va}. QR`),await M(S,va,4,"QR"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Ea}. QM`),await M(S,Ea,5,"QM"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Aa}. QO`),await M(S,Aa,6,"QO"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${xa}. QC`),await M(S,xa,7,"QC"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Sections ${Ba},${Ia},${Pa}. Sigma1, Sigma2 & Sigma 3`),await Q(S),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Xi}. Lagrange Polynomials`),await D(S),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${ti}. Powers of Tau`),await V(S),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Yi}. C0`),await nt(S),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Wi}. FFlonk Header`),await R(S),globalThis.gc&&globalThis.gc(),a&&a.info("> Writing the zkey file finished"),await S.close()}async function O(S){await Mt(S,no),await S.writeULE32(Ma),await Ut(S)}async function E(S){await Mt(S,Ja);const h=new Uint8Array(8+2*u),U=new DataView(h.buffer);for(let G=0;G<B.length;G++){a&&G!==0&&G%5e5===0&&a.info(`      writing Additions: ${G}/${B.length}`);const m=B[G];U.setUint32(0,m[0],!0),U.setUint32(4,m[1],!0),h.set(m[2],8),h.set(m[3],8+u),await S.write(h)}await Ut(S)}async function q(S,h,U,G){await Mt(S,h);for(let m=0;m<y.length;m++)a&&m!==0&&m%5e5===0&&a.info(`      writing witness ${G}: ${m}/${y.length}`),await S.writeULE32(y[m][U]);await Ut(S)}async function M(S,h,U,G){let m=new ut(F.domainSize*u);for(let z=0;z<y.length;z++)m.set(y[z][U],z*u),a&&z!==0&&z%5e5===0&&a.info(`      writing ${G}: ${z}/${y.length}`);A[G]=await Ft.fromEvaluations(m,l,a),x[G]=await Kt.fromPolynomial(A[G],4,l,a),await Mt(S,h),await S.write(A[G].coef),await S.write(x[G].eval),await Ut(S)}async function Q(S){const h=new ut(u*F.domainSize*3),U=new wn(F.nVars),G=new wn(F.nVars);let m=c.one;for(let W=0;W<F.domainSize;W++)W<y.length?(z(y[W][0],W),z(y[W][1],F.domainSize+W),z(y[W][2],F.domainSize*2+W)):W<F.domainSize-2?(z(0,W),z(0,F.domainSize+W),z(0,F.domainSize*2+W)):(h.set(m,W*u),h.set(c.mul(m,P),(F.domainSize+W)*u),h.set(c.mul(m,T),(F.domainSize*2+W)*u)),m=c.mul(m,c.w[F.cirPower]),a&&W!==0&&W%5e5===0&&a.info(`      writing sigma phase1: ${W}/${y.length}`);for(let W=0;W<F.nVars;W++)typeof G[W]<"u"?h.set(U[W],G[W]*u):console.log("Variable not used"),a&&W!==0&&W%5e5===0&&a.info(`      writing sigma phase2: ${W}/${F.nVars}`);globalThis.gc&&globalThis.gc();for(let W=0;W<3;W++){const it=W===0?Ba:W===1?Ia:Pa;let X="S"+(W+1);A[X]=await Ft.fromEvaluations(h.slice(F.domainSize*u*W,F.domainSize*u*(W+1)),l,a),x[X]=await Kt.fromPolynomial(A[X],4,l,a),await Mt(S,it),await S.write(A[X].coef),await S.write(x[X].eval),await Ut(S),globalThis.gc&&globalThis.gc()}return 0;function z(W,it){typeof U[W]>"u"?G[W]=it:h.set(U[W],it*u);let X;it<F.domainSize?X=m:it<2*F.domainSize?X=c.mul(m,P):X=c.mul(m,T),U[W]=X}}async function D(S){await Mt(S,Xi);const h=Math.max(F.nPublic,1);for(let U=0;U<h;U++){let G=new ut(F.domainSize*u);G.set(c.one,U*u),await at(S,G)}await Ut(S)}async function V(S){await Mt(S,ti),v=new ut((F.domainSize*9+18)*b),await i.readToBuffer(v,0,(F.domainSize*9+18)*b,o[2][0].p),await S.write(v),await Ut(S)}async function nt(S){let h=new ne(8,l,a);if(h.addPolynomial(0,A.QL),h.addPolynomial(1,A.QR),h.addPolynomial(2,A.QO),h.addPolynomial(3,A.QM),h.addPolynomial(4,A.QC),h.addPolynomial(5,A.S1),h.addPolynomial(6,A.S2),h.addPolynomial(7,A.S3),A.C0=h.getPolynomial(),A.C0.degree()>=8*F.domainSize)throw new Error("C0 Polynomial is not well calculated");await Mt(S,Yi),await S.write(A.C0.coef),await Ut(S)}async function R(S){await Mt(S,Wi);const h=l.q,U=(Math.floor((St.bitLength(h)-1)/64)+1)*8;await S.writeULE32(U),await yn(S,h,U);const G=l.r,m=(Math.floor((St.bitLength(G)-1)/64)+1)*8;await S.writeULE32(m),await yn(S,G,m),await S.writeULE32(F.nVars),await S.writeULE32(F.nPublic),await S.writeULE32(F.domainSize),await S.writeULE32(B.length),await S.writeULE32(y.length),await S.write(P),await S.write(T),await S.write(C),await S.write(_),await S.write(g),await S.write($);let z;z=await i.read(w,o[3][0].p+w),await S.write(z);let W=await A.C0.multiExponentiation(v,"C0");await S.write(W),await Ut(S)}async function at(S,h){const[U,G]=await Ft.to4T(h,F.domainSize,[],c);return await S.write(U),await S.write(G),[U,G]}function J(){let S=c.two;for(;U(S,[],F.cirPower);)c.add(S,c.one);let h=c.add(S,c.one);for(;U(h,[S],F.cirPower);)c.add(h,c.one);return[S,h];function U(G,m,z){const W=2**z;let it=c.one;for(let X=0;X<W;X++){if(c.eq(G,it))return!0;for(let lt=0;lt<m.length;lt++)if(c.eq(G,c.mul(m[lt],it)))return!0;it=c.mul(it,c.w[z])}return!1}}function k(){let S=c.e(31624),U=St.div(3648040478639879203707734290876212514758060733402672390616367364429301415936n,St.e(3));return c.exp(S,U)}function K(){return c.w[2]}function I(){return c.w[3]}function d(S,h){const U=h.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);return h.exp(U,2**(28-S))}}const{stringifyBigInts:_o}=rn;async function Os(e,t,n,a){n&&n.info("FFLONK PROVER STARTED"),n&&n.info("> Reading witness file");const{fd:i,sections:o}=await Ht(t,"wtns",2),l=await Ua(i,o);n&&n.info("> Reading zkey file");const{fd:s,sections:f}=await Ht(e,"zkey",2),r=await Cn(s,f,void 0,a);if(r.protocolId!==Ma)throw new Error("zkey file is not fflonk");if(!St.eq(r.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!==r.nVars-r.nAdditions)throw new Error(`Invalid witness length. Circuit: ${r.nVars}, witness: ${l.nWitness}, ${r.nAdditions}`);const c=r.curve,u=c.Fr,b=c.Fr.n8,w=c.G1.F.n8*2,A=r.domainSize*b;n&&(n.info("----------------------------"),n.info("  FFLONK PROVE SETTINGS"),n.info(`  Curve:         ${c.name}`),n.info(`  Circuit power: ${r.power}`),n.info(`  Domain size:   ${r.domainSize}`),n.info(`  Vars:          ${r.nVars}`),n.info(`  Public vars:   ${r.nPublic}`),n.info(`  Constraints:   ${r.nConstraints}`),n.info(`  Additions:     ${r.nAdditions}`),n.info("----------------------------")),n&&n.info("> Reading witness file data");const x=await Zt(i,o,2);await i.close(),x.set(u.zero,0);const v=new ut(r.nAdditions*b);let F={},y={},B={},P={},T={},C={},_=new Fe(c,n);n&&n.info(`> Reading Section ${Ja}. Additions`),await j(),n&&n.info(`> Reading Sections ${Ba},${Ia},${Pa}. Sigma1, Sigma2 & Sigma 3`),n&&n.info(" Reading Sigma polynomials "),y.Sigma1=new Ft(new ut(A),c,n),y.Sigma2=new Ft(new ut(A),c,n),y.Sigma3=new Ft(new ut(A),c,n),await s.readToBuffer(y.Sigma1.coef,0,A,f[Ba][0].p),await s.readToBuffer(y.Sigma2.coef,0,A,f[Ia][0].p),await s.readToBuffer(y.Sigma3.coef,0,A,f[Pa][0].p),n&&n.info(" Reading Sigma evaluations"),B.Sigma1=new Kt(new ut(A*4),c,n),B.Sigma2=new Kt(new ut(A*4),c,n),B.Sigma3=new Kt(new ut(A*4),c,n),await s.readToBuffer(B.Sigma1.eval,0,A*4,f[Ba][0].p+A),await s.readToBuffer(B.Sigma2.eval,0,A*4,f[Ia][0].p+A),await s.readToBuffer(B.Sigma3.eval,0,A*4,f[Pa][0].p+A),n&&n.info(`> Reading Section ${ti}. Powers of Tau`);const g=new ut(r.domainSize*16*w);await s.readToBuffer(g,0,(r.domainSize*9+18)*w,f[ti][0].p),globalThis.gc&&globalThis.gc(),n&&n.info(""),n&&n.info("> ROUND 1"),await q(),delete y.T0,delete B.QL,delete B.QR,delete B.QM,delete B.QO,delete B.QC,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 2"),await M(),delete F.A,delete F.B,delete F.C,delete B.A,delete B.B,delete B.C,delete B.Sigma1,delete B.Sigma2,delete B.Sigma3,delete B.lagrange1,delete B.Z,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 3"),await Q(),delete y.A,delete y.B,delete y.C,delete y.Z,delete y.T1,delete y.T2,delete y.Sigma1,delete y.Sigma2,delete y.Sigma3,delete y.QL,delete y.QR,delete y.QM,delete y.QC,delete y.QO,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 4"),await D(),globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 5"),await V(),delete y.C0,delete y.C1,delete y.C2,delete y.R1,delete y.R2,delete y.F,delete y.L,delete y.ZT,delete y.ZTS2,await s.close(),globalThis.gc&&globalThis.gc(),_.addEvaluation("inv",nt());let $=_.toObjectProof();$.protocol="fflonk",$.curve=c.name;let Z=[];for(let R=1;R<=r.nPublic;R++){const at=R*b,J=x.slice(at,at+b);Z.push(St.fromRprLE(J))}return n&&n.info("FFLONK PROVER FINISHED"),{proof:_o($),publicSignals:_o(Z)};async function j(){n&&n.info(" Computing additions");const R=await Zt(s,f,Ja),at=8+b*2;for(let J=0;J<r.nAdditions;J++){n&&J!==0&&J%1e5===0&&n.info(`    addition ${J}/${r.nAdditions}`);let k=J*at;const K=O(R,k);k+=4;const I=O(R,k);k+=4;const d=R.slice(k,k+b);k+=b;const S=R.slice(k,k+b),h=E(K),U=E(I),G=u.add(u.mul(d,h),u.mul(S,U));v.set(G,b*J)}}function O(R,at){const J=R.slice(at,at+4);return new DataView(J.buffer,J.byteOffset,J.byteLength).getUint32(0,!0)}function E(R){let at=r.nVars-r.nAdditions;if(R<at)return x.slice(R*b,R*b+b);if(R<r.nVars){const J=(R-at)*b;return v.slice(J,J+b)}return u.zero}async function q(){T.b=[];for(let K=1;K<=9;K++)T.b[K]=u.random();n&&n.info("> Computing A, B, C wire polynomials"),await at(),n&&n.info("> Computing T0 polynomial"),await J(),n&&n.info("> Computing C1 polynomial"),await k(),n&&n.info("> Computing C1 multi exponentiation");let R=await y.C1.multiExponentiation(g,"C1");return _.addPolynomial("C1",R),0;async function at(){n&&n.info(" Reading data from zkey file"),F.A=new ut(A),F.B=new ut(A),F.C=new ut(A);const K=await Zt(s,f,Qi),I=await Zt(s,f,Di),d=await Zt(s,f,Ki);for(let S=0;S<r.nConstraints;S++){const h=S*b,U=S*4,G=O(K,U);F.A.set(E(G),h);const m=O(I,U);F.B.set(E(m),h);const z=O(d,U);F.C.set(E(z),h)}if(F.A.set(T.b[1],A-64),F.A.set(T.b[2],A-32),F.B.set(T.b[3],A-64),F.B.set(T.b[4],A-32),F.C.set(T.b[5],A-64),F.C.set(T.b[6],A-32),F.A=await u.batchToMontgomery(F.A),F.B=await u.batchToMontgomery(F.B),F.C=await u.batchToMontgomery(F.C),n&&n.info(" Computing A ifft"),y.A=await Ft.fromEvaluations(F.A,c,n),n&&n.info(" Computing B ifft"),y.B=await Ft.fromEvaluations(F.B,c,n),n&&n.info(" Computing C ifft"),y.C=await Ft.fromEvaluations(F.C,c,n),n&&n.info(" Computing A fft"),B.A=await Kt.fromPolynomial(y.A,4,c,n),n&&n.info(" Computing B fft"),B.B=await Kt.fromPolynomial(y.B,4,c,n),n&&n.info(" Computing C fft"),B.C=await Kt.fromPolynomial(y.C,4,c,n),y.A.degree()>=r.domainSize)throw new Error("A Polynomial is not well calculated");if(y.B.degree()>=r.domainSize)throw new Error("B Polynomial is not well calculated");if(y.C.degree()>=r.domainSize)throw new Error("C Polynomial is not well calculated")}async function J(){n&&n.info(` Reading sections ${Sa}, ${va}, ${Ea}, ${Aa}, ${xa}. Q selectors`),B.QL=new Kt(new ut(A*4),c,n),B.QR=new Kt(new ut(A*4),c,n),B.QM=new Kt(new ut(A*4),c,n),B.QO=new Kt(new ut(A*4),c,n),B.QC=new Kt(new ut(A*4),c,n),await s.readToBuffer(B.QL.eval,0,A*4,f[Sa][0].p+A),await s.readToBuffer(B.QR.eval,0,A*4,f[va][0].p+A),await s.readToBuffer(B.QM.eval,0,A*4,f[Ea][0].p+A),await s.readToBuffer(B.QO.eval,0,A*4,f[Aa][0].p+A),await s.readToBuffer(B.QC.eval,0,A*4,f[xa][0].p+A);const K=await Zt(s,f,Xi);B.lagrange1=new Kt(K,c,n),F.T0=new ut(A*4),n&&n.info(" Computing T0 evaluations");for(let I=0;I<r.domainSize*4;I++){n&&I!==0&&I%1e5===0&&n.info(`      T0 evaluation ${I}/${r.domainSize*4}`);const d=B.A.getEvaluation(I),S=B.B.getEvaluation(I),h=B.C.getEvaluation(I),U=B.QL.getEvaluation(I),G=B.QR.getEvaluation(I),m=B.QM.getEvaluation(I),z=B.QO.getEvaluation(I),W=B.QC.getEvaluation(I);let it=u.zero;for(let st=0;st<r.nPublic;st++){const ct=st*5*r.domainSize+r.domainSize+I,gt=B.lagrange1.getEvaluation(ct),yt=F.A.slice(st*b,(st+1)*b);it=u.sub(it,u.mul(gt,yt))}const X=u.mul(d,U),lt=u.mul(S,G),_t=u.mul(u.mul(d,S),m),wt=u.mul(h,z),ft=u.add(X,u.add(lt,u.add(_t,u.add(wt,u.add(W,it)))));F.T0.set(ft,I*b)}if(n&&n.info("buffer T0: "+F.T0.byteLength/b),n&&n.info(" Computing T0 ifft"),y.T0=await Ft.fromEvaluations(F.T0,c,n),n&&n.info("T0 length: "+y.T0.length()),n&&n.info("T0 degree: "+y.T0.degree()),n&&n.info(" Computing T0 / ZH"),y.T0.divByZerofier(r.domainSize,u.one),y.T0.degree()>=2*r.domainSize-2)throw new Error(`T0 Polynomial is not well calculated (degree is ${y.T0.degree()} and must be less than ${2*r.domainSize+2}`);delete F.T0}async function k(){let K=new ne(4,c,n);if(K.addPolynomial(0,y.A),K.addPolynomial(1,y.B),K.addPolynomial(2,y.C),K.addPolynomial(3,y.T0),y.C1=K.getPolynomial(),y.C1.degree()>=8*r.domainSize-8)throw new Error("C1 Polynomial is not well calculated")}}async function M(){n&&n.info("> Computing challenges beta and gamma");const R=new Wn(c);R.addPolCommitment(r.C0);for(let d=0;d<r.nPublic;d++)R.addScalar(F.A.slice(d*b,d*b+b));R.addPolCommitment(_.getPolynomial("C1")),T.beta=R.getChallenge(),n&&n.info(" challenges.beta: "+u.toString(T.beta)),R.reset(),R.addScalar(T.beta),T.gamma=R.getChallenge(),n&&n.info(" challenges.gamma: "+u.toString(T.gamma)),n&&n.info("> Computing Z polynomial"),await J(),n&&n.info("> Computing T1 polynomial"),await k(),n&&n.info("> Computing T2 polynomial"),await K(),n&&n.info("> Computing C2 polynomial"),await I(),n&&n.info("> Computing C2 multi exponentiation");let at=await y.C2.multiExponentiation(g,"C2");return _.addPolynomial("C2",at),0;async function J(){n&&n.info(" Computing Z evaluations");let d=new ut(A),S=new ut(A);d.set(u.one,0),S.set(u.one,0);let h=u.one;for(let U=0;U<r.domainSize;U++){n&&U!==0&&U%1e5===0&&n.info(`    Z evaluation ${U}/${r.domainSize}`);const G=U*b,m=u.mul(T.beta,h);let z=F.A.slice(G,G+b);z=u.add(z,m),z=u.add(z,T.gamma);let W=F.B.slice(G,G+b);W=u.add(W,u.mul(r.k1,m)),W=u.add(W,T.gamma);let it=F.C.slice(G,G+b);it=u.add(it,u.mul(r.k2,m)),it=u.add(it,T.gamma);let X=u.mul(z,u.mul(W,it)),lt=F.A.slice(G,G+b);lt=u.add(lt,u.mul(T.beta,B.Sigma1.getEvaluation(U*4))),lt=u.add(lt,T.gamma);let _t=F.B.slice(G,G+b);_t=u.add(_t,u.mul(T.beta,B.Sigma2.getEvaluation(U*4))),_t=u.add(_t,T.gamma);let wt=F.C.slice(G,G+b);wt=u.add(wt,u.mul(T.beta,B.Sigma3.getEvaluation(U*4))),wt=u.add(wt,T.gamma);let ft=u.mul(lt,u.mul(_t,wt));X=u.mul(d.slice(G,G+b),X),d.set(X,(U+1)%r.domainSize*b),ft=u.mul(S.slice(G,G+b),ft),S.set(ft,(U+1)%r.domainSize*b),h=u.mul(h,u.w[r.power])}S=await u.batchInverse(S);for(let U=0;U<r.domainSize;U++){const G=U*b,m=u.mul(d.slice(G,G+b),S.slice(G,G+b));d.set(m,G)}if(F.Z=d,!u.eq(d.slice(0,b),u.one))throw new Error("Copy constraints does not match");if(n&&n.info(" Computing Z ifft"),y.Z=await Ft.fromEvaluations(F.Z,c,n),n&&n.info(" Computing Z fft"),B.Z=await Kt.fromPolynomial(y.Z,4,c,n),y.Z.blindCoefficients([T.b[9],T.b[8],T.b[7]]),y.Z.degree()>=r.domainSize+3)throw new Error("Z Polynomial is not well calculated");delete F.Z}async function k(){n&&n.info(" Computing T1 evaluations"),F.T1=new ut(A*2),F.T1z=new ut(A*2);let d=u.one;for(let S=0;S<r.domainSize*2;S++){n&&S!==0&&S%1e5===0&&n.info(`    T1 evaluation ${S}/${r.domainSize*4}`);const h=u.square(d),U=B.Z.getEvaluation(S*2),G=u.add(u.add(u.mul(T.b[7],h),u.mul(T.b[8],d)),T.b[9]),m=B.lagrange1.getEvaluation(r.domainSize+S*2);let z=u.mul(u.sub(U,u.one),m),W=u.mul(G,m);F.T1.set(z,S*b),F.T1z.set(W,S*b),d=u.mul(d,u.w[r.power+1])}if(n&&n.info(" Computing T1 ifft"),y.T1=await Ft.fromEvaluations(F.T1,c,n),y.T1.divByZerofier(r.domainSize,u.one),n&&n.info(" Computing T1z ifft"),y.T1z=await Ft.fromEvaluations(F.T1z,c,n),y.T1.add(y.T1z),y.T1.degree()>=r.domainSize+2)throw new Error("T1 Polynomial is not well calculated");delete F.T1,delete F.T1z,delete y.T1z}async function K(){n&&n.info(" Computing T2 evaluations"),F.T2=new ut(A*4),F.T2z=new ut(A*4);let d=u.one;for(let S=0;S<r.domainSize*4;S++){n&&S!==0&&S%1e5===0&&n.info(`    T2 evaluation ${S}/${r.domainSize*4}`);const h=u.square(d),U=u.mul(d,u.w[r.power]),G=u.square(U),m=B.A.getEvaluation(S),z=B.B.getEvaluation(S),W=B.C.getEvaluation(S),it=B.Z.getEvaluation(S),X=B.Z.getEvaluation((r.domainSize*4+4+S)%(r.domainSize*4)),lt=u.add(u.add(u.mul(T.b[7],h),u.mul(T.b[8],d)),T.b[9]),_t=u.add(u.add(u.mul(T.b[7],G),u.mul(T.b[8],U)),T.b[9]),wt=B.Sigma1.getEvaluation(S),ft=B.Sigma2.getEvaluation(S),st=B.Sigma3.getEvaluation(S),ct=u.mul(T.beta,d);let gt=u.add(m,ct);gt=u.add(gt,T.gamma);let yt=u.add(z,u.mul(ct,r.k1));yt=u.add(yt,T.gamma);let xt=u.add(W,u.mul(ct,r.k2));xt=u.add(xt,T.gamma);let Rt=u.mul(u.mul(u.mul(gt,yt),xt),it),Vt=u.mul(u.mul(u.mul(gt,yt),xt),lt),jt=u.add(m,u.mul(T.beta,wt));jt=u.add(jt,T.gamma);let Pt=u.add(z,u.mul(T.beta,ft));Pt=u.add(Pt,T.gamma);let bt=u.add(W,u.mul(T.beta,st));bt=u.add(bt,T.gamma);let kt=u.mul(u.mul(u.mul(jt,Pt),bt),X),Jt=u.mul(u.mul(u.mul(jt,Pt),bt),_t),Dt=u.sub(Rt,kt),ot=u.sub(Vt,Jt);F.T2.set(Dt,S*b),F.T2z.set(ot,S*b),d=u.mul(d,u.w[r.power+2])}if(n&&n.info(" Computing T2 ifft"),y.T2=await Ft.fromEvaluations(F.T2,c,n),n&&n.info(" Computing T2 / ZH"),y.T2.divByZerofier(r.domainSize,u.one),n&&n.info(" Computing T2z ifft"),y.T2z=await Ft.fromEvaluations(F.T2z,c,n),y.T2.add(y.T2z),y.T2.degree()>=3*r.domainSize)throw new Error("T2 Polynomial is not well calculated");delete F.T2,delete F.T2z,delete y.T2z}async function I(){let d=new ne(3,c,n);if(d.addPolynomial(0,y.Z),d.addPolynomial(1,y.T1),d.addPolynomial(2,y.T2),y.C2=d.getPolynomial(),y.C2.degree()>=9*r.domainSize)throw new Error("C2 Polynomial is not well calculated")}}async function Q(){n&&n.info("> Computing challenge xi");const R=new Wn(c);R.addScalar(T.gamma),R.addPolCommitment(_.getPolynomial("C2")),T.xiSeed=R.getChallenge();const at=u.square(T.xiSeed);C.w8=[],C.w8[0]=u.one;for(let J=1;J<8;J++)C.w8[J]=u.mul(C.w8[J-1],r.w8);C.w4=[],C.w4[0]=u.one;for(let J=1;J<4;J++)C.w4[J]=u.mul(C.w4[J-1],r.w4);C.w3=[],C.w3[0]=u.one,C.w3[1]=r.w3,C.w3[2]=u.square(r.w3),C.S0={},C.S0.h0w8=[],C.S0.h0w8[0]=u.mul(at,T.xiSeed);for(let J=1;J<8;J++)C.S0.h0w8[J]=u.mul(C.S0.h0w8[0],C.w8[J]);C.S1={},C.S1.h1w4=[],C.S1.h1w4[0]=u.square(C.S0.h0w8[0]);for(let J=1;J<4;J++)C.S1.h1w4[J]=u.mul(C.S1.h1w4[0],C.w4[J]);C.S2={},C.S2.h2w3=[],C.S2.h2w3[0]=u.mul(C.S1.h1w4[0],at),C.S2.h2w3[1]=u.mul(C.S2.h2w3[0],C.w3[1]),C.S2.h2w3[2]=u.mul(C.S2.h2w3[0],C.w3[2]),C.S2.h3w3=[],C.S2.h3w3[0]=u.mul(C.S2.h2w3[0],r.wr),C.S2.h3w3[1]=u.mul(C.S2.h3w3[0],C.w3[1]),C.S2.h3w3[2]=u.mul(C.S2.h3w3[0],C.w3[2]),T.xi=u.mul(u.square(C.S2.h2w3[0]),C.S2.h2w3[0]),n&&n.info(" challenges.xi: "+u.toString(T.xi)),y.QL=new Ft(new ut(A),c,n),y.QR=new Ft(new ut(A),c,n),y.QM=new Ft(new ut(A),c,n),y.QO=new Ft(new ut(A),c,n),y.QC=new Ft(new ut(A),c,n),await s.readToBuffer(y.QL.coef,0,A,f[Sa][0].p),await s.readToBuffer(y.QR.coef,0,A,f[va][0].p),await s.readToBuffer(y.QM.coef,0,A,f[Ea][0].p),await s.readToBuffer(y.QO.coef,0,A,f[Aa][0].p),await s.readToBuffer(y.QC.coef,0,A,f[xa][0].p),n&&n.info(" Computing evaluations"),_.addEvaluation("ql",y.QL.evaluate(T.xi)),_.addEvaluation("qr",y.QR.evaluate(T.xi)),_.addEvaluation("qm",y.QM.evaluate(T.xi)),_.addEvaluation("qo",y.QO.evaluate(T.xi)),_.addEvaluation("qc",y.QC.evaluate(T.xi)),_.addEvaluation("s1",y.Sigma1.evaluate(T.xi)),_.addEvaluation("s2",y.Sigma2.evaluate(T.xi)),_.addEvaluation("s3",y.Sigma3.evaluate(T.xi)),_.addEvaluation("a",y.A.evaluate(T.xi)),_.addEvaluation("b",y.B.evaluate(T.xi)),_.addEvaluation("c",y.C.evaluate(T.xi)),_.addEvaluation("z",y.Z.evaluate(T.xi)),T.xiw=u.mul(T.xi,u.w[r.power]),_.addEvaluation("zw",y.Z.evaluate(T.xiw)),_.addEvaluation("t1w",y.T1.evaluate(T.xiw)),_.addEvaluation("t2w",y.T2.evaluate(T.xiw))}async function D(){n&&n.info("> Computing challenge alpha");const R=new Wn(c);R.addScalar(T.xiSeed),R.addScalar(_.getEvaluation("ql")),R.addScalar(_.getEvaluation("qr")),R.addScalar(_.getEvaluation("qm")),R.addScalar(_.getEvaluation("qo")),R.addScalar(_.getEvaluation("qc")),R.addScalar(_.getEvaluation("s1")),R.addScalar(_.getEvaluation("s2")),R.addScalar(_.getEvaluation("s3")),R.addScalar(_.getEvaluation("a")),R.addScalar(_.getEvaluation("b")),R.addScalar(_.getEvaluation("c")),R.addScalar(_.getEvaluation("z")),R.addScalar(_.getEvaluation("zw")),R.addScalar(_.getEvaluation("t1w")),R.addScalar(_.getEvaluation("t2w")),T.alpha=R.getChallenge(),n&&n.info(" challenges.alpha: "+u.toString(T.alpha)),n&&n.info("> Reading C0 polynomial"),y.C0=new Ft(new ut(A*8),c,n),await s.readToBuffer(y.C0.coef,0,A*8,f[Yi][0].p),n&&n.info("> Computing R0 polynomial"),J(),n&&n.info("> Computing R1 polynomial"),k(),n&&n.info("> Computing R2 polynomial"),K(),n&&n.info("> Computing F polynomial"),await I(),n&&n.info("> Computing W1 multi exponentiation");let at=await y.F.multiExponentiation(g,"W1");return _.addPolynomial("W1",at),0;function J(){if(y.R0=Ft.lagrangePolynomialInterpolation([C.S0.h0w8[0],C.S0.h0w8[1],C.S0.h0w8[2],C.S0.h0w8[3],C.S0.h0w8[4],C.S0.h0w8[5],C.S0.h0w8[6],C.S0.h0w8[7]],[y.C0.evaluate(C.S0.h0w8[0]),y.C0.evaluate(C.S0.h0w8[1]),y.C0.evaluate(C.S0.h0w8[2]),y.C0.evaluate(C.S0.h0w8[3]),y.C0.evaluate(C.S0.h0w8[4]),y.C0.evaluate(C.S0.h0w8[5]),y.C0.evaluate(C.S0.h0w8[6]),y.C0.evaluate(C.S0.h0w8[7])],c),y.R0.degree()>7)throw new Error("R0 Polynomial is not well calculated")}function k(){if(y.R1=Ft.lagrangePolynomialInterpolation([C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3]],[y.C1.evaluate(C.S1.h1w4[0]),y.C1.evaluate(C.S1.h1w4[1]),y.C1.evaluate(C.S1.h1w4[2]),y.C1.evaluate(C.S1.h1w4[3])],c),y.R1.degree()>3)throw new Error("R1 Polynomial is not well calculated")}function K(){if(y.R2=Ft.lagrangePolynomialInterpolation([C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],[y.C2.evaluate(C.S2.h2w3[0]),y.C2.evaluate(C.S2.h2w3[1]),y.C2.evaluate(C.S2.h2w3[2]),y.C2.evaluate(C.S2.h3w3[0]),y.C2.evaluate(C.S2.h3w3[1]),y.C2.evaluate(C.S2.h3w3[2])],c),y.R2.degree()>5)throw new Error("R2 Polynomial is not well calculated")}async function I(){n&&n.info(" Computing F polynomial"),y.F=Ft.fromPolynomial(y.C0,c,n),y.F.sub(y.R0),y.F.divByZerofier(8,T.xi);let d=Ft.fromPolynomial(y.C1,c,n);d.sub(y.R1),d.mulScalar(T.alpha),d.divByZerofier(4,T.xi);let S=Ft.fromPolynomial(y.C2,c,n);if(S.sub(y.R2),S.mulScalar(u.square(T.alpha)),S.divByZerofier(3,T.xi),S.divByZerofier(3,T.xiw),y.F.add(d),y.F.add(S),y.F.degree()>=9*r.domainSize-6)throw new Error("F Polynomial is not well calculated")}}async function V(){n&&n.info("> Computing challenge y");const R=new Wn(c);R.addScalar(T.alpha),R.addPolCommitment(_.getPolynomial("W1")),T.y=R.getChallenge(),n&&n.info(" challenges.y: "+u.toString(T.y)),n&&n.info("> Computing L polynomial"),await I(),n&&n.info("> Computing ZTS2 polynomial"),await S();let at=y.ZTS2.evaluate(T.y);at=u.inv(at),y.L.mulScalar(at);const J=Ft.fromCoefficientsArray([u.neg(T.y),u.one],c);n&&n.info("> Computing W' = L / ZTS2 polynomial");const k=y.L.divBy(J);if(k.degree()>0)throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${k.degree()} and should be 0`);if(y.L.degree()>=9*r.domainSize-1)throw new Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");n&&n.info("> Computing W' multi exponentiation");let K=await y.L.multiExponentiation(g,"W2");return _.addPolynomial("W2",K),0;async function I(){n&&n.info(" Computing L polynomial");const h=y.R0.evaluate(T.y),U=y.R1.evaluate(T.y),G=y.R2.evaluate(T.y);let m=u.sub(T.y,C.S0.h0w8[0]);for(let st=1;st<8;st++)m=u.mul(m,u.sub(T.y,C.S0.h0w8[st]));let z=u.sub(T.y,C.S1.h1w4[0]);for(let st=1;st<4;st++)z=u.mul(z,u.sub(T.y,C.S1.h1w4[st]));let W=u.sub(T.y,C.S2.h2w3[0]);for(let st=1;st<3;st++)W=u.mul(W,u.sub(T.y,C.S2.h2w3[st]));for(let st=0;st<3;st++)W=u.mul(W,u.sub(T.y,C.S2.h3w3[st]));let it=u.mul(z,W),X=u.mul(T.alpha,u.mul(m,W)),lt=u.mul(u.square(T.alpha),u.mul(m,z));P.denH1=z,P.denH2=W,y.L=Ft.fromPolynomial(y.C0,c,n),y.L.subScalar(h),y.L.mulScalar(it);let _t=Ft.fromPolynomial(y.C1,c,n);_t.subScalar(U),_t.mulScalar(X);let wt=Ft.fromPolynomial(y.C2,c,n);wt.subScalar(G),wt.mulScalar(lt),y.L.add(_t),y.L.add(wt),n&&n.info("> Computing ZT polynomial"),await d();const ft=y.ZT.evaluate(T.y);if(y.F.mulScalar(ft),y.L.sub(y.F),y.L.degree()>=9*r.domainSize)throw new Error("L Polynomial is not well calculated");delete F.L}async function d(){y.ZT=Ft.zerofierPolynomial([C.S0.h0w8[0],C.S0.h0w8[1],C.S0.h0w8[2],C.S0.h0w8[3],C.S0.h0w8[4],C.S0.h0w8[5],C.S0.h0w8[6],C.S0.h0w8[7],C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3],C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],c)}async function S(){y.ZTS2=Ft.zerofierPolynomial([C.S1.h1w4[0],C.S1.h1w4[1],C.S1.h1w4[2],C.S1.h1w4[3],C.S2.h2w3[0],C.S2.h2w3[1],C.S2.h2w3[2],C.S2.h3w3[0],C.S2.h3w3[1],C.S2.h3w3[2]],c)}}function nt(){let R=T.xi;for(let S=0;S<r.power;S++)R=u.square(R);P.zh=u.sub(R,u.one),K(P,C.S0.h0w8,T.y,c),I(P,C.S1.h1w4,T.y,c),d(P,C.S2.h2w3,C.S2.h3w3,T.y,T.xi,T.xiw,c);const at=Math.max(1,r.nPublic);let J=u.one;for(let S=0;S<at;S++)P["Li_"+(S+1)]=u.mul(u.e(r.domainSize),u.sub(T.xi,J)),J=u.mul(J,u.w[r.power]);let k=u.one;for(const S of Object.values(P))if(Array.isArray(S))for(const h of S)k=u.mul(k,h);else k=u.mul(k,S);return u.inv(k);function K(S,h,U,G){const m=G.Fr,z=h.length,W=m.mul(m.e(z),m.exp(h[0],z-2)),it=[];for(let X=0;X<z;X++){const lt=h[(z-1)*X%z],_t=m.sub(U,h[X]);S[["LiS0_"+(X+1)]]=m.mul(m.mul(W,lt),_t)}return it}function I(S,h,U,G){const m=G.Fr,z=h.length,W=m.mul(m.e(z),m.exp(h[0],z-2)),it=[];for(let X=0;X<z;X++){const lt=h[(z-1)*X%z],_t=m.sub(U,h[X]);S[["LiS1_"+(X+1)]]=m.mul(m.mul(W,lt),_t)}return it}function d(S,h,U,G,m,z,W){const it=W.Fr,X=[],lt=it.mul(it.e(3),h[0]),_t=it.sub(m,z);let wt=it.mul(lt,_t);for(let ct=0;ct<3;ct++){const gt=h[2*ct%3],yt=it.sub(G,h[ct]);S[["LiS2_"+(ct+1)]]=it.mul(wt,it.mul(gt,yt))}const ft=it.mul(it.e(3),U[0]),st=it.sub(z,m);wt=it.mul(ft,st);for(let ct=0;ct<3;ct++){const gt=U[2*ct%3],yt=it.sub(G,U[ct]);S[["LiS2_"+(ct+1+3)]]=it.mul(wt,it.mul(gt,yt))}return X}}}const{unstringifyBigInts:hu}=rn;async function pu(e,t,n,a,i,o){const l=hu(e),s={type:"mem"};return await ci(l,t,s,i),await Os(n,s,a,o)}const{unstringifyBigInts:qi}=rn;async function wu(e,t,n,a){a&&a.info("FFLONK VERIFIER STARTED"),e=qi(e),n=qi(n);const i=await Yn(e.curve),o=Lu(i,e),l=new Fe(i,a);l.fromObjectProof(n);const s=qi(t);if(s.length!==o.nPublic)return a.error("Number of public signals does not match with vk"),!1;const f=i.Fr;if(a&&(a.info("----------------------------"),a.info("  FFLONK VERIFY SETTINGS"),a.info(`  Curve:         ${i.name}`),a.info(`  Circuit power: ${o.power}`),a.info(`  Domain size:   ${2**o.power}`),a.info(`  Public vars:   ${o.nPublic}`),a.info("----------------------------")),a&&a.info("> Checking commitments belong to G1"),!gu(i,l,o))return a&&a.error("Proof commitments are not valid"),!1;if(a&&a.info("> Checking evaluations belong to F"),!mu(i,l))return a&&a.error("Proof evaluations are not valid."),!1;if(a&&a.info("> Checking public inputs belong to F"),!bu(i,s))return a&&a.error("Public inputs are not valid."),!1;a&&a.info("> Computing challenges");const{challenges:r,roots:c}=yu(i,l,o,s,a);a&&a.info("> Computing Zero polynomial evaluation Z_H(xi)"),r.zh=f.sub(r.xiN,f.one),r.invzh=f.inv(r.zh),a&&a.info("> Computing Lagrange evaluations");const u=await Cu(i,r,o);a&&a.info("> Computing polynomial identities PI(X)");const b=Fu(i,s,u);a&&a.info("> Computing r0(y)");const w=Su(l,r,c,i,a);a&&a.info("> Computing r1(y)");const A=vu(l,r,c,b,i,a);a&&a.info("> Computing r2(y)");const x=Eu(l,r,c,u[1],o,i,a);a&&a.info("> Computing F");const v=Au(i,l,o,r,c);a&&a.info("> Computing E");const F=xu(i,l,r,o,w,A,x);a&&a.info("> Computing J");const y=Bu(i,l,r);a&&a.info("> Validate all evaluations with a pairing");const B=await Iu(i,l,r,o,v,F,y);return a&&(B?a.info("PROOF VERIFIED SUCCESSFULLY"):a.warn("Invalid Proof")),a&&a.info("FFLONK VERIFIER FINISHED"),B}function Lu(e,t){const n=t;return n.k1=e.Fr.fromObject(t.k1),n.k2=e.Fr.fromObject(t.k2),n.w=e.Fr.fromObject(t.w),n.w3=e.Fr.fromObject(t.w3),n.w4=e.Fr.fromObject(t.w4),n.w8=e.Fr.fromObject(t.w8),n.wr=e.Fr.fromObject(t.wr),n.X_2=e.G2.fromObject(t.X_2),n.C0=e.G1.fromObject(t.C0),n}function gu(e,t,n){const a=e.G1;return a.isValid(t.polynomials.C1)&&a.isValid(t.polynomials.C2)&&a.isValid(t.polynomials.W1)&&a.isValid(t.polynomials.W2)&&a.isValid(n.C0)}function zs(e,t){return St.geq(t,0)&&St.lt(t,e.r)}function dn(e,t){return zs(e,St.fromRprLE(t))}function mu(e,t){return dn(e,t.evaluations.ql)&&dn(e,t.evaluations.qr)&&dn(e,t.evaluations.qm)&&dn(e,t.evaluations.qo)&&dn(e,t.evaluations.qc)&&dn(e,t.evaluations.s1)&&dn(e,t.evaluations.s2)&&dn(e,t.evaluations.s3)&&dn(e,t.evaluations.a)&&dn(e,t.evaluations.b)&&dn(e,t.evaluations.c)&&dn(e,t.evaluations.z)&&dn(e,t.evaluations.zw)&&dn(e,t.evaluations.t1w)&&dn(e,t.evaluations.t2w)}function bu(e,t){for(let n=0;n<t.length;n++)if(!zs(e,t[n]))return!1;return!0}function yu(e,t,n,a,i){const o=e.Fr,l={},s={},f=new Wn(e);f.addPolCommitment(n.C0);for(let A=0;A<a.length;A++)f.addScalar(o.e(a[A]));f.addPolCommitment(t.polynomials.C1),l.beta=f.getChallenge(),f.reset(),f.addScalar(l.beta),l.gamma=f.getChallenge(),f.reset(),f.addScalar(l.gamma),f.addPolCommitment(t.polynomials.C2);const r=f.getChallenge(),c=o.square(r);let u=[];u[1]=n.w8,u[2]=o.square(n.w8),u[3]=o.mul(u[2],n.w8),u[4]=o.mul(u[3],n.w8),u[5]=o.mul(u[4],n.w8),u[6]=o.mul(u[5],n.w8),u[7]=o.mul(u[6],n.w8);let b=[];b[1]=n.w4,b[2]=o.square(n.w4),b[3]=o.mul(b[2],n.w4);let w=[];w[1]=n.w3,w[2]=o.square(n.w3),s.S0={},s.S0.h0w8=[],s.S0.h0w8[0]=o.mul(c,r);for(let A=1;A<8;A++)s.S0.h0w8[A]=o.mul(s.S0.h0w8[0],u[A]);s.S1={},s.S1.h1w4=[],s.S1.h1w4[0]=o.square(s.S0.h0w8[0]);for(let A=1;A<4;A++)s.S1.h1w4[A]=o.mul(s.S1.h1w4[0],b[A]);s.S2={},s.S2.h2w3=[],s.S2.h2w3[0]=o.mul(s.S1.h1w4[0],c),s.S2.h2w3[1]=o.mul(s.S2.h2w3[0],w[1]),s.S2.h2w3[2]=o.mul(s.S2.h2w3[0],w[2]),s.S2.h3w3=[],s.S2.h3w3[0]=o.mul(s.S2.h2w3[0],n.wr),s.S2.h3w3[1]=o.mul(s.S2.h3w3[0],w[1]),s.S2.h3w3[2]=o.mul(s.S2.h3w3[0],w[2]),l.xi=o.mul(o.square(s.S2.h2w3[0]),s.S2.h2w3[0]),l.xiw=o.mul(l.xi,o.w[n.power]),l.xiN=l.xi,n.domainSize=1;for(let A=0;A<n.power;A++)l.xiN=o.square(l.xiN),n.domainSize*=2;return f.reset(),f.addScalar(r),f.addScalar(t.evaluations.ql),f.addScalar(t.evaluations.qr),f.addScalar(t.evaluations.qm),f.addScalar(t.evaluations.qo),f.addScalar(t.evaluations.qc),f.addScalar(t.evaluations.s1),f.addScalar(t.evaluations.s2),f.addScalar(t.evaluations.s3),f.addScalar(t.evaluations.a),f.addScalar(t.evaluations.b),f.addScalar(t.evaluations.c),f.addScalar(t.evaluations.z),f.addScalar(t.evaluations.zw),f.addScalar(t.evaluations.t1w),f.addScalar(t.evaluations.t2w),l.alpha=f.getChallenge(),f.reset(),f.addScalar(l.alpha),f.addPolCommitment(t.polynomials.W1),l.y=f.getChallenge(),i&&(i.info(" challenges.beta:  "+o.toString(l.beta)),i.info(" challenges.gamma: "+o.toString(l.gamma)),i.info(" challenges.xi:    "+o.toString(l.xi)),i.info(" challenges.alpha: "+o.toString(l.alpha)),i.info(" challenges.y:     "+o.toString(l.y))),{challenges:l,roots:s}}async function Cu(e,t,n){const a=e.Fr,i=Math.max(1,n.nPublic),o=new ut(i*a.n8);let l=new ut(i*a.n8),s=a.one;for(let r=0;r<i;r++){const c=r*a.n8;o.set(a.mul(s,t.zh),c),l.set(a.mul(a.e(n.domainSize),a.sub(t.xi,s)),c),s=a.mul(s,n.w)}l=await a.batchInverse(l);let f=[];for(let r=0;r<i;r++){const c=r*a.n8;f[r+1]=a.mul(o.slice(c,c+a.n8),l.slice(c,c+a.n8))}return f}function Fu(e,t,n){const a=e.Fr;let i=a.zero;for(let o=0;o<t.length;o++){const l=a.e(t[o]);i=a.sub(i,a.mul(l,n[o+1]))}return i}function Su(e,t,n,a,i){const o=a.Fr,l=qs(n.S0.h0w8,t.y,t.xi,a);i&&i.info(" Computing r0(y)");let s=o.zero;for(let f=0;f<8;f++){let r=[];r[1]=n.S0.h0w8[f];for(let u=2;u<8;u++)r[u]=o.mul(r[u-1],n.S0.h0w8[f]);let c=o.add(e.evaluations.ql,o.mul(e.evaluations.qr,r[1]));c=o.add(c,o.mul(e.evaluations.qo,r[2])),c=o.add(c,o.mul(e.evaluations.qm,r[3])),c=o.add(c,o.mul(e.evaluations.qc,r[4])),c=o.add(c,o.mul(e.evaluations.s1,r[5])),c=o.add(c,o.mul(e.evaluations.s2,r[6])),c=o.add(c,o.mul(e.evaluations.s3,r[7])),s=o.add(s,o.mul(c,l[f]))}return s}function vu(e,t,n,a,i,o){const l=i.Fr,s=qs(n.S1.h1w4,t.y,t.xi,i);o&&o.info(" Computing T0(xi)");let f=l.mul(e.evaluations.ql,e.evaluations.a);f=l.add(f,l.mul(e.evaluations.qr,e.evaluations.b)),f=l.add(f,l.mul(e.evaluations.qm,l.mul(e.evaluations.a,e.evaluations.b))),f=l.add(f,l.mul(e.evaluations.qo,e.evaluations.c)),f=l.add(f,e.evaluations.qc),f=l.add(f,a),f=l.mul(f,t.invzh),o&&o.info(" Computing C1(h_1_4^i) values");let r=l.zero;for(let c=0;c<4;c++){let u=e.evaluations.a;u=l.add(u,l.mul(n.S1.h1w4[c],e.evaluations.b));const b=l.square(n.S1.h1w4[c]);u=l.add(u,l.mul(b,e.evaluations.c)),u=l.add(u,l.mul(l.mul(b,n.S1.h1w4[c]),f)),r=l.add(r,l.mul(u,s[c]))}return r}function Eu(e,t,n,a,i,o,l){const s=o.Fr,f=Pu([n.S2.h2w3,n.S2.h3w3],t.y,t.xi,t.xiw,o);l&&l.info(" Computing T1(xi)");let r=s.sub(e.evaluations.z,s.one);r=s.mul(r,a),r=s.mul(r,t.invzh),l&&l.info(" Computing T2(xi)");const c=s.mul(t.beta,t.xi),u=s.add(e.evaluations.a,s.add(c,t.gamma)),b=s.add(e.evaluations.b,s.add(s.mul(c,i.k1),t.gamma)),w=s.add(e.evaluations.c,s.add(s.mul(c,i.k2),t.gamma)),A=s.mul(u,s.mul(b,s.mul(w,e.evaluations.z))),x=s.add(e.evaluations.a,s.add(s.mul(t.beta,e.evaluations.s1),t.gamma)),v=s.add(e.evaluations.b,s.add(s.mul(t.beta,e.evaluations.s2),t.gamma)),F=s.add(e.evaluations.c,s.add(s.mul(t.beta,e.evaluations.s3),t.gamma)),y=s.mul(x,s.mul(v,s.mul(F,e.evaluations.zw)));let B=s.sub(A,y);B=s.mul(B,t.invzh),l&&l.info(" Computing C2(h_2_3^i) values");let P=s.zero;for(let T=0;T<3;T++){let C=s.add(e.evaluations.z,s.mul(n.S2.h2w3[T],r));C=s.add(C,s.mul(s.square(n.S2.h2w3[T]),B)),P=s.add(P,s.mul(C,f[T]))}l&&l.info(" Computing C2(h_3_3^i) values");for(let T=0;T<3;T++){let C=s.add(e.evaluations.zw,s.mul(n.S2.h3w3[T],e.evaluations.t1w));C=s.add(C,s.mul(s.square(n.S2.h3w3[T]),e.evaluations.t2w)),P=s.add(P,s.mul(C,f[T+3]))}return P}function Au(e,t,n,a,i){const o=e.G1,l=e.Fr;let s=l.sub(a.y,i.S0.h0w8[0]);for(let b=1;b<8;b++)s=l.mul(s,l.sub(a.y,i.S0.h0w8[b]));a.temp=s;let f=l.sub(a.y,i.S1.h1w4[0]);for(let b=1;b<4;b++)f=l.mul(f,l.sub(a.y,i.S1.h1w4[b]));let r=l.sub(a.y,i.S2.h2w3[0]);for(let b=1;b<3;b++)r=l.mul(r,l.sub(a.y,i.S2.h2w3[b]));for(let b=0;b<3;b++)r=l.mul(r,l.sub(a.y,i.S2.h3w3[b]));a.quotient1=l.mul(a.alpha,l.div(s,f)),a.quotient2=l.mul(l.square(a.alpha),l.div(s,r));let c=o.timesFr(t.polynomials.C1,a.quotient1),u=o.timesFr(t.polynomials.C2,a.quotient2);return o.add(n.C0,o.add(c,u))}function xu(e,t,n,a,i,o,l){const s=e.G1,f=e.Fr;let r=f.mul(o,n.quotient1),c=f.mul(l,n.quotient2);return s.timesFr(s.one,f.add(i,f.add(r,c)))}function Bu(e,t,n){return e.G1.timesFr(t.polynomials.W1,n.temp)}async function Iu(e,t,n,a,i,o,l){const s=e.G1;let f=s.timesFr(t.polynomials.W2,n.y);f=s.add(s.sub(s.sub(i,o),l),f);const r=e.G2.one,c=t.polynomials.W2,u=a.X_2;return await e.pairingEq(s.neg(f),r,c,u)}function qs(e,t,n,a){const i=a.Fr,o=e.length,l=i.sub(i.exp(t,o),n),s=i.mul(i.e(o),i.exp(e[0],o-2)),f=[];for(let r=0;r<o;r++){const c=e[(o-1)*r%o],u=i.sub(t,e[r]);f[r]=i.div(l,i.mul(i.mul(s,c),u))}return f}function Pu(e,t,n,a,i){const o=i.Fr,l=[],s=e[0].length,f=s*e.length,r=o.exp(t,f),c=o.mul(o.add(n,a),o.exp(t,s)),u=o.mul(n,a),b=o.add(o.sub(r,c),u);let w=o.mul(o.mul(o.e(s),e[0][0]),o.sub(n,a));for(let A=0;A<s;A++){const x=e[0][(s-1)*A%s],v=o.sub(t,e[0][A]),F=o.mul(w,o.mul(x,v));l[A]=o.div(b,F)}w=o.mul(o.mul(o.e(s),e[1][0]),o.sub(a,n));for(let A=0;A<s;A++){const x=e[1][(s-1)*A%s],v=o.sub(t,e[1][A]),F=o.mul(w,o.mul(x,v));l[A+s]=o.div(b,F)}return l}const{unstringifyBigInts:ho}=rn;function nn(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return t=`0x${t}`,t}async function Gu(e,t){const n=ho(t),a=ho(e);await Yn(n.curve);let i="";for(let o=0;o<a.length;o++)i!==""&&(i=i+","),i=i+nn(a[o]);return`[${nn(n.polynomials.C1[0])}, ${nn(n.polynomials.C1[1])},${nn(n.polynomials.C2[0])},${nn(n.polynomials.C2[1])},${nn(n.polynomials.W1[0])},${nn(n.polynomials.W1[1])},${nn(n.polynomials.W2[0])},${nn(n.polynomials.W2[1])},${nn(n.evaluations.ql)},${nn(n.evaluations.qr)},${nn(n.evaluations.qm)},${nn(n.evaluations.qo)},${nn(n.evaluations.qc)},${nn(n.evaluations.s1)},${nn(n.evaluations.s2)},${nn(n.evaluations.s3)},${nn(n.evaluations.a)},${nn(n.evaluations.b)},${nn(n.evaluations.c)},${nn(n.evaluations.z)},${nn(n.evaluations.zw)},${nn(n.evaluations.t1w)},${nn(n.evaluations.t2w)},${nn(n.evaluations.inv)}],[${i}]`}var ku=Object.freeze({__proto__:null,setup:_u,prove:Os,fullProve:pu,verify:wu,exportSolidityVerifier:xs,exportSolidityCallData:Gu});export{Tu as curves,ku as fflonk,Ou as groth16,Ru as plonk,zu as powersOfTau,qu as r1cs,Mu as wtns,Uu as zKey};
